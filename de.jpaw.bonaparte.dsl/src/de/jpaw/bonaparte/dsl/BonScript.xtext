 /*
  * Copyright 2012 Michael Bischoff
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
  
grammar de.jpaw.bonaparte.dsl.BonScript with org.eclipse.xtext.common.Terminals

generate bonScript "http://www.jpaw.de/bonaparte/dsl/BonScript"

Model:
    imports  += ImportDefinition*
    packages += PackageDefinition*
    //(extensions = ModelExtensionDefinition)      // Extensions only
;
    
QualifiedId: 
    ID ('.' ID)*
;

ImportDefinition:
    'import' importURI=STRING
;

// enums for field attributes. Defaults can be set at package or class level
enum XVisibility:
    PUBLIC='public' | PRIVATE='private' | PROTECTED='protected' | DEFAULT='default';  // default means standard Java visibility
enum XSignedness:
    SIGNED='signed' | UNSIGNED='unsigned';
enum XRequired:
    REQUIRED='required' | OPTIONAL='optional';
enum XTrimming:
    TRIM='trim' | NOTRIM='notrim';
enum XSpecialCharsSetting:
    ALLOW_CONTROL_CHARS = 'allowControlChars' | NO_CONTROL_CHARS = 'noControlChars';
enum XUsePrimitives:
    USE_PRIMITIVES = 'usePrimitives' | USE_BOXED = 'useBoxed';

// We need a special "undefined" setting for enums. According to the XText documentation (2.3, section 6.2.7),
// ECore does not support this currently. Therefore extra artificial types are required to represent null values.
// therefore all this weird workaround is required
Visibility:          x = XVisibility;
Signedness:          x = XSignedness;
Required:            x = XRequired;
Trimming:            x = XTrimming;
SpecialCharsSetting: x = XSpecialCharsSetting;
UsePrimitives:       x = XUsePrimitives;

FieldDefaultsDefinition:
    'default' {FieldDefaultsDefinition}
        (visibility    = Visibility)?             // default for classes, member fields
        ((signed       = Signedness)? &           // numeric integers: if not provided, default is signed
        (required      = Required)? &             // default is required for lower case types
        (trim          = Trimming)? &             // Unicode & Ascii: default is notrim (conserve leading and trailing spaces)
        (allowCtrls    = SpecialCharsSetting)? &  // Unicode fields: allow control characters: default: no
        (usePrimitives = UsePrimitives)?          // allow primitive types in objects, these can never be null
         // (rawFormat = ('hex' | 'base64'))?     // Raw data: how to serialize
         )
    ';'
;

// packages loosely correspond to Java packages, in OSGi environments, they would be mapped to application modules
PackageDefinition:
    //(annotations=PackageAnnotations)  // for extensions
    'package ' ('(' prefix=QualifiedId ')')? name=QualifiedId '{'  // prefix is generated but not stored in serialized form, default is de.jpaw.bonaparte.pojos
        (defaults  = FieldDefaultsDefinition)?
        types   += TypeDefinition*
        enums   += EnumDefinition*
        classes += ClassDefinition*
    '}'
;

// a class corresponds to a Java class
ClassDefinition:
    // (annotations=ClassAnnotations)  // for extensions
    // (isDeprecated?='@Deprecated')?
    (abstract?='abstract' | final?='final')? 'class' name=QualifiedId
    ('revision' revision = STRING)?
    ('extends' extendsClass=[ClassDefinition|QualifiedId])?
    '{'
        (defaults  = FieldDefaultsDefinition)?
        fields += FieldDefinition*   
    '}'
;

EnumDefinition:
    'enum' name = ID '{' values += ID (',' values += ID)+ '}'   
;

// type definitions can be used in the same or different packages. It is important to know that
// any package defaults will apply at the location where the type is defined. This means that
// the type expansion will have the same features in different packages, even if they use different defaults. 
TypeDefinition:
    'type' name = ID 'is' datatype = DataType ';'
;

// Careful: Due to implementation of the validators, FieldDefinition may only be referenced from the ClassDefinition type!
FieldDefinition:
    // (annotations=FieldAnnotations)  // for extensions, for example additional JSR303 like validations. Mixed feelings about this, because it actually violates the "single responsibility" principle.
    (visibility = Visibility)?
    (required   = Required)?
    datatype    = DataType
    (isArray    = ArrayModifier)?
    name        = ID ';'
;

DataType:
    (elementaryDataType=ElementaryDataType
        | ('(' objectDataType=[ClassDefinition|QualifiedId] (orSuperClass?='...')? ')')  // unfortunately parentheses needed to avoid conflict with typeRef
        | referenceDataType=[TypeDefinition|QualifiedId]
    )  
;

ArrayModifier:
    '[' {ArrayModifier} (maxcount=INT)? ']'
;
 
ElementaryDataType:
    (   name = ("boolean" | "Boolean"  | "day"       | "Day"       // some primitive types or their boxed equivalents
              | "char"    | "Char"     | "character" | "Character")  // day is 8 digit number, YYYYMMDD
      | (name = ('enum'| 'Enum') enumType = [EnumDefinition|QualifiedId])  // enums are not precisely elementary data types in Java, but they do not require recursing another class
      | (name= ("timestamp" | "Timestamp") ("(" length=INT ")")? )
      | ( 
         name=("ascii" | "Ascii" | "uppercase" | "Uppercase" | "lowercase" | "Lowercase")         "(" length=INT ")"
           (trim    ?= 'trim'     | notrim   ?= 'notrim')?
           ('regexp' regexp=STRING)?                )          // ASCII 7 bit chars (0x20 - 0x7e)
      | (name=("unicode"|"Unicode")       "(" length=INT ")"   // any displayable Unicode character
           (trimming   = Trimming)?          
           (allowCtrls = SpecialCharsSetting)?      // Unicode fields: allow control characters
        )
      | (
           (signed = Signedness)?
           (  (name=("decimal"|"Decimal")      "(" length=INT ("," decimals=INT)? ")")
             | (name=("number"|"Number")       "(" length=INT ")")  // maps to int, long, BigInteger (currently only int)
             | name=("byte"|"Byte"|"short"|"Short"|"integer"|"Integer"|"int"|"Int"|"long"|"Long"|"float"|"Float"|"double"|"Double")  // numeric primitives with sign only
           )
         )
      | (name=("raw"|"Raw")           "(" length=INT ")")  // byte array
    )   
;

// stubs for extensions (derived grammars) to overwrite without destroying anything in here
ModelExtensionDefinition:
    {ModelExtensionDefinition}
;

PackageAnnotations:
    {PackageAnnotations}
;

ClassAnnotations:
    {ClassAnnotations}
;

FieldAnnotations:
    {FieldAnnotations}
;
