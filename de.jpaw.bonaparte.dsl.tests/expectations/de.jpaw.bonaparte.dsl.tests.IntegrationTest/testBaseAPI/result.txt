{DEFAULT_OUTPUTdebug/app.crud.info==== PACKAGE app.crud (ROOT) ===
CLASS CrudRequest: EXTENDS RequestParameters abstract=false final=false
    //
    FIELD crud: local required = required, defaults: req=null)
    FIELD onlyActive: local required = required, defaults: req=null)
    FIELD version: local required = optional, defaults: req=null)
    FIELD key: local required = optional, defaults: req=null)
    FIELD data: local required = optional, defaults: req=null)

CLASS CrudResponse: EXTENDS ServiceResponse abstract=false final=false
    //
    FIELD tracking: local required = optional, defaults: req=null)
    FIELD key: local required = optional, defaults: req=null)
    FIELD data: local required = optional, defaults: req=null)

CLASS CrudNaturalKeyRequest: EXTENDS RequestParameters abstract=false final=false
    //
    FIELD crud: local required = required, defaults: req=null)
    FIELD onlyActive: local required = required, defaults: req=null)
    FIELD version: local required = optional, defaults: req=null)
    FIELD key: local required = optional, defaults: req=null)
    FIELD data: local required = optional, defaults: req=null)

CLASS CrudNaturalKeyResponse: EXTENDS ServiceResponse abstract=false final=false
    //
    FIELD tracking: local required = optional, defaults: req=null)
    FIELD key: local required = optional, defaults: req=null)
    FIELD data: local required = optional, defaults: req=null)

CLASS ReadAllRequest: EXTENDS RequestParameters abstract=false final=false
    //
    FIELD returnOnlyActive: local required = required, defaults: req=null)

CLASS DataWithTracking:  abstract=false final=false
    //
    FIELD tracking: local required = required, defaults: req=null)
    FIELD data: local required = required, defaults: req=null)

CLASS ReadAllResponse: EXTENDS ServiceResponse abstract=false final=false
    //
    FIELD dataList: local required = required, defaults: req=null)
    FIELD sinkRef: local required = optional, defaults: req=null)

CLASS RefResolverRequest: EXTENDS RequestParameters abstract=false final=false
    //
    FIELD ref: local required = required, defaults: req=null)

CLASS RefResolverResponse: EXTENDS ServiceResponse abstract=false final=false
    //
    FIELD key: local required = required, defaults: req=null)

, DEFAULT_OUTPUTdebug/app.search.info==== PACKAGE app.search (ROOT) ===
CLASS SearchCriteria: EXTENDS RequestParameters abstract=true final=false
    //
    FIELD searchFilters: defaults: req=null)
    FIELD searchOption: defaults: req=null)
    FIELD sortColumns: defaults: req=null)
    FIELD searchOutputTarget: defaults: req=null)

CLASS SearchOption:  abstract=false final=true
    //
    FIELD limit: local required = required, defaults: req=null)
    FIELD offset: local required = required, defaults: req=null)

CLASS SortColumn:  abstract=false final=true
    //
    FIELD fieldName: local required = required, defaults: req=null)
    FIELD ascending: local required = required, defaults: req=null)

CLASS SearchFilter:  abstract=true final=false
    //
    FIELD fieldName: local required = required, defaults: req=null)
    FIELD negateResult: local required = required, defaults: req=null)

CLASS NullFilter: EXTENDS SearchFilter abstract=false final=true
    //

CLASS BooleanFilter: EXTENDS SearchFilter abstract=false final=true
    //
    FIELD booleanValue: local required = required, defaults: req=null)

CLASS UnicodeFilter: EXTENDS SearchFilter abstract=false final=true
    //
    FIELD equalsValue: local required = optional, defaults: req=null)
    FIELD likeValue: local required = optional, defaults: req=null)

CLASS AsciiFilter: EXTENDS SearchFilter abstract=false final=true
    //
    FIELD equalsValue: local required = optional, defaults: req=null)
    FIELD likeValue: local required = optional, defaults: req=null)

CLASS IntFilter: EXTENDS SearchFilter abstract=false final=true
    //
    FIELD lowerBound: local required = optional, defaults: req=null)
    FIELD upperBound: local required = optional, defaults: req=null)

CLASS LongFilter: EXTENDS SearchFilter abstract=false final=true
    //
    FIELD lowerBound: local required = optional, defaults: req=null)
    FIELD upperBound: local required = optional, defaults: req=null)

CLASS NumericFilter: EXTENDS SearchFilter abstract=false final=true
    //
    FIELD lowerBound: local required = optional, defaults: req=null)
    FIELD upperBound: local required = optional, defaults: req=null)

CLASS DayFilter: EXTENDS SearchFilter abstract=false final=true
    //
    FIELD lowerBound: local required = optional, defaults: req=null)
    FIELD upperBound: local required = optional, defaults: req=null)

CLASS TimestampFilter: EXTENDS SearchFilter abstract=false final=true
    //
    FIELD lowerBound: local required = optional, defaults: req=null)
    FIELD upperBound: local required = optional, defaults: req=null)

CLASS EnumFilter: EXTENDS SearchFilter abstract=false final=true
    //
    FIELD enumClass: local required = required, defaults: req=null)
    FIELD enumName: local required = required, defaults: req=null)

CLASS SearchRequest: EXTENDS SearchCriteria abstract=false final=false
    //

, DEFAULT_OUTPUTdebug/base.api.info==== PACKAGE base.api (ROOT) ===
CLASS ServiceRequestHeader:  abstract=false final=false
    //
    FIELD tenantId: local required = required, defaults: req=null)
    FIELD userId: local required = required, defaults: req=null)
    FIELD idempotencyBehaviour: local required = required, defaults: req=null)
    FIELD languageCode: local required = optional, defaults: req=null)
    FIELD recordNo: local required = optional, defaults: req=null)
    FIELD messageId: local required = optional, defaults: req=null)
    FIELD plannedRunDate: local required = optional, defaults: req=null)
    FIELD authenticationParameters: local required = optional, defaults: req=null)

CLASS JmsServiceRequestHeader: EXTENDS ServiceRequestHeader abstract=false final=false
    //
    FIELD responseAddress: local required = optional, defaults: req=null)

CLASS AuthenticationParameters:  abstract=true final=false
    //

CLASS AuthX500DistinguishedName: EXTENDS AuthenticationParameters abstract=false final=false
    //
    FIELD distinguishedName: local required = required, defaults: req=null)

CLASS AuthSAML: EXTENDS AuthenticationParameters abstract=false final=false
    //
    FIELD samlToken: local required = required, defaults: req=null)

CLASS AuthFortytwo: EXTENDS AuthenticationParameters abstract=false final=false
    //
    FIELD fortytwoToken: local required = required, defaults: req=null)

CLASS RequestParameters:  abstract=true final=false
    //

CLASS ServiceRequest:  abstract=false final=false
    //
    FIELD requestHeader: local required = required, defaults: req=null)
    FIELD requestParameters: local required = required, defaults: req=null)

CLASS ServiceResponse:  abstract=false final=false
    //
    FIELD requestId: local required = optional, defaults: req=null)
    FIELD tenantId: local required = required, defaults: req=null)
    FIELD processRef: local required = required, defaults: req=null)
    FIELD returnCode: local required = required, defaults: req=null)
    FIELD errorDetails: local required = optional, defaults: req=null)
    FIELD errorMessage: local required = optional, defaults: req=null)

CLASS SessionParameters:  abstract=false final=false
    //
    FIELD executable: local required = required, defaults: req=null)
    FIELD dataUrl: local required = required, defaults: req=null)
    FIELD singleTenantId: local required = optional, defaults: req=null)

CLASS KeyValuePair:  abstract=false final=false
    //
    FIELD key: local required = required, defaults: req=null)
    FIELD value: local required = optional, defaults: req=null)

CLASS OutputSessionParameters:  abstract=false final=false
    //
    FIELD dataSinkId: local required = required, defaults: req=null)
    FIELD asOf: local required = required, defaults: req=null)
    FIELD additionalParameters: local required = optional, defaults: req=null)
    FIELD originatorRef: local required = optional, defaults: req=null)
    FIELD communicationFormatType: local required = optional, defaults: req=null)
    FIELD configurationRef: local required = optional, defaults: req=null)

CLASS PingRequest: EXTENDS RequestParameters abstract=false final=false
    //
    FIELD pingId: local required = optional, defaults: req=null)
    FIELD delayInMillis: local required = optional, defaults: req=null)

CLASS PingResponse: EXTENDS ServiceResponse abstract=false final=false
    //
    FIELD pingId: local required = optional, defaults: req=null)
    FIELD whenExecuted: local required = required, defaults: req=null)
    FIELD whenFinished: local required = required, defaults: req=null)

CLASS BatchRequest: EXTENDS RequestParameters abstract=false final=false
    //
    FIELD allowNo: defaults: req=null)
    FIELD commands: local required = required, defaults: req=null)

CLASS ErrorRequest: EXTENDS RequestParameters abstract=false final=false
    //
    FIELD returnCode: local required = required, defaults: req=null)
    FIELD errorDetails: local required = optional, defaults: req=null)
    FIELD originalMessage: local required = optional, defaults: req=null)

, DEFAULT_OUTPUTdebug/base.api.ping.info==== PACKAGE base.api.ping (ROOT) ===
CLASS BpmPingRequest: EXTENDS RequestParameters abstract=false final=false
    //
    FIELD iterations: defaults: req=null)
    FIELD delay: defaults: req=null)

, DEFAULT_OUTPUTdebug/base.api.types.info==== PACKAGE base.api.types (ROOT) ===
, DEFAULT_OUTPUTdebug/base.conf.info==== PACKAGE base.conf (ROOT) ===
CLASS ConfigRef: EXTENDS Ref abstract=false final=false
    //

CLASS ConfigKey: EXTENDS ConfigRef abstract=false final=false
    //
    FIELD configGroup: local required = required, defaults: req=null)
    FIELD configKey: local required = required, defaults: req=null)
    FIELD genericRef1: local required = required, defaults: req=null)
    FIELD genericRef2: local required = required, defaults: req=null)

CLASS AbstractConfigObject:  abstract=true final=false
    //

CLASS ConfigDTO: EXTENDS ConfigRef abstract=false final=false
    //
    FIELD configGroup: local required = required, defaults: req=null)
    FIELD configKey: local required = required, defaults: req=null)
    FIELD genericRef1: local required = required, defaults: req=null)
    FIELD genericRef2: local required = required, defaults: req=null)
    FIELD configTypeEnum: local required = required, defaults: req=null)
    FIELD booleanProperty: local required = optional, defaults: req=null)
    FIELD integerProperty: local required = optional, defaults: req=null)
    FIELD decimalProperty: local required = optional, defaults: req=null)
    FIELD stringProperty: local required = optional, defaults: req=null)
    FIELD objectProperty: local required = optional, defaults: req=null)

CLASS ReadConfigWithDefaultsRequest: EXTENDS RequestParameters abstract=false final=false
    //
    FIELD key: defaults: req=null)
    FIELD retryWithDefaultRef2: defaults: req=null)
    FIELD retryWithDefaultRef1: defaults: req=null)
    FIELD retryWithDefaultTenant: defaults: req=null)

CLASS ReadConfigWithDefaultsResponse: EXTENDS ServiceResponse abstract=false final=false
    //
    FIELD configurationResult: local required = optional, defaults: req=null)
    FIELD defaultsUsed: defaults: req=null)

CLASS ReadConfigMultipleEntriesRequest: EXTENDS RequestParameters abstract=false final=false
    //
    FIELD configGroup: local required = required, defaults: req=null)
    FIELD readGlobalTenant: local required = required, defaults: req=null)

CLASS ReadConfigMultipleEntriesResponse: EXTENDS ServiceResponse abstract=false final=false
    //
    FIELD entries: local required = required, defaults: req=null)

, DEFAULT_OUTPUTdebug/base.core.info==== PACKAGE base.core (ROOT) ===
CLASS SingleValueBase:  abstract=true final=false
    //

CLASS Integer_:  abstract=false final=false
    //
    FIELD value: defaults: req=null)

CLASS Long_:  abstract=false final=false
    //
    FIELD value: defaults: req=null)

CLASS Boolean_:  abstract=false final=false
    //
    FIELD value: defaults: req=null)

CLASS Day_:  abstract=false final=false
    //
    FIELD value: defaults: req=null)

CLASS Timestamp_:  abstract=false final=false
    //
    FIELD value: defaults: req=null)

CLASS Double_:  abstract=false final=false
    //
    FIELD value: defaults: req=null)

CLASS Ascii_:  abstract=false final=false
    //
    FIELD value: defaults: req=null)

CLASS Unicode_:  abstract=false final=false
    //
    FIELD value: defaults: req=null)

CLASS Uppercase_:  abstract=false final=false
    //
    FIELD value: defaults: req=null)

CLASS Decimal_:  abstract=false final=false
    //
    FIELD value: defaults: req=null)

CLASS Enum_:  abstract=false final=false
    //
    FIELD clazz: defaults: req=null)
    FIELD name: defaults: req=null)

, DEFAULT_OUTPUTdebug/base.data.info==== PACKAGE base.data (ROOT) ===
CLASS NoTracking:  abstract=false final=false
    //

CLASS WriteTracking: EXTENDS NoTracking abstract=false final=false
    //
    FIELD cTechUserId: local required = required, defaults: req=null)
    FIELD cAppUserRef: local required = required, defaults: req=null)
    FIELD cTimestamp: local required = required, defaults: req=null)
    FIELD cProcessRef: local required = required, defaults: req=null)

CLASS FullTracking: EXTENDS WriteTracking abstract=false final=false
    //
    FIELD mTechUserId: local required = required, defaults: req=null)
    FIELD mAppUserRef: local required = required, defaults: req=null)
    FIELD mTimestamp: local required = required, defaults: req=null)
    FIELD mProcessRef: local required = required, defaults: req=null)

CLASS FullTrackingWithActiveColumn: EXTENDS FullTracking abstract=false final=false
    //
    FIELD isActive: local required = required, defaults: req=null)

CLASS FullTrackingWithActiveColumnAndVersion: EXTENDS FullTrackingWithActiveColumn abstract=false final=false
    //
    FIELD version: local required = required, defaults: req=null)

CLASS FullTrackingWithVersion: EXTENDS FullTracking abstract=false final=false
    //
    FIELD version: local required = required, defaults: req=null)

CLASS AdditionalHistoryTableColumns:  abstract=false final=false
    //
    FIELD crud: defaults: req=null)
    FIELD historyNo: defaults: req=null)
    FIELD localTimestamp: local required = required, defaults: req=null)

CLASS Ref:  abstract=false final=false
    //
    FIELD objectRef: defaults: req=null)

CLASS NaturalKeyRef:  abstract=true final=false
    //

CLASS NaturalKeyBase:  abstract=true final=false
    //

CLASS UserRef: EXTENDS Ref abstract=false final=false
    //

CLASS UserKey: EXTENDS UserRef abstract=false final=true
    //
    FIELD userId: local required = required, local visibility = public, defaults: req=null)

CLASS User: EXTENDS UserRef abstract=false final=false
    //
    FIELD userId: local required = required, defaults: req=null)
    FIELD username: local required = required, defaults: req=null)
    FIELD isTechnical: local required = required, defaults: req=null)
    FIELD tenantId: local required = required, defaults: req=null)
    FIELD personRef: defaults: req=null)
    FIELD fullName: local required = optional, defaults: req=null)
    FIELD emailAddress: local required = optional, defaults: req=null)
    FIELD authenticationType: local required = required, defaults: req=null)
    FIELD phoneNo: local required = optional, defaults: req=null)
    FIELD commonName: local required = optional, defaults: req=null)
    FIELD noLogging: local required = required, defaults: req=null)

CLASS UserStatus: EXTENDS Ref abstract=false final=false
    //
    FIELD lastSuccessfulLogin: local required = required, defaults: req=null)
    FIELD currentPasswordSerialNumber: local required = required, defaults: req=null)
    FIELD numberOfIncorrectAttempts: local required = required, defaults: req=null)
    FIELD accountThrottledUntil: local required = optional, defaults: req=null)

CLASS Password: EXTENDS Ref abstract=false final=false
    //
    FIELD passwordSerialNumber: local required = required, defaults: req=null)
    FIELD passwordHash: local required = required, defaults: req=null)
    FIELD passwordExpiry: local required = required, defaults: req=null)
    FIELD userExpiry: local required = required, defaults: req=null)
    FIELD passwordCreation: local required = required, defaults: req=null)
    FIELD passwordSetByUser: local required = required, defaults: req=null)

CLASS TenantRef: EXTENDS Ref abstract=false final=false
    //

CLASS TenantKey: EXTENDS TenantRef abstract=false final=true
    //
    FIELD tenantId: local required = required, local visibility = public, defaults: req=null)

CLASS Tenant: EXTENDS TenantRef abstract=false final=false
    //
    FIELD tenantId: local required = required, defaults: req=null)
    FIELD name: local required = required, defaults: req=null)
    FIELD customizationRef: local required = optional, defaults: req=null)
    FIELD customizationUIRef: local required = optional, defaults: req=null)
    FIELD customizationRepRef: local required = optional, defaults: req=null)
    FIELD passwordMinimumLength: local required = optional, defaults: req=null)
    FIELD passwordDifferPreviousN: local required = optional, defaults: req=null)
    FIELD passwordExpirationInDays: local required = optional, defaults: req=null)
    FIELD passwordResetDurationInSec: local required = optional, defaults: req=null)
    FIELD passwordThrottlingAfterX: local required = optional, defaults: req=null)
    FIELD passwordThrottlingDuration: local required = optional, defaults: req=null)
    FIELD passwordBlockingPeriod: local required = optional, defaults: req=null)

CLASS Customization: EXTENDS Ref abstract=false final=false
    //
    FIELD customizationId: local required = required, defaults: req=null)
    FIELD parentRef: local required = optional, defaults: req=null)
    FIELD customizationType: local required = required, defaults: req=null)
    FIELD name: local required = required, defaults: req=null)

CLASS EntityCustomizationEntry:  abstract=false final=false
    //
    FIELD customizationRef: local required = required, defaults: req=null)
    FIELD rtti: local required = required, defaults: req=null)
    FIELD dataTransferObjClassName: local required = required, defaults: req=null)
    FIELD entityClassName: local required = required, defaults: req=null)
    FIELD isInherited: local required = required, defaults: req=null)

CLASS RequestHandlerCustomizationEntry:  abstract=false final=false
    //
    FIELD customizationRef: local required = required, defaults: req=null)
    FIELD requestClassName: local required = required, defaults: req=null)
    FIELD requestHandlerClassName: local required = required, defaults: req=null)

CLASS TranslationKey: EXTENDS NaturalKeyRef abstract=false final=true
    //
    FIELD targetObjectRef: local required = required, defaults: req=null)
    FIELD languageCode: local required = required, defaults: req=null)

CLASS TranslationDTO: EXTENDS NaturalKeyBase abstract=false final=false
    //
    FIELD targetObjectRef: local required = required, defaults: req=null)
    FIELD languageCode: local required = required, defaults: req=null)
    FIELD tenantRef: local required = required, defaults: req=null)
    FIELD name: defaults: req=null)

, DEFAULT_OUTPUTdebug/base.input.info==== PACKAGE base.input (ROOT) ===
CLASS ImportRef: EXTENDS Ref abstract=false final=false
    //

CLASS ImportKey: EXTENDS ImportRef abstract=false final=true
    //
    FIELD importConfigId: local required = required, defaults: req=null)

CLASS ImportConfigDto: EXTENDS ImportRef abstract=false final=false
    //
    FIELD importConfigId: local required = required, defaults: req=null)
    FIELD format: local required = optional, defaults: req=null)
    FIELD inputChannelType: local required = optional, defaults: req=null)
    FIELD camelConfig: local required = required, defaults: req=null)
    FIELD uri: local required = optional, defaults: req=null)
    FIELD baseClassName: local required = required, defaults: req=null)
    FIELD importTypeClassName: local required = required, defaults: req=null)
    FIELD split: local required = required, defaults: req=null)
    FIELD tenantRef: local required = optional, defaults: req=null)
    FIELD userRef: local required = optional, defaults: req=null)

CLASS ImportPreConfig: EXTENDS ImportRef abstract=false final=true
    //
    FIELD importConfigId: local required = required, defaults: req=null)
    FIELD uri: local required = required, defaults: req=null)
    FIELD format: local required = optional, defaults: req=null)
    FIELD inputChannelType: local required = optional, defaults: req=null)

CLASS ImportConfigCrudRequest: EXTENDS CrudRequest abstract=false final=false
    //

CLASS ImportConfigSearchRequest: EXTENDS SearchRequest abstract=false final=false
    //

CLASS ImportRequest: EXTENDS RequestParameters abstract=false final=false
    //
    FIELD importRef: local required = required, defaults: req=null)

, DEFAULT_OUTPUTdebug/base.messaging.info==== PACKAGE base.messaging (ROOT) ===
CLASS DocumentCreatedCallbackRequest: EXTENDS RequestParameters abstract=false final=false
    //
    FIELD communicationFormatType: local required = optional, defaults: req=null)
    FIELD sinkRef: local required = optional, defaults: req=null)
    FIELD originatorRef: local required = optional, defaults: req=null)
    FIELD configurationRef: local required = optional, defaults: req=null)
    FIELD returnCode: local required = optional, defaults: req=null)
    FIELD returnDetails: local required = optional, defaults: req=null)

CLASS RequestHandlerConfigRef: EXTENDS Ref abstract=false final=false
    //

CLASS RequestHandlerConfigKey: EXTENDS RequestHandlerConfigRef abstract=false final=true
    //
    FIELD tenantRef: local required = required, local visibility = public, defaults: req=null)
    FIELD jobRequestObjectName: local required = required, defaults: req=null)

CLASS RequestHandlerConfigDTO: EXTENDS RequestHandlerConfigRef abstract=false final=false
    //
    FIELD tenantRef: local required = required, local visibility = public, defaults: req=null)
    FIELD jobRequestObjectName: local required = required, defaults: req=null)
    FIELD category: local required = required, defaults: req=null)
    FIELD moduleId: local required = required, defaults: req=null)
    FIELD name: local required = required, defaults: req=null)
    FIELD jobParameters: local required = optional, defaults: req=null)

CLASS SinkRef: EXTENDS Ref abstract=false final=false
    //

CLASS Sink: EXTENDS SinkRef abstract=false final=false
    //
    FIELD commTargetChannelType: local required = required, defaults: req=null)
    FIELD commFormatType: local required = required, defaults: req=null)
    FIELD fileOrQueueName: local required = required, defaults: req=null)
    FIELD numberOfSourceRecords: local required = optional, defaults: req=null)
    FIELD numberOfMappedRecords: local required = optional, defaults: req=null)
    FIELD plannedRunDate: local required = optional, defaults: req=null)
    FIELD originatorRef: local required = optional, defaults: req=null)
    FIELD configurationRef: local required = optional, defaults: req=null)
    FIELD dataSinkRef: local required = required, defaults: req=null)
    FIELD fileSize: local required = optional, defaults: req=null)

CLASS SinkCreatedResponse: EXTENDS ServiceResponse abstract=false final=false
    //
    FIELD sinkRef: local required = required, defaults: req=null)

CLASS FileDownloadRequest: EXTENDS RequestParameters abstract=false final=false
    //
    FIELD sinkRef: local required = required, defaults: req=null)
    FIELD offset: local required = required, defaults: req=null)
    FIELD limit: local required = required, defaults: req=null)

CLASS FileDownloadResponse: EXTENDS ServiceResponse abstract=false final=false
    //
    FIELD sink: local required = required, defaults: req=null)
    FIELD hasMore: local required = required, defaults: req=null)
    FIELD data: local required = required, defaults: req=null)

CLASS FileUploadRequest: EXTENDS RequestParameters abstract=false final=false
    //
    FIELD parameters: local required = required, defaults: req=null)
    FIELD data: local required = required, defaults: req=null)

CLASS SourceRef: EXTENDS Ref abstract=false final=false
    //

CLASS Source: EXTENDS SourceRef abstract=false final=false
    //
    FIELD executable: defaults: req=null)
    FIELD hostname: defaults: req=null)
    FIELD dataUrl: defaults: req=null)
    FIELD singleTenantId: defaults: req=null)
    FIELD osUserId: local required = required, defaults: req=null)
    FIELD numberOfRecords: defaults: req=null)
    FIELD numberSuccessful: defaults: req=null)
    FIELD numberDuplicate: defaults: req=null)
    FIELD executableStartedAt: local required = required, defaults: req=null)
    FIELD firstRecordProcessedAt: defaults: req=null)
    FIELD lastRecordProcessedAt: defaults: req=null)
    FIELD executableStoppedAt: defaults: req=null)

CLASS DataSinkRef: EXTENDS Ref abstract=false final=false
    //

CLASS DataSinkKey: EXTENDS DataSinkRef abstract=false final=true
    //
    FIELD tenantRef: local required = required, local visibility = public, defaults: req=null)
    FIELD dataSinkId: local required = required, local visibility = public, defaults: req=null)

CLASS DataSinkFilterProps: EXTENDS DataSinkRef abstract=false final=true
    //
    FIELD tenantRef: local required = required, defaults: req=null)
    FIELD dataSinkId: local required = required, defaults: req=null)
    FIELD commTargetChannelType: local required = required, defaults: req=null)
    FIELD commFormatType: local required = required, defaults: req=null)
    FIELD category: local required = required, defaults: req=null)

CLASS DataSink: EXTENDS DataSinkRef abstract=false final=false
    //
    FIELD tenantRef: local required = required, defaults: req=null)
    FIELD dataSinkId: local required = required, defaults: req=null)
    FIELD commTargetChannelType: local required = required, defaults: req=null)
    FIELD commFormatType: local required = required, defaults: req=null)
    FIELD fileOrQueueNamePattern: local required = required, defaults: req=null)
    FIELD compressed: local required = required, defaults: req=null)
    FIELD originatorModule: local required = optional, defaults: req=null)
    FIELD preTransformerName: local required = optional, defaults: req=null)
    FIELD commFormatName: local required = optional, defaults: req=null)
    FIELD camelRoute: local required = optional, defaults: req=null)
    FIELD category: local required = required, defaults: req=null)
    FIELD callbackRef: local required = optional, defaults: req=null)

CLASS DemoRecord:  abstract=false final=false
    //
    FIELD recordNo: local required = required, defaults: req=null)
    FIELD minusPi: local required = required, defaults: req=null)
    FIELD hello: local required = required, defaults: req=null)
    FIELD today: local required = required, defaults: req=null)
    FIELD now: local required = required, defaults: req=null)
    FIELD none: local required = optional, defaults: req=null)
    FIELD yes: local required = required, defaults: req=null)
    FIELD no: local required = required, defaults: req=null)

, DEFAULT_OUTPUTdebug/base.security.info==== PACKAGE base.security (ROOT) ===
CLASS AuthenticationRequest: EXTENDS RequestParameters abstract=false final=false
    //
    FIELD passwordHash: local required = optional, defaults: req=null)
    FIELD authenticationType: local required = required, defaults: req=null)

CLASS AuthenticationDetails:  abstract=false final=false
    //
    FIELD whenLastLoggedIn: defaults: req=null)
    FIELD passwordExpires: defaults: req=null)
    FIELD numberInvalidAttempts: defaults: req=null)

CLASS AuthenticationResponse: EXTENDS ServiceResponse abstract=false final=false
    //
    FIELD userInformation: defaults: req=null)
    FIELD userHistory: defaults: req=null)
    FIELD allowedTenants: defaults: req=null)

CLASS AuthorizationRequest: EXTENDS RequestParameters abstract=false final=false
    //
    FIELD userId: local required = required, defaults: req=null)
    FIELD tenantId: local required = required, defaults: req=null)
    FIELD likePermissionName: local required = optional, defaults: req=null)
    FIELD onlyPermissionType: local required = optional, defaults: req=null)

CLASS AuthorizationResponse: EXTENDS ServiceResponse abstract=false final=false
    //
    FIELD resultingPermissions: defaults: req=null)

CLASS RoleRef: EXTENDS Ref abstract=false final=false
    //

CLASS RoleKey: EXTENDS RoleRef abstract=false final=true
    //
    FIELD tenantRef: local required = required, defaults: req=null)
    FIELD roleId: local required = required, defaults: req=null)

CLASS Role: EXTENDS RoleRef abstract=false final=false
    //
    FIELD tenantRef: local required = required, defaults: req=null)
    FIELD roleId: local required = required, defaults: req=null)
    FIELD name: local required = required, defaults: req=null)

CLASS RoleToPermission:  abstract=false final=false
    //
    FIELD tenantRef: local required = required, defaults: req=null)
    FIELD roleRef: local required = required, defaults: req=null)
    FIELD permissionId: local required = required, defaults: req=null)

CLASS UserTenantRole:  abstract=false final=false
    //
    FIELD userRef: local required = required, defaults: req=null)
    FIELD tenantRef: local required = required, defaults: req=null)
    FIELD roleRef: local required = required, defaults: req=null)

CLASS PermissionRef: EXTENDS Ref abstract=false final=false
    //

CLASS PermissionKey: EXTENDS PermissionRef abstract=false final=true
    //
    FIELD tenantRef: local required = required, defaults: req=null)
    FIELD permissionId: local required = required, defaults: req=null)

CLASS Permission: EXTENDS PermissionRef abstract=false final=false
    //
    FIELD tenantRef: local required = required, defaults: req=null)
    FIELD permissionId: local required = required, defaults: req=null)
    FIELD permissionType: local required = required, defaults: req=null)

, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/crud/CrudNaturalKeyRequest.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.crud;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.api.types.Crud;
import com.arvatosystems.fortytwo.base.api.RequestParameters;
import com.arvatosystems.fortytwo.base.data.NaturalKeyRef;
import com.arvatosystems.fortytwo.base.data.NaturalKeyBase;


/**
     * The base class to be used for CRUD specific requests for entities which have a natural key.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class CrudNaturalKeyRequest<DATA extends NaturalKeyBase, KEY extends NaturalKeyRef> extends RequestParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -80063761232L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return com.arvatosystems.fortytwo.app.crud.CrudNaturalKeyResponse.class;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return RequestParameters.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.crud.CrudNaturalKeyRequest";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.RequestParameters";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$crud$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "crud$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$crud = new EnumDataItem(Visibility.DEFAULT, true, "crud", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "Crud", false, "Crud", null);
    protected static final MiscElementaryDataItem meta$$onlyActive = new MiscElementaryDataItem(Visibility.DEFAULT, true, "onlyActive", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", true);
    protected static final NumericElementaryDataItem meta$$version = new NumericElementaryDataItem(Visibility.DEFAULT, false, "version", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    protected static final ObjectReference meta$$key = new ObjectReference(Visibility.DEFAULT, false, "key", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "KEY", false, true, "KEY");
    protected static final ObjectReference meta$$data = new ObjectReference(Visibility.DEFAULT, false, "data", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "DATA", false, true, "DATA");
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(5);
        FieldDefinition [] field$array = new FieldDefinition[5];
        field$array[0] = meta$$crud;
        field$array[1] = meta$$onlyActive;
        field$array[2] = meta$$version;
        field$array[3] = meta$$key;
        field$array[4] = meta$$data;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // specifies the command !
    Crud crud;
    // work on active records only, fail if record exists, but is inactive !
    boolean onlyActive;
    // this is a required field for all crud except INSERT and READ !
    Integer version;
    // the key object !
    KEY key;
    // the full data record !
    DATA data;
    // auto-generated getters and setters
    public Crud getCrud() {
        return crud;
    }
    public void setCrud(Crud crud) {
        this.crud = crud;
    }
    public boolean getOnlyActive() {
        return onlyActive;
    }
    public void setOnlyActive(boolean onlyActive) {
        this.onlyActive = onlyActive;
    }
    public Integer getVersion() {
        return version;
    }
    public void setVersion(Integer version) {
        this.version = version;
    }
    public KEY getKey() {
        return key;
    }
    public void setKey(KEY key) {
        this.key = key;
    }
    public DATA getData() {
        return data;
    }
    public void setData(DATA data) {
        this.data = data;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$crud$token, crud == null ? null : crud.getToken());
        w.addField(onlyActive);
        if (version == null) w.writeNull(meta$$version); else w.addField(version);
        w.addField((BonaPortable)key);
        w.addField((BonaPortable)data);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("crud")) {
            w.addField(meta$$crud$token, crud == null ? null : crud.getToken());
            return;
        }
        if (_n.equals("onlyActive")) {
            w.addField(onlyActive);
            return;
        }
        if (_n.equals("version")) {
            if (version == null) w.writeNull(meta$$version); else w.addField(version);
            return;
        }
        if (_n.equals("key")) {
            if (key == null) {
                w.writeNull(meta$$key);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)key);             // full / recursive object output
            } else {
                // write a specific subcomponent
                key.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        if (_n.equals("data")) {
            if (data == null) {
                w.writeNull(meta$$data);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)data);             // full / recursive object output
            } else {
                // write a specific subcomponent
                data.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        try {  // for possible EnumExceptions
        crud = com.arvatosystems.fortytwo.base.api.types.Crud.factory(p.readString("crud", false, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        onlyActive = p.readBoolean   ("onlyActive", false);
        version = p.readInteger   ("version", true, false);
        key = (KEY)p.readObject("key", NaturalKeyRef.class, true, true);
        data = (DATA)p.readObject("data", NaturalKeyBase.class, true, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (crud == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "crud", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (key != null)
            key.validate();  // check object
        if (data != null)
            data.validate();  // check object
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (crud == null ? 0 : crud.hashCode());
        _hash = 29 * _hash + (onlyActive ? 1231 : 1237);
        _hash = 29 * _hash + (version == null ? 0 : version.hashCode());
        _hash = 29 * _hash + (key == null ? 0 : key.hashCode());
        _hash = 29 * _hash + (data == null ? 0 : data.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof CrudNaturalKeyRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof CrudNaturalKeyRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        CrudNaturalKeyRequest<DATA, KEY> that = (CrudNaturalKeyRequest<DATA, KEY>)_that;
        return super.equalsSub(_that)
        && ((crud == null && that.crud == null) || (crud != null && crud.equals(that.crud)))
        && onlyActive == that.onlyActive
        && ((version == null && that.version == null) || (version != null && version.equals(that.version)))
        && ((key == null && that.key == null) || (key != null && key.hasSameContentsAs(that.key)))
        && ((data == null && that.data == null) || (data != null && data.hasSameContentsAs(that.data)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        if (key != null)
            key.treeWalkString(_cvt);
        if (data != null)
            data.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public CrudNaturalKeyRequest() {
        super();
    }
    
    // default all-arguments constructor
    public CrudNaturalKeyRequest(Crud crud
    , boolean onlyActive
    , Integer version
    , KEY key
    , DATA data
    ) {
        super();
        this.crud = crud;
        this.onlyActive = onlyActive;
        this.version = version;
        this.key = key;
        this.data = data;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == CrudNaturalKeyRequest.class) {
            return (T) new CrudNaturalKeyRequest(getCrud(), getOnlyActive(), getVersion(), getKey(), getData());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/crud/CrudNaturalKeyResponse.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.crud;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.api.ServiceResponse;
import com.arvatosystems.fortytwo.base.data.NaturalKeyRef;
import com.arvatosystems.fortytwo.base.data.NoTracking;
import com.arvatosystems.fortytwo.base.data.NaturalKeyBase;


/**
     * The base class to be used for CRUD specific responses for entities which have a natural key.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class CrudNaturalKeyResponse<DATA extends NaturalKeyBase, KEY extends NaturalKeyRef, TRACKING extends NoTracking> extends ServiceResponse
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -164193798611L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return ServiceResponse.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return ServiceResponse.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.crud.CrudNaturalKeyResponse";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.ServiceResponse";
    private static final String BUNDLE = null;
    
    protected static final ObjectReference meta$$tracking = new ObjectReference(Visibility.DEFAULT, false, "tracking", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "TRACKING", false, true, "TRACKING");
    protected static final ObjectReference meta$$key = new ObjectReference(Visibility.DEFAULT, false, "key", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "KEY", false, true, "KEY");
    protected static final ObjectReference meta$$data = new ObjectReference(Visibility.DEFAULT, false, "data", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "DATA", false, true, "DATA");
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(3);
        FieldDefinition [] field$array = new FieldDefinition[3];
        field$array[0] = meta$$tracking;
        field$array[1] = meta$$key;
        field$array[2] = meta$$data;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // the tracking columns, returned for READ commands !
    TRACKING tracking;
    // the key object !
    KEY key;
    // the full data record !
    DATA data;
    // auto-generated getters and setters
    public TRACKING getTracking() {
        return tracking;
    }
    public void setTracking(TRACKING tracking) {
        this.tracking = tracking;
    }
    public KEY getKey() {
        return key;
    }
    public void setKey(KEY key) {
        this.key = key;
    }
    public DATA getData() {
        return data;
    }
    public void setData(DATA data) {
        this.data = data;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField((BonaPortable)tracking);
        w.addField((BonaPortable)key);
        w.addField((BonaPortable)data);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("tracking")) {
            if (tracking == null) {
                w.writeNull(meta$$tracking);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)tracking);             // full / recursive object output
            } else {
                // write a specific subcomponent
                tracking.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        if (_n.equals("key")) {
            if (key == null) {
                w.writeNull(meta$$key);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)key);             // full / recursive object output
            } else {
                // write a specific subcomponent
                key.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        if (_n.equals("data")) {
            if (data == null) {
                w.writeNull(meta$$data);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)data);             // full / recursive object output
            } else {
                // write a specific subcomponent
                data.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        tracking = (TRACKING)p.readObject("tracking", NoTracking.class, true, true);
        key = (KEY)p.readObject("key", NaturalKeyRef.class, true, true);
        data = (DATA)p.readObject("data", NaturalKeyBase.class, true, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (tracking != null)
            tracking.validate();  // check object
        if (key != null)
            key.validate();  // check object
        if (data != null)
            data.validate();  // check object
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (tracking == null ? 0 : tracking.hashCode());
        _hash = 29 * _hash + (key == null ? 0 : key.hashCode());
        _hash = 29 * _hash + (data == null ? 0 : data.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof CrudNaturalKeyResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof CrudNaturalKeyResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        CrudNaturalKeyResponse<DATA, KEY, TRACKING> that = (CrudNaturalKeyResponse<DATA, KEY, TRACKING>)_that;
        return super.equalsSub(_that)
        && ((tracking == null && that.tracking == null) || (tracking != null && tracking.hasSameContentsAs(that.tracking)))
        && ((key == null && that.key == null) || (key != null && key.hasSameContentsAs(that.key)))
        && ((data == null && that.data == null) || (data != null && data.hasSameContentsAs(that.data)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        if (tracking != null)
            tracking.treeWalkString(_cvt);
        if (key != null)
            key.treeWalkString(_cvt);
        if (data != null)
            data.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public CrudNaturalKeyResponse() {
        super();
    }
    
    // default all-arguments constructor
    public CrudNaturalKeyResponse(ByteArray requestId
    , String tenantId
    , Long processRef
    , int returnCode
    , String errorDetails
    , String errorMessage
    , TRACKING tracking
    , KEY key
    , DATA data
    ) {
        super(requestId
        , tenantId
        , processRef
        , returnCode
        , errorDetails
        , errorMessage
        );
        this.tracking = tracking;
        this.key = key;
        this.data = data;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == CrudNaturalKeyResponse.class) {
            return (T) new CrudNaturalKeyResponse(getRequestId(), getTenantId(), getProcessRef(), getReturnCode(), getErrorDetails(), getErrorMessage(), getTracking(), getKey(), getData());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/crud/CrudRequest.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.crud;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;
import com.arvatosystems.fortytwo.base.api.types.Crud;
import com.arvatosystems.fortytwo.base.api.RequestParameters;


/**
     * The base class to be used for CRUD specific requests for entities which have an artificial key.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class CrudRequest<DATA extends Ref> extends RequestParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -1667422478L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return com.arvatosystems.fortytwo.app.crud.CrudResponse.class;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return RequestParameters.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.crud.CrudRequest";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.RequestParameters";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$crud$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "crud$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$crud = new EnumDataItem(Visibility.DEFAULT, true, "crud", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "Crud", false, "Crud", null);
    protected static final MiscElementaryDataItem meta$$onlyActive = new MiscElementaryDataItem(Visibility.DEFAULT, true, "onlyActive", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", true);
    protected static final NumericElementaryDataItem meta$$version = new NumericElementaryDataItem(Visibility.DEFAULT, false, "version", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$key = new NumericElementaryDataItem(Visibility.DEFAULT, false, "key", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final ObjectReference meta$$data = new ObjectReference(Visibility.DEFAULT, false, "data", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "DATA", false, true, "DATA");
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(5);
        FieldDefinition [] field$array = new FieldDefinition[5];
        field$array[0] = meta$$crud;
        field$array[1] = meta$$onlyActive;
        field$array[2] = meta$$version;
        field$array[3] = meta$$key;
        field$array[4] = meta$$data;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // specifies the command !
    Crud crud;
    // work on active records only, fail if record exists, but is inactive !
    boolean onlyActive;
    // this is a required field for all crud except INSERT and READ !
    Integer version;
    // the artificial key !
    Long key;
    // the full data record !
    DATA data;
    // auto-generated getters and setters
    public Crud getCrud() {
        return crud;
    }
    public void setCrud(Crud crud) {
        this.crud = crud;
    }
    public boolean getOnlyActive() {
        return onlyActive;
    }
    public void setOnlyActive(boolean onlyActive) {
        this.onlyActive = onlyActive;
    }
    public Integer getVersion() {
        return version;
    }
    public void setVersion(Integer version) {
        this.version = version;
    }
    public Long getKey() {
        return key;
    }
    public void setKey(Long key) {
        this.key = key;
    }
    public DATA getData() {
        return data;
    }
    public void setData(DATA data) {
        this.data = data;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$crud$token, crud == null ? null : crud.getToken());
        w.addField(onlyActive);
        if (version == null) w.writeNull(meta$$version); else w.addField(version);
        if (key == null) w.writeNull(meta$$key); else w.addField(key);
        w.addField((BonaPortable)data);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("crud")) {
            w.addField(meta$$crud$token, crud == null ? null : crud.getToken());
            return;
        }
        if (_n.equals("onlyActive")) {
            w.addField(onlyActive);
            return;
        }
        if (_n.equals("version")) {
            if (version == null) w.writeNull(meta$$version); else w.addField(version);
            return;
        }
        if (_n.equals("key")) {
            if (key == null) w.writeNull(meta$$key); else w.addField(key);
            return;
        }
        if (_n.equals("data")) {
            if (data == null) {
                w.writeNull(meta$$data);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)data);             // full / recursive object output
            } else {
                // write a specific subcomponent
                data.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        try {  // for possible EnumExceptions
        crud = com.arvatosystems.fortytwo.base.api.types.Crud.factory(p.readString("crud", false, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        onlyActive = p.readBoolean   ("onlyActive", false);
        version = p.readInteger   ("version", true, false);
        key = p.readLong      ("key", true, false);
        data = (DATA)p.readObject("data", Ref.class, true, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (crud == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "crud", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (data != null)
            data.validate();  // check object
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (crud == null ? 0 : crud.hashCode());
        _hash = 29 * _hash + (onlyActive ? 1231 : 1237);
        _hash = 29 * _hash + (version == null ? 0 : version.hashCode());
        _hash = 29 * _hash + (key == null ? 0 : key.hashCode());
        _hash = 29 * _hash + (data == null ? 0 : data.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof CrudRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof CrudRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        CrudRequest<DATA> that = (CrudRequest<DATA>)_that;
        return super.equalsSub(_that)
        && ((crud == null && that.crud == null) || (crud != null && crud.equals(that.crud)))
        && onlyActive == that.onlyActive
        && ((version == null && that.version == null) || (version != null && version.equals(that.version)))
        && ((key == null && that.key == null) || (key != null && key.equals(that.key)))
        && ((data == null && that.data == null) || (data != null && data.hasSameContentsAs(that.data)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        if (data != null)
            data.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public CrudRequest() {
        super();
    }
    
    // default all-arguments constructor
    public CrudRequest(Crud crud
    , boolean onlyActive
    , Integer version
    , Long key
    , DATA data
    ) {
        super();
        this.crud = crud;
        this.onlyActive = onlyActive;
        this.version = version;
        this.key = key;
        this.data = data;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == CrudRequest.class) {
            return (T) new CrudRequest(getCrud(), getOnlyActive(), getVersion(), getKey(), getData());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/crud/CrudResponse.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.crud;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.api.ServiceResponse;
import com.arvatosystems.fortytwo.base.data.NoTracking;


/**
     * The base class to be used for CRUD specific responses for entities which have an artificial key.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class CrudResponse<DATA extends BonaPortable, TRACKING extends NoTracking> extends ServiceResponse
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 15529839659L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return ServiceResponse.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return ServiceResponse.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.crud.CrudResponse";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.ServiceResponse";
    private static final String BUNDLE = null;
    
    protected static final ObjectReference meta$$tracking = new ObjectReference(Visibility.DEFAULT, false, "tracking", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "TRACKING", false, true, "TRACKING");
    protected static final NumericElementaryDataItem meta$$key = new NumericElementaryDataItem(Visibility.DEFAULT, false, "key", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final ObjectReference meta$$data = new ObjectReference(Visibility.DEFAULT, false, "data", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "DATA", false, true, "DATA");
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(3);
        FieldDefinition [] field$array = new FieldDefinition[3];
        field$array[0] = meta$$tracking;
        field$array[1] = meta$$key;
        field$array[2] = meta$$data;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // the tracking columns, returned for READ commands !
    TRACKING tracking;
    // the artificial key !
    Long key;
    // the full data record !
    DATA data;
    // auto-generated getters and setters
    public TRACKING getTracking() {
        return tracking;
    }
    public void setTracking(TRACKING tracking) {
        this.tracking = tracking;
    }
    public Long getKey() {
        return key;
    }
    public void setKey(Long key) {
        this.key = key;
    }
    @XmlAnyElement
    public DATA getData() {
        return data;
    }
    public void setData(DATA data) {
        this.data = data;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField((BonaPortable)tracking);
        if (key == null) w.writeNull(meta$$key); else w.addField(key);
        w.addField((BonaPortable)data);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("tracking")) {
            if (tracking == null) {
                w.writeNull(meta$$tracking);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)tracking);             // full / recursive object output
            } else {
                // write a specific subcomponent
                tracking.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        if (_n.equals("key")) {
            if (key == null) w.writeNull(meta$$key); else w.addField(key);
            return;
        }
        if (_n.equals("data")) {
            if (data == null) {
                w.writeNull(meta$$data);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)data);             // full / recursive object output
            } else {
                // write a specific subcomponent
                data.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        tracking = (TRACKING)p.readObject("tracking", NoTracking.class, true, true);
        key = p.readLong      ("key", true, false);
        data = (DATA)p.readObject("data", BonaPortable.class, true, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (tracking != null)
            tracking.validate();  // check object
        if (data != null)
            data.validate();  // check object
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (tracking == null ? 0 : tracking.hashCode());
        _hash = 29 * _hash + (key == null ? 0 : key.hashCode());
        _hash = 29 * _hash + (data == null ? 0 : data.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof CrudResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof CrudResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        CrudResponse<DATA, TRACKING> that = (CrudResponse<DATA, TRACKING>)_that;
        return super.equalsSub(_that)
        && ((tracking == null && that.tracking == null) || (tracking != null && tracking.hasSameContentsAs(that.tracking)))
        && ((key == null && that.key == null) || (key != null && key.equals(that.key)))
        && ((data == null && that.data == null) || (data != null && data.hasSameContentsAs(that.data)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        if (tracking != null)
            tracking.treeWalkString(_cvt);
        if (data != null)
            data.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public CrudResponse() {
        super();
    }
    
    // default all-arguments constructor
    public CrudResponse(ByteArray requestId
    , String tenantId
    , Long processRef
    , int returnCode
    , String errorDetails
    , String errorMessage
    , TRACKING tracking
    , Long key
    , DATA data
    ) {
        super(requestId
        , tenantId
        , processRef
        , returnCode
        , errorDetails
        , errorMessage
        );
        this.tracking = tracking;
        this.key = key;
        this.data = data;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == CrudResponse.class) {
            return (T) new CrudResponse(getRequestId(), getTenantId(), getProcessRef(), getReturnCode(), getErrorDetails(), getErrorMessage(), getTracking(), getKey(), getData());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/crud/DataWithTracking.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.crud;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.NoTracking;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class DataWithTracking<DATA extends BonaPortable, TRACKING extends NoTracking>
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -550766806L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.crud.DataWithTracking";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final ObjectReference meta$$tracking = new ObjectReference(Visibility.DEFAULT, true, "tracking", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "TRACKING", false, true, "TRACKING");
    protected static final ObjectReference meta$$data = new ObjectReference(Visibility.DEFAULT, true, "data", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "DATA", false, true, "DATA");
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$tracking;
        field$array[1] = meta$$data;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    TRACKING tracking;
    DATA data;
    // auto-generated getters and setters
    public TRACKING getTracking() {
        return tracking;
    }
    public void setTracking(TRACKING tracking) {
        this.tracking = tracking;
    }
    @XmlAnyElement
    public DATA getData() {
        return data;
    }
    public void setData(DATA data) {
        this.data = data;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField((BonaPortable)tracking);
        w.addField((BonaPortable)data);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("tracking")) {
            if (tracking == null) {
                w.writeNull(meta$$tracking);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)tracking);             // full / recursive object output
            } else {
                // write a specific subcomponent
                tracking.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        if (_n.equals("data")) {
            if (data == null) {
                w.writeNull(meta$$data);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)data);             // full / recursive object output
            } else {
                // write a specific subcomponent
                data.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        tracking = (TRACKING)p.readObject("tracking", NoTracking.class, false, true);
        data = (DATA)p.readObject("data", BonaPortable.class, false, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (tracking == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "tracking", PARTIALLY_QUALIFIED_CLASS_NAME);
        tracking.validate();      // check object (!= null checked before)
        if (data == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "data", PARTIALLY_QUALIFIED_CLASS_NAME);
        data.validate();      // check object (!= null checked before)
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (tracking == null ? 0 : tracking.hashCode());
        _hash = 29 * _hash + (data == null ? 0 : data.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof DataWithTracking))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof DataWithTracking))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        DataWithTracking<DATA, TRACKING> that = (DataWithTracking<DATA, TRACKING>)_that;
        return true
        && ((tracking == null && that.tracking == null) || (tracking != null && tracking.hasSameContentsAs(that.tracking)))
        && ((data == null && that.data == null) || (data != null && data.hasSameContentsAs(that.data)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        if (tracking != null)
            tracking.treeWalkString(_cvt);
        if (data != null)
            data.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public DataWithTracking() {
    }
    
    // default all-arguments constructor
    public DataWithTracking(TRACKING tracking
    , DATA data
    ) {
        this.tracking = tracking;
        this.data = data;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == DataWithTracking.class) {
            return (T) new DataWithTracking(getTracking(), getData());
        }
        throw new IllegalArgumentException("DataWithTracking does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/crud/ReadAllRequest.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.crud;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;
import com.arvatosystems.fortytwo.base.api.RequestParameters;


/**
     * A simple request to return all relevant data records for a JPA entity. Do not use for tables which could contain huge data sets.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class ReadAllRequest<DATA extends Ref> extends RequestParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -79692192963L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return com.arvatosystems.fortytwo.app.crud.ReadAllResponse.class;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return RequestParameters.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.crud.ReadAllRequest";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.RequestParameters";
    private static final String BUNDLE = null;
    
    protected static final MiscElementaryDataItem meta$$returnOnlyActive = new MiscElementaryDataItem(Visibility.DEFAULT, true, "returnOnlyActive", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", true);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$returnOnlyActive;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    boolean returnOnlyActive;
    // auto-generated getters and setters
    public boolean getReturnOnlyActive() {
        return returnOnlyActive;
    }
    public void setReturnOnlyActive(boolean returnOnlyActive) {
        this.returnOnlyActive = returnOnlyActive;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(returnOnlyActive);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("returnOnlyActive")) {
            w.addField(returnOnlyActive);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        returnOnlyActive = p.readBoolean   ("returnOnlyActive", false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (returnOnlyActive ? 1231 : 1237);
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ReadAllRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ReadAllRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        ReadAllRequest<DATA> that = (ReadAllRequest<DATA>)_that;
        return super.equalsSub(_that)
        && returnOnlyActive == that.returnOnlyActive
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public ReadAllRequest() {
        super();
    }
    
    // default all-arguments constructor
    public ReadAllRequest(boolean returnOnlyActive
    ) {
        super();
        this.returnOnlyActive = returnOnlyActive;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == ReadAllRequest.class) {
            return (T) new ReadAllRequest(getReturnOnlyActive());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/crud/ReadAllResponse.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.crud;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.api.ServiceResponse;
import com.arvatosystems.fortytwo.base.data.NoTracking;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class ReadAllResponse<DATA extends BonaPortable, TRACKING extends NoTracking> extends ServiceResponse
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -152675182272L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return ServiceResponse.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return ServiceResponse.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.crud.ReadAllResponse";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.ServiceResponse";
    private static final String BUNDLE = null;
    
    protected static final ObjectReference meta$$dataList = new ObjectReference(Visibility.DEFAULT, true, "dataList", Multiplicity.LIST, 0, 0, 0, DataCategory.OBJECT,
        "DataWithTracking<DATA, TRACKING>", false, false, "DataWithTracking<DATA, TRACKING>");
    protected static final NumericElementaryDataItem meta$$sinkRef = new NumericElementaryDataItem(Visibility.DEFAULT, false, "sinkRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$dataList;
        field$array[1] = meta$$sinkRef;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // the list of results !
    List<DataWithTracking<DATA, TRACKING>> dataList;
    // contains the result if an export was called (in which case the result list is empty) !
    Long sinkRef;
    // auto-generated getters and setters
    public List<DataWithTracking<DATA, TRACKING>> getDataList() {
        return dataList;
    }
    public void setDataList(List<DataWithTracking<DATA, TRACKING>> dataList) {
        this.dataList = dataList;
    }
    public Long getSinkRef() {
        return sinkRef;
    }
    public void setSinkRef(Long sinkRef) {
        this.sinkRef = sinkRef;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (dataList == null) {
            w.writeNullCollection(meta$$dataList);
        } else {
            w.startArray(dataList.size(), 0, 0);
            for (DataWithTracking<DATA, TRACKING> _i : dataList)
                w.addField((BonaPortable)_i);
            w.terminateArray();
        }
        if (sinkRef == null) w.writeNull(meta$$sinkRef); else w.addField(sinkRef);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("dataList")) {
            if (dataList == null) {
                w.writeNullCollection(meta$$dataList);
            } else {
                if (pfc.index < 0) {
                    w.startArray(dataList.size(), 0, 0);
                    for (DataWithTracking<DATA, TRACKING> _i : dataList) {
                        if (_i == null) {
                            w.writeNull(meta$$dataList);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)_i);             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            _i.foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                    w.terminateArray();
                } else {
                    if (pfc.index < dataList.size()) {
                        // output single element
                        if (dataList.get(pfc.index) == null) {
                            w.writeNull(meta$$dataList);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)dataList.get(pfc.index));             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            dataList.get(pfc.index).foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                }
            }
            return;
        }
        if (_n.equals("sinkRef")) {
            if (sinkRef == null) w.writeNull(meta$$sinkRef); else w.addField(sinkRef);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        _length = p.parseArrayStart("dataList", false, 0, 0);
        if (_length < 0) {
            dataList = null;
        } else {
            dataList = new ArrayList<DataWithTracking<DATA, TRACKING>>(_length);
            for (int _i = 0; _i < _length; ++_i)
                dataList.add((DataWithTracking<DATA, TRACKING>)p.readObject("dataList", DataWithTracking.class, false, false));
            p.parseArrayEnd();
        }
        sinkRef = p.readLong      ("sinkRef", true, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (dataList == null)   // initial check for aggregate type itself, it may not be NULL
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "dataList", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (dataList != null)
            for (DataWithTracking<DATA, TRACKING> _i : dataList)
        if (_i == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "_i", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (dataList != null)
            for (DataWithTracking<DATA, TRACKING> _i : dataList)
        _i.validate();      // check object (!= null checked before)
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (dataList == null ? 0 : dataList.hashCode());
        _hash = 29 * _hash + (sinkRef == null ? 0 : sinkRef.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ReadAllResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ReadAllResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        ReadAllResponse<DATA, TRACKING> that = (ReadAllResponse<DATA, TRACKING>)_that;
        return super.equalsSub(_that)
        && ((dataList == null && that.dataList == null) || (dataList != null && that.dataList != null && xCompareSub$dataList(that)))
        && ((sinkRef == null && that.sinkRef == null) || (sinkRef != null && sinkRef.equals(that.sinkRef)))
        ;
    }
    private boolean xCompareSub$dataList(ReadAllResponse<DATA, TRACKING> that) {
        // both dataList and that dataList are known to be not null
        if (dataList.size() != that.dataList.size())
            return false;
        // indexed access is not optional, but sequential access will be left for later optimization
        for (int _i = 0; _i < dataList.size(); ++_i)
            if (!(((dataList.get(_i) == null && that.dataList.get(_i) == null) || (dataList.get(_i) != null && dataList.get(_i).hasSameContentsAs(that.dataList.get(_i))))))
                return false;
        return true;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        if (dataList != null)
            for (DataWithTracking<DATA, TRACKING> _i : dataList)
        if (_i != null)
            _i.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public ReadAllResponse() {
        super();
    }
    
    // default all-arguments constructor
    public ReadAllResponse(ByteArray requestId
    , String tenantId
    , Long processRef
    , int returnCode
    , String errorDetails
    , String errorMessage
    , List<DataWithTracking<DATA, TRACKING>> dataList
    , Long sinkRef
    ) {
        super(requestId
        , tenantId
        , processRef
        , returnCode
        , errorDetails
        , errorMessage
        );
        this.dataList = dataList;
        this.sinkRef = sinkRef;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == ReadAllResponse.class) {
            return (T) new ReadAllResponse(getRequestId(), getTenantId(), getProcessRef(), getReturnCode(), getErrorDetails(), getErrorMessage(), getDataList(), getSinkRef());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/crud/RefResolverRequest.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.crud;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;
import com.arvatosystems.fortytwo.base.api.RequestParameters;


/**
     * The base class to be used for Resolver specific requests for the artificial key.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class RefResolverRequest<REF extends Ref> extends RequestParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 157083141075L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return com.arvatosystems.fortytwo.app.crud.RefResolverResponse.class;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return RequestParameters.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.crud.RefResolverRequest";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.RequestParameters";
    private static final String BUNDLE = null;
    
    protected static final ObjectReference meta$$ref = new ObjectReference(Visibility.DEFAULT, true, "ref", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "REF", false, true, "REF");
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$ref;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // the reference to the data !
    REF ref;
    // auto-generated getters and setters
    public REF getRef() {
        return ref;
    }
    public void setRef(REF ref) {
        this.ref = ref;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField((BonaPortable)ref);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("ref")) {
            if (ref == null) {
                w.writeNull(meta$$ref);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)ref);             // full / recursive object output
            } else {
                // write a specific subcomponent
                ref.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        ref = (REF)p.readObject("ref", Ref.class, false, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (ref == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "ref", PARTIALLY_QUALIFIED_CLASS_NAME);
        ref.validate();      // check object (!= null checked before)
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (ref == null ? 0 : ref.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof RefResolverRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof RefResolverRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        RefResolverRequest<REF> that = (RefResolverRequest<REF>)_that;
        return super.equalsSub(_that)
        && ((ref == null && that.ref == null) || (ref != null && ref.hasSameContentsAs(that.ref)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        if (ref != null)
            ref.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public RefResolverRequest() {
        super();
    }
    
    // default all-arguments constructor
    public RefResolverRequest(REF ref
    ) {
        super();
        this.ref = ref;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == RefResolverRequest.class) {
            return (T) new RefResolverRequest(getRef());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/crud/RefResolverResponse.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.crud;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.api.ServiceResponse;


/**
     * The base class to be used for Resolver specific responses for the artificial key.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class RefResolverResponse extends ServiceResponse
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -126969132182L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return ServiceResponse.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return ServiceResponse.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.crud.RefResolverResponse";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.ServiceResponse";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$key = new NumericElementaryDataItem(Visibility.DEFAULT, true, "key", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$key;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // the artificial key !
    Long key;
    // auto-generated getters and setters
    public Long getKey() {
        return key;
    }
    public void setKey(Long key) {
        this.key = key;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (key == null) w.writeNull(meta$$key); else w.addField(key);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("key")) {
            if (key == null) w.writeNull(meta$$key); else w.addField(key);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        key = p.readLong      ("key", false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (key == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "key", PARTIALLY_QUALIFIED_CLASS_NAME);
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (key == null ? 0 : key.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof RefResolverResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof RefResolverResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        RefResolverResponse that = (RefResolverResponse)_that;
        return super.equalsSub(_that)
        && ((key == null && that.key == null) || (key != null && key.equals(that.key)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public RefResolverResponse() {
        super();
    }
    
    // default all-arguments constructor
    public RefResolverResponse(ByteArray requestId
    , String tenantId
    , Long processRef
    , int returnCode
    , String errorDetails
    , String errorMessage
    , Long key
    ) {
        super(requestId
        , tenantId
        , processRef
        , returnCode
        , errorDetails
        , errorMessage
        );
        this.key = key;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == RefResolverResponse.class) {
            return (T) new RefResolverResponse(getRequestId(), getTenantId(), getProcessRef(), getReturnCode(), getErrorDetails(), getErrorMessage(), getKey());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/crud/package-info.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

@XmlJavaTypeAdapters({
    @XmlJavaTypeAdapter(type=LocalDate.class,       value=LocalDateAdapter.class),
    @XmlJavaTypeAdapter(type=LocalTime.class,       value=LocalTimeAdapter.class),
    @XmlJavaTypeAdapter(type=LocalDateTime.class,   value=LocalDateTimeAdapter.class),
    @XmlJavaTypeAdapter(type=ByteArray.class,       value=ByteArrayAdapter.class)
})
package com.arvatosystems.fortytwo.app.crud;

import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapters;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import org.joda.time.LocalTime;
import de.jpaw.util.ByteArray;

import de.jpaw.xml.jaxb.ByteArrayAdapter;
import de.jpaw.xml.jaxb.LocalDateAdapter;
import de.jpaw.xml.jaxb.LocalTimeAdapter;
import de.jpaw.xml.jaxb.LocalDateTimeAdapter;
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/search/AsciiFilter.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.search;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Provides filtering for ASCII text fields (IDs, tokens). Exactly one of the parameters equalsValue and likeValue must be provided, the other one must be null.
     * If both parameters are null or both are not equal to null, an "invalid search filter" parameter error is returned. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public final class AsciiFilter extends SearchFilter
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -173687374423L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return SearchFilter.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return SearchFilter.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.search.AsciiFilter";
    private static final String REVISION = null;
    private static final String PARENT = "app.search.SearchFilter";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$equalsValue = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "equalsValue", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 80, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$likeValue = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "likeValue", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 80, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$equalsValue;
        field$array[1] = meta$$likeValue;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    String equalsValue;
    String likeValue;
    // auto-generated getters and setters
    public String getEqualsValue() {
        return equalsValue;
    }
    public void setEqualsValue(String equalsValue) {
        this.equalsValue = equalsValue;
    }
    public String getLikeValue() {
        return likeValue;
    }
    public void setLikeValue(String likeValue) {
        this.likeValue = likeValue;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$equalsValue, equalsValue);
        w.addField(meta$$likeValue, likeValue);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("equalsValue")) {
            w.addField(meta$$equalsValue, equalsValue);
            return;
        }
        if (_n.equals("likeValue")) {
            w.addField(meta$$likeValue, likeValue);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        equalsValue = p.readString    ("equalsValue", true, 80, true, false, false, false);
        likeValue = p.readString    ("likeValue", true, 80, true, false, false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (equalsValue != null) {
            if (equalsValue.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "equalsValue.length=" + equalsValue.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (likeValue != null) {
            if (likeValue.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "likeValue.length=" + likeValue.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (equalsValue == null ? 0 : equalsValue.hashCode());
        _hash = 29 * _hash + (likeValue == null ? 0 : likeValue.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AsciiFilter))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AsciiFilter))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        AsciiFilter that = (AsciiFilter)_that;
        return super.equalsSub(_that)
        && ((equalsValue == null && that.equalsValue == null) || (equalsValue != null && equalsValue.equals(that.equalsValue)))
        && ((likeValue == null && that.likeValue == null) || (likeValue != null && likeValue.equals(that.likeValue)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        equalsValue = _cvt.convert(equalsValue, meta$$equalsValue);
        likeValue = _cvt.convert(likeValue, meta$$likeValue);
    }
    // default no-argument constructor
    public AsciiFilter() {
        super();
    }
    
    // default all-arguments constructor
    public AsciiFilter(String fieldName
    , boolean negateResult
    , String equalsValue
    , String likeValue
    ) {
        super(fieldName
        , negateResult
        );
        this.equalsValue = equalsValue;
        this.likeValue = likeValue;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == AsciiFilter.class) {
            return (T) new AsciiFilter(getFieldName(), getNegateResult(), getEqualsValue(), getLikeValue());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/search/BooleanFilter.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.search;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Provides filtering for boolean values. The result set is the subset of all rows which have the same boolean setting for the given field. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public final class BooleanFilter extends SearchFilter
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -277094361426L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return SearchFilter.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return SearchFilter.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.search.BooleanFilter";
    private static final String REVISION = null;
    private static final String PARENT = "app.search.SearchFilter";
    private static final String BUNDLE = null;
    
    protected static final MiscElementaryDataItem meta$$booleanValue = new MiscElementaryDataItem(Visibility.DEFAULT, true, "booleanValue", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", true);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$booleanValue;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    boolean booleanValue;
    // auto-generated getters and setters
    public boolean getBooleanValue() {
        return booleanValue;
    }
    public void setBooleanValue(boolean booleanValue) {
        this.booleanValue = booleanValue;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(booleanValue);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("booleanValue")) {
            w.addField(booleanValue);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        booleanValue = p.readBoolean   ("booleanValue", false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (booleanValue ? 1231 : 1237);
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof BooleanFilter))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof BooleanFilter))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        BooleanFilter that = (BooleanFilter)_that;
        return super.equalsSub(_that)
        && booleanValue == that.booleanValue
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public BooleanFilter() {
        super();
    }
    
    // default all-arguments constructor
    public BooleanFilter(String fieldName
    , boolean negateResult
    , boolean booleanValue
    ) {
        super(fieldName
        , negateResult
        );
        this.booleanValue = booleanValue;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == BooleanFilter.class) {
            return (T) new BooleanFilter(getFieldName(), getNegateResult(), getBooleanValue());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/search/DayFilter.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.search;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Provides filtering for calendar dates (full days). 
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public final class DayFilter extends SearchFilter
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 232993428618L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return SearchFilter.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return SearchFilter.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.search.DayFilter";
    private static final String REVISION = null;
    private static final String PARENT = "app.search.SearchFilter";
    private static final String BUNDLE = null;
    
    protected static final TemporalElementaryDataItem meta$$lowerBound = new TemporalElementaryDataItem(Visibility.DEFAULT, false, "lowerBound", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDate", false, 0, false);
    protected static final TemporalElementaryDataItem meta$$upperBound = new TemporalElementaryDataItem(Visibility.DEFAULT, false, "upperBound", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDate", false, 0, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$lowerBound;
        field$array[1] = meta$$upperBound;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    LocalDate lowerBound;
    LocalDate upperBound;
    // auto-generated getters and setters
    public LocalDate getLowerBound() {
        return lowerBound;
    }
    public void setLowerBound(LocalDate lowerBound) {
        this.lowerBound = lowerBound;
    }
    public LocalDate getUpperBound() {
        return upperBound;
    }
    public void setUpperBound(LocalDate upperBound) {
        this.upperBound = upperBound;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$lowerBound, lowerBound);
        w.addField(meta$$upperBound, upperBound);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("lowerBound")) {
            w.addField(meta$$lowerBound, lowerBound);
            return;
        }
        if (_n.equals("upperBound")) {
            w.addField(meta$$upperBound, upperBound);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        lowerBound = p.readDay("lowerBound", true);
        upperBound = p.readDay("upperBound", true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (lowerBound == null ? 0 : lowerBound.hashCode());
        _hash = 29 * _hash + (upperBound == null ? 0 : upperBound.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof DayFilter))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof DayFilter))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        DayFilter that = (DayFilter)_that;
        return super.equalsSub(_that)
        && ((lowerBound == null && that.lowerBound == null) || (lowerBound != null && lowerBound.equals(that.lowerBound)))
        && ((upperBound == null && that.upperBound == null) || (upperBound != null && upperBound.equals(that.upperBound)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public DayFilter() {
        super();
    }
    
    // default all-arguments constructor
    public DayFilter(String fieldName
    , boolean negateResult
    , LocalDate lowerBound
    , LocalDate upperBound
    ) {
        super(fieldName
        , negateResult
        );
        this.lowerBound = lowerBound;
        this.upperBound = upperBound;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == DayFilter.class) {
            return (T) new DayFilter(getFieldName(), getNegateResult(), getLowerBound(), getUpperBound());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/search/EnumFilter.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.search;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Provides filtering for enum.  Should not be used. If it is possible to fill enumClass, then it should
     * also be possible to call getToken() at the caller and use a regular AsciiFilter.
     * Reflection should be avoided where possible.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
@Deprecated
public final class EnumFilter extends SearchFilter
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 242970924015L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return SearchFilter.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return SearchFilter.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.search.EnumFilter";
    private static final String REVISION = null;
    private static final String PARENT = "app.search.SearchFilter";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$enumClass = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "enumClass", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 100, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$enumName = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "enumName", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 30, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$enumClass;
        field$array[1] = meta$$enumName;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    String enumClass;
    String enumName;
    // auto-generated getters and setters
    public String getEnumClass() {
        return enumClass;
    }
    public void setEnumClass(String enumClass) {
        this.enumClass = enumClass;
    }
    public String getEnumName() {
        return enumName;
    }
    public void setEnumName(String enumName) {
        this.enumName = enumName;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$enumClass, enumClass);
        w.addField(meta$$enumName, enumName);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("enumClass")) {
            w.addField(meta$$enumClass, enumClass);
            return;
        }
        if (_n.equals("enumName")) {
            w.addField(meta$$enumName, enumName);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        enumClass = p.readString    ("enumClass", false, 100, true, false, false, false);
        enumName = p.readString    ("enumName", false, 30, true, false, false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (enumClass == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "enumClass", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (enumName == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "enumName", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (enumClass != null) {
            if (enumClass.length() > 100)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "enumClass.length=" + enumClass.length() + " > 100",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (enumName != null) {
            if (enumName.length() > 30)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "enumName.length=" + enumName.length() + " > 30",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (enumClass == null ? 0 : enumClass.hashCode());
        _hash = 29 * _hash + (enumName == null ? 0 : enumName.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof EnumFilter))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof EnumFilter))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        EnumFilter that = (EnumFilter)_that;
        return super.equalsSub(_that)
        && ((enumClass == null && that.enumClass == null) || (enumClass != null && enumClass.equals(that.enumClass)))
        && ((enumName == null && that.enumName == null) || (enumName != null && enumName.equals(that.enumName)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        enumClass = _cvt.convert(enumClass, meta$$enumClass);
        enumName = _cvt.convert(enumName, meta$$enumName);
    }
    // default no-argument constructor
    public EnumFilter() {
        super();
    }
    
    // default all-arguments constructor
    public EnumFilter(String fieldName
    , boolean negateResult
    , String enumClass
    , String enumName
    ) {
        super(fieldName
        , negateResult
        );
        this.enumClass = enumClass;
        this.enumName = enumName;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == EnumFilter.class) {
            return (T) new EnumFilter(getFieldName(), getNegateResult(), getEnumClass(), getEnumName());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/search/IntFilter.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.search;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Provides filtering for integral values. At least one parameter must be provided. In order to search for exactly one value, both parameters must be set to the same value.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public final class IntFilter extends SearchFilter
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -252120302525L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return SearchFilter.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return SearchFilter.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.search.IntFilter";
    private static final String REVISION = null;
    private static final String PARENT = "app.search.SearchFilter";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$lowerBound = new NumericElementaryDataItem(Visibility.DEFAULT, false, "lowerBound", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$upperBound = new NumericElementaryDataItem(Visibility.DEFAULT, false, "upperBound", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$lowerBound;
        field$array[1] = meta$$upperBound;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    Integer lowerBound;
    Integer upperBound;
    // auto-generated getters and setters
    public Integer getLowerBound() {
        return lowerBound;
    }
    public void setLowerBound(Integer lowerBound) {
        this.lowerBound = lowerBound;
    }
    public Integer getUpperBound() {
        return upperBound;
    }
    public void setUpperBound(Integer upperBound) {
        this.upperBound = upperBound;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (lowerBound == null) w.writeNull(meta$$lowerBound); else w.addField(lowerBound);
        if (upperBound == null) w.writeNull(meta$$upperBound); else w.addField(upperBound);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("lowerBound")) {
            if (lowerBound == null) w.writeNull(meta$$lowerBound); else w.addField(lowerBound);
            return;
        }
        if (_n.equals("upperBound")) {
            if (upperBound == null) w.writeNull(meta$$upperBound); else w.addField(upperBound);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        lowerBound = p.readInteger   ("lowerBound", true, false);
        upperBound = p.readInteger   ("upperBound", true, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (lowerBound == null ? 0 : lowerBound.hashCode());
        _hash = 29 * _hash + (upperBound == null ? 0 : upperBound.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof IntFilter))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof IntFilter))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        IntFilter that = (IntFilter)_that;
        return super.equalsSub(_that)
        && ((lowerBound == null && that.lowerBound == null) || (lowerBound != null && lowerBound.equals(that.lowerBound)))
        && ((upperBound == null && that.upperBound == null) || (upperBound != null && upperBound.equals(that.upperBound)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public IntFilter() {
        super();
    }
    
    // default all-arguments constructor
    public IntFilter(String fieldName
    , boolean negateResult
    , Integer lowerBound
    , Integer upperBound
    ) {
        super(fieldName
        , negateResult
        );
        this.lowerBound = lowerBound;
        this.upperBound = upperBound;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == IntFilter.class) {
            return (T) new IntFilter(getFieldName(), getNegateResult(), getLowerBound(), getUpperBound());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/search/LongFilter.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.search;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Provides filtering for integral values. At least one parameter must be provided. In order to search for exactly one value, both parameters must be set to the same value.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public final class LongFilter extends SearchFilter
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -219180602080L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return SearchFilter.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return SearchFilter.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.search.LongFilter";
    private static final String REVISION = null;
    private static final String PARENT = "app.search.SearchFilter";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$lowerBound = new NumericElementaryDataItem(Visibility.DEFAULT, false, "lowerBound", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$upperBound = new NumericElementaryDataItem(Visibility.DEFAULT, false, "upperBound", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$lowerBound;
        field$array[1] = meta$$upperBound;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    Long lowerBound;
    Long upperBound;
    // auto-generated getters and setters
    public Long getLowerBound() {
        return lowerBound;
    }
    public void setLowerBound(Long lowerBound) {
        this.lowerBound = lowerBound;
    }
    public Long getUpperBound() {
        return upperBound;
    }
    public void setUpperBound(Long upperBound) {
        this.upperBound = upperBound;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (lowerBound == null) w.writeNull(meta$$lowerBound); else w.addField(lowerBound);
        if (upperBound == null) w.writeNull(meta$$upperBound); else w.addField(upperBound);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("lowerBound")) {
            if (lowerBound == null) w.writeNull(meta$$lowerBound); else w.addField(lowerBound);
            return;
        }
        if (_n.equals("upperBound")) {
            if (upperBound == null) w.writeNull(meta$$upperBound); else w.addField(upperBound);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        lowerBound = p.readLong      ("lowerBound", true, false);
        upperBound = p.readLong      ("upperBound", true, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (lowerBound == null ? 0 : lowerBound.hashCode());
        _hash = 29 * _hash + (upperBound == null ? 0 : upperBound.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof LongFilter))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof LongFilter))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        LongFilter that = (LongFilter)_that;
        return super.equalsSub(_that)
        && ((lowerBound == null && that.lowerBound == null) || (lowerBound != null && lowerBound.equals(that.lowerBound)))
        && ((upperBound == null && that.upperBound == null) || (upperBound != null && upperBound.equals(that.upperBound)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public LongFilter() {
        super();
    }
    
    // default all-arguments constructor
    public LongFilter(String fieldName
    , boolean negateResult
    , Long lowerBound
    , Long upperBound
    ) {
        super(fieldName
        , negateResult
        );
        this.lowerBound = lowerBound;
        this.upperBound = upperBound;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == LongFilter.class) {
            return (T) new LongFilter(getFieldName(), getNegateResult(), getLowerBound(), getUpperBound());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/search/NullFilter.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.search;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Provides filtering for NULL fields. The result set consists of all rows which have a NULL value for the specified column.
     * To select all rows with a NOT NULL value, set the "negateResult" field of the SearchFilter base class to true.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public final class NullFilter extends SearchFilter
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 121294402305L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return SearchFilter.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return SearchFilter.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.search.NullFilter";
    private static final String REVISION = null;
    private static final String PARENT = "app.search.SearchFilter";
    private static final String BUNDLE = null;
    
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(0);
        FieldDefinition [] field$array = new FieldDefinition[0];
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // auto-generated getters and setters
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof NullFilter))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof NullFilter))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        NullFilter that = (NullFilter)_that;
        return super.equalsSub(_that)
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public NullFilter() {
        super();
    }
    
    // default all-arguments constructor
    public NullFilter(String fieldName
    , boolean negateResult
    ) {
        super(fieldName
        , negateResult
        );
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == NullFilter.class) {
            return (T) new NullFilter(getFieldName(), getNegateResult());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/search/NumericFilter.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.search;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Provides filtering for non-integral values. At least one parameter must be provided. In order to search for exactly one value, both parameters must be set to the same value.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public final class NumericFilter extends SearchFilter
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -265820391779L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return SearchFilter.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return SearchFilter.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.search.NumericFilter";
    private static final String REVISION = null;
    private static final String PARENT = "app.search.SearchFilter";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$lowerBound = new NumericElementaryDataItem(Visibility.DEFAULT, false, "lowerBound", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "BigDecimal", false, false, 18, 6, false, false);
    protected static final NumericElementaryDataItem meta$$upperBound = new NumericElementaryDataItem(Visibility.DEFAULT, false, "upperBound", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "BigDecimal", false, false, 18, 6, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$lowerBound;
        field$array[1] = meta$$upperBound;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    BigDecimal lowerBound;
    BigDecimal upperBound;
    // auto-generated getters and setters
    public BigDecimal getLowerBound() {
        return lowerBound;
    }
    public void setLowerBound(BigDecimal lowerBound) {
        this.lowerBound = lowerBound;
    }
    public BigDecimal getUpperBound() {
        return upperBound;
    }
    public void setUpperBound(BigDecimal upperBound) {
        this.upperBound = upperBound;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$lowerBound, lowerBound);
        w.addField(meta$$upperBound, upperBound);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("lowerBound")) {
            w.addField(meta$$lowerBound, lowerBound);
            return;
        }
        if (_n.equals("upperBound")) {
            w.addField(meta$$upperBound, upperBound);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        lowerBound = p.readBigDecimal("lowerBound", true, 18, 6, false, false, false);
        upperBound = p.readBigDecimal("upperBound", true, 18, 6, false, false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + BigDecimalTools.hashCode(lowerBound, 6);
        _hash = 29 * _hash + BigDecimalTools.hashCode(upperBound, 6);
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof NumericFilter))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof NumericFilter))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        NumericFilter that = (NumericFilter)_that;
        return super.equalsSub(_that)
        && ((lowerBound == null && that.lowerBound == null) || (lowerBound != null && BigDecimalTools.equals(lowerBound, 6, that.lowerBound, 6)))
        && ((upperBound == null && that.upperBound == null) || (upperBound != null && BigDecimalTools.equals(upperBound, 6, that.upperBound, 6)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public NumericFilter() {
        super();
    }
    
    // default all-arguments constructor
    public NumericFilter(String fieldName
    , boolean negateResult
    , BigDecimal lowerBound
    , BigDecimal upperBound
    ) {
        super(fieldName
        , negateResult
        );
        this.lowerBound = lowerBound;
        this.upperBound = upperBound;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == NumericFilter.class) {
            return (T) new NumericFilter(getFieldName(), getNegateResult(), getLowerBound(), getUpperBound());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/search/SearchCriteria.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.search;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.api.RequestParameters;
import com.arvatosystems.fortytwo.base.api.OutputSessionParameters;


/** The type which defines filtering, sorting and data subsets for queries.
     * This class contains the components searchFilters, searchOption and sortColumns, all of which may be null.
     * If all components are null, the result set matches the result set of the CfgReadAllRequest (ignoring a possibly different sorting).
     * <p>
     * For filtering, the SearchFilter class is the abstract base class, which can be extended for customization purposes, in order to provide additional filters.
     * In addition to the SearchFilter interface class, the corresponding implementation must be provided, overriding the <code>applyFilters</code> method of the CfgReadAllResponse generic class.
     * <p>
     * The SearchOption class just provides functionality to select a subset of the result, for paging views in the UI. As this does only make sense in conjunction with a defined ordering,
     * ordering by the (artificial) primary key column is assumed in case no list of SortColumns is provided (objectRef ascending).  
     */

public abstract class SearchCriteria extends RequestParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 99903846984L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return com.arvatosystems.fortytwo.app.crud.ReadAllResponse.class;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return RequestParameters.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.search.SearchCriteria";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.RequestParameters";
    private static final String BUNDLE = null;
    
    protected static final ObjectReference meta$$searchFilters = new ObjectReference(Visibility.DEFAULT, false, "searchFilters", Multiplicity.LIST, 0, 0, 0, DataCategory.OBJECT,
        "SearchFilter", false, true, "SearchFilter");
    protected static final ObjectReference meta$$searchOption = new ObjectReference(Visibility.DEFAULT, false, "searchOption", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "SearchOption", false, false, "SearchOption");
    protected static final ObjectReference meta$$sortColumns = new ObjectReference(Visibility.DEFAULT, false, "sortColumns", Multiplicity.LIST, 0, 0, 0, DataCategory.OBJECT,
        "SortColumn", false, false, "SortColumn");
    protected static final ObjectReference meta$$searchOutputTarget = new ObjectReference(Visibility.DEFAULT, false, "searchOutputTarget", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "OutputSessionParameters", false, true, "OutputSessionParameters");
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(true);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(4);
        FieldDefinition [] field$array = new FieldDefinition[4];
        field$array[0] = meta$$searchFilters;
        field$array[1] = meta$$searchOption;
        field$array[2] = meta$$sortColumns;
        field$array[3] = meta$$searchOutputTarget;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    List<SearchFilter> searchFilters;
    SearchOption searchOption;
    List<SortColumn> sortColumns;
    // if supplied, then the results will be redirected to a dataSink !
    OutputSessionParameters searchOutputTarget;
    // auto-generated getters and setters
    public List<SearchFilter> getSearchFilters() {
        return searchFilters;
    }
    public void setSearchFilters(List<SearchFilter> searchFilters) {
        this.searchFilters = searchFilters;
    }
    public SearchOption getSearchOption() {
        return searchOption;
    }
    public void setSearchOption(SearchOption searchOption) {
        this.searchOption = searchOption;
    }
    public List<SortColumn> getSortColumns() {
        return sortColumns;
    }
    public void setSortColumns(List<SortColumn> sortColumns) {
        this.sortColumns = sortColumns;
    }
    public OutputSessionParameters getSearchOutputTarget() {
        return searchOutputTarget;
    }
    public void setSearchOutputTarget(OutputSessionParameters searchOutputTarget) {
        this.searchOutputTarget = searchOutputTarget;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (searchFilters == null) {
            w.writeNullCollection(meta$$searchFilters);
        } else {
            w.startArray(searchFilters.size(), 0, 0);
            for (SearchFilter _i : searchFilters)
                w.addField((BonaPortable)_i);
            w.terminateArray();
        }
        w.addField((BonaPortable)searchOption);
        if (sortColumns == null) {
            w.writeNullCollection(meta$$sortColumns);
        } else {
            w.startArray(sortColumns.size(), 0, 0);
            for (SortColumn _i : sortColumns)
                w.addField((BonaPortable)_i);
            w.terminateArray();
        }
        w.addField((BonaPortable)searchOutputTarget);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("searchFilters")) {
            if (searchFilters == null) {
                w.writeNullCollection(meta$$searchFilters);
            } else {
                if (pfc.index < 0) {
                    w.startArray(searchFilters.size(), 0, 0);
                    for (SearchFilter _i : searchFilters) {
                        if (_i == null) {
                            w.writeNull(meta$$searchFilters);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)_i);             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            _i.foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                    w.terminateArray();
                } else {
                    if (pfc.index < searchFilters.size()) {
                        // output single element
                        if (searchFilters.get(pfc.index) == null) {
                            w.writeNull(meta$$searchFilters);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)searchFilters.get(pfc.index));             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            searchFilters.get(pfc.index).foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                }
            }
            return;
        }
        if (_n.equals("searchOption")) {
            if (searchOption == null) {
                w.writeNull(meta$$searchOption);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)searchOption);             // full / recursive object output
            } else {
                // write a specific subcomponent
                searchOption.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        if (_n.equals("sortColumns")) {
            if (sortColumns == null) {
                w.writeNullCollection(meta$$sortColumns);
            } else {
                if (pfc.index < 0) {
                    w.startArray(sortColumns.size(), 0, 0);
                    for (SortColumn _i : sortColumns) {
                        if (_i == null) {
                            w.writeNull(meta$$sortColumns);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)_i);             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            _i.foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                    w.terminateArray();
                } else {
                    if (pfc.index < sortColumns.size()) {
                        // output single element
                        if (sortColumns.get(pfc.index) == null) {
                            w.writeNull(meta$$sortColumns);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)sortColumns.get(pfc.index));             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            sortColumns.get(pfc.index).foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                }
            }
            return;
        }
        if (_n.equals("searchOutputTarget")) {
            if (searchOutputTarget == null) {
                w.writeNull(meta$$searchOutputTarget);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)searchOutputTarget);             // full / recursive object output
            } else {
                // write a specific subcomponent
                searchOutputTarget.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        _length = p.parseArrayStart("searchFilters", true, 0, 0);
        if (_length < 0) {
            searchFilters = null;
        } else {
            searchFilters = new ArrayList<SearchFilter>(_length);
            for (int _i = 0; _i < _length; ++_i)
                searchFilters.add((SearchFilter)p.readObject("searchFilters", SearchFilter.class, true, true));
            p.parseArrayEnd();
        }
        searchOption = (SearchOption)p.readObject("searchOption", SearchOption.class, true, false);
        _length = p.parseArrayStart("sortColumns", true, 0, 0);
        if (_length < 0) {
            sortColumns = null;
        } else {
            sortColumns = new ArrayList<SortColumn>(_length);
            for (int _i = 0; _i < _length; ++_i)
                sortColumns.add((SortColumn)p.readObject("sortColumns", SortColumn.class, true, false));
            p.parseArrayEnd();
        }
        searchOutputTarget = (OutputSessionParameters)p.readObject("searchOutputTarget", OutputSessionParameters.class, true, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (searchFilters != null)
            for (SearchFilter _i : searchFilters)
        if (_i != null)
            _i.validate();  // check object
        if (searchOption != null)
            searchOption.validate();  // check object
        if (sortColumns != null)
            for (SortColumn _i : sortColumns)
        if (_i != null)
            _i.validate();  // check object
        if (searchOutputTarget != null)
            searchOutputTarget.validate();  // check object
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (searchFilters == null ? 0 : searchFilters.hashCode());
        _hash = 29 * _hash + (searchOption == null ? 0 : searchOption.hashCode());
        _hash = 29 * _hash + (sortColumns == null ? 0 : sortColumns.hashCode());
        _hash = 29 * _hash + (searchOutputTarget == null ? 0 : searchOutputTarget.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof SearchCriteria))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof SearchCriteria))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        SearchCriteria that = (SearchCriteria)_that;
        return super.equalsSub(_that)
        && ((searchFilters == null && that.searchFilters == null) || (searchFilters != null && that.searchFilters != null && xCompareSub$searchFilters(that)))
        && ((searchOption == null && that.searchOption == null) || (searchOption != null && searchOption.hasSameContentsAs(that.searchOption)))
        && ((sortColumns == null && that.sortColumns == null) || (sortColumns != null && that.sortColumns != null && xCompareSub$sortColumns(that)))
        && ((searchOutputTarget == null && that.searchOutputTarget == null) || (searchOutputTarget != null && searchOutputTarget.hasSameContentsAs(that.searchOutputTarget)))
        ;
    }
    private boolean xCompareSub$searchFilters(SearchCriteria that) {
        // both searchFilters and that searchFilters are known to be not null
        if (searchFilters.size() != that.searchFilters.size())
            return false;
        // indexed access is not optional, but sequential access will be left for later optimization
        for (int _i = 0; _i < searchFilters.size(); ++_i)
            if (!(((searchFilters.get(_i) == null && that.searchFilters.get(_i) == null) || (searchFilters.get(_i) != null && searchFilters.get(_i).hasSameContentsAs(that.searchFilters.get(_i))))))
                return false;
        return true;
    }
    private boolean xCompareSub$sortColumns(SearchCriteria that) {
        // both sortColumns and that sortColumns are known to be not null
        if (sortColumns.size() != that.sortColumns.size())
            return false;
        // indexed access is not optional, but sequential access will be left for later optimization
        for (int _i = 0; _i < sortColumns.size(); ++_i)
            if (!(((sortColumns.get(_i) == null && that.sortColumns.get(_i) == null) || (sortColumns.get(_i) != null && sortColumns.get(_i).hasSameContentsAs(that.sortColumns.get(_i))))))
                return false;
        return true;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        if (searchFilters != null)
            for (SearchFilter _i : searchFilters)
        if (_i != null)
            _i.treeWalkString(_cvt);
        if (searchOption != null)
            searchOption.treeWalkString(_cvt);
        if (sortColumns != null)
            for (SortColumn _i : sortColumns)
        if (_i != null)
            _i.treeWalkString(_cvt);
        if (searchOutputTarget != null)
            searchOutputTarget.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public SearchCriteria() {
        super();
    }
    
    // default all-arguments constructor
    public SearchCriteria(List<SearchFilter> searchFilters
    , SearchOption searchOption
    , List<SortColumn> sortColumns
    , OutputSessionParameters searchOutputTarget
    ) {
        super();
        this.searchFilters = searchFilters;
        this.searchOption = searchOption;
        this.sortColumns = sortColumns;
        this.searchOutputTarget = searchOutputTarget;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == SearchCriteria.class) {
            throw new IllegalArgumentException("SearchCriteria is abstract can cannot be supported by copyOf()");
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/search/SearchFilter.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.search;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



public abstract class SearchFilter
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 1700818585L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.search.SearchFilter";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$fieldName = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "fieldName", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 64, 0, null);
    protected static final MiscElementaryDataItem meta$$negateResult = new MiscElementaryDataItem(Visibility.DEFAULT, true, "negateResult", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", true);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(true);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$fieldName;
        field$array[1] = meta$$negateResult;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // the field name subject to comparison !
    String fieldName;
    // if true, this condition is negated. !
    boolean negateResult;
    // auto-generated getters and setters
    public String getFieldName() {
        return fieldName;
    }
    public void setFieldName(String fieldName) {
        this.fieldName = fieldName;
    }
    public boolean getNegateResult() {
        return negateResult;
    }
    public void setNegateResult(boolean negateResult) {
        this.negateResult = negateResult;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(meta$$fieldName, fieldName);
        w.addField(negateResult);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("fieldName")) {
            w.addField(meta$$fieldName, fieldName);
            return;
        }
        if (_n.equals("negateResult")) {
            w.addField(negateResult);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        fieldName = p.readString    ("fieldName", false, 64, true, false, false, false);
        negateResult = p.readBoolean   ("negateResult", false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (fieldName == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "fieldName", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (fieldName != null) {
            if (fieldName.length() > 64)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "fieldName.length=" + fieldName.length() + " > 64",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (fieldName == null ? 0 : fieldName.hashCode());
        _hash = 29 * _hash + (negateResult ? 1231 : 1237);
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof SearchFilter))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof SearchFilter))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        SearchFilter that = (SearchFilter)_that;
        return true
        && ((fieldName == null && that.fieldName == null) || (fieldName != null && fieldName.equals(that.fieldName)))
        && negateResult == that.negateResult
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        fieldName = _cvt.convert(fieldName, meta$$fieldName);
    }
    // default no-argument constructor
    public SearchFilter() {
    }
    
    // default all-arguments constructor
    public SearchFilter(String fieldName
    , boolean negateResult
    ) {
        this.fieldName = fieldName;
        this.negateResult = negateResult;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == SearchFilter.class) {
            throw new IllegalArgumentException("SearchFilter is abstract can cannot be supported by copyOf()");
        }
        throw new IllegalArgumentException("SearchFilter does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/search/SearchOption.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.search;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public final class SearchOption
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 1965173654L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.search.SearchOption";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$limit = new NumericElementaryDataItem(Visibility.DEFAULT, true, "limit", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", true, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$offset = new NumericElementaryDataItem(Visibility.DEFAULT, true, "offset", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", true, false, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$limit;
        field$array[1] = meta$$offset;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // max rows !
    int limit;
    // skip rows !
    int offset;
    // auto-generated getters and setters
    public int getLimit() {
        return limit;
    }
    public void setLimit(int limit) {
        this.limit = limit;
    }
    public int getOffset() {
        return offset;
    }
    public void setOffset(int offset) {
        this.offset = offset;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(limit);
        w.addField(offset);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("limit")) {
            w.addField(limit);
            return;
        }
        if (_n.equals("offset")) {
            w.addField(offset);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        limit = p.readInteger   ("limit", false, false);
        offset = p.readInteger   ("offset", false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + limit;
        _hash = 29 * _hash + offset;
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof SearchOption))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof SearchOption))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        SearchOption that = (SearchOption)_that;
        return true
        && limit == that.limit
        && offset == that.offset
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
    }
    // default no-argument constructor
    public SearchOption() {
    }
    
    // default all-arguments constructor
    public SearchOption(int limit
    , int offset
    ) {
        this.limit = limit;
        this.offset = offset;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == SearchOption.class) {
            return (T) new SearchOption(getLimit(), getOffset());
        }
        throw new IllegalArgumentException("SearchOption does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/search/SearchRequest.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.search;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.api.RequestParameters;
import com.arvatosystems.fortytwo.base.api.OutputSessionParameters;


/**
     * The request to be used when communicating with search based request handler.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class SearchRequest<DATA extends BonaPortable> extends SearchCriteria
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -51919676430L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return SearchCriteria.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return SearchCriteria.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.search.SearchRequest";
    private static final String REVISION = null;
    private static final String PARENT = "app.search.SearchCriteria";
    private static final String BUNDLE = null;
    
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(0);
        FieldDefinition [] field$array = new FieldDefinition[0];
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // auto-generated getters and setters
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof SearchRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof SearchRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        SearchRequest<DATA> that = (SearchRequest<DATA>)_that;
        return super.equalsSub(_that)
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public SearchRequest() {
        super();
    }
    
    // default all-arguments constructor
    public SearchRequest(List<SearchFilter> searchFilters
    , SearchOption searchOption
    , List<SortColumn> sortColumns
    , OutputSessionParameters searchOutputTarget
    ) {
        super(searchFilters
        , searchOption
        , sortColumns
        , searchOutputTarget
        );
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == SearchRequest.class) {
            return (T) new SearchRequest(getSearchFilters(), getSearchOption(), getSortColumns(), getSearchOutputTarget());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/search/SortColumn.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.search;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public final class SortColumn
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -1813137363L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.search.SortColumn";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$fieldName = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "fieldName", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 64, 0, null);
    protected static final MiscElementaryDataItem meta$$ascending = new MiscElementaryDataItem(Visibility.DEFAULT, true, "ascending", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", true);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$fieldName;
        field$array[1] = meta$$ascending;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    String fieldName;
    boolean ascending;
    // auto-generated getters and setters
    public String getFieldName() {
        return fieldName;
    }
    public void setFieldName(String fieldName) {
        this.fieldName = fieldName;
    }
    public boolean getAscending() {
        return ascending;
    }
    public void setAscending(boolean ascending) {
        this.ascending = ascending;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(meta$$fieldName, fieldName);
        w.addField(ascending);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("fieldName")) {
            w.addField(meta$$fieldName, fieldName);
            return;
        }
        if (_n.equals("ascending")) {
            w.addField(ascending);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        fieldName = p.readString    ("fieldName", false, 64, true, false, false, false);
        ascending = p.readBoolean   ("ascending", false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (fieldName == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "fieldName", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (fieldName != null) {
            if (fieldName.length() > 64)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "fieldName.length=" + fieldName.length() + " > 64",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (fieldName == null ? 0 : fieldName.hashCode());
        _hash = 29 * _hash + (ascending ? 1231 : 1237);
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof SortColumn))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof SortColumn))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        SortColumn that = (SortColumn)_that;
        return true
        && ((fieldName == null && that.fieldName == null) || (fieldName != null && fieldName.equals(that.fieldName)))
        && ascending == that.ascending
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        fieldName = _cvt.convert(fieldName, meta$$fieldName);
    }
    // default no-argument constructor
    public SortColumn() {
    }
    
    // default all-arguments constructor
    public SortColumn(String fieldName
    , boolean ascending
    ) {
        this.fieldName = fieldName;
        this.ascending = ascending;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == SortColumn.class) {
            return (T) new SortColumn(getFieldName(), getAscending());
        }
        throw new IllegalArgumentException("SortColumn does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/search/TimestampFilter.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.search;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Provides filtering for time instants. All parameters are provided in UTC timezone. 
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public final class TimestampFilter extends SearchFilter
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -266139737160L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return SearchFilter.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return SearchFilter.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.search.TimestampFilter";
    private static final String REVISION = null;
    private static final String PARENT = "app.search.SearchFilter";
    private static final String BUNDLE = null;
    
    protected static final TemporalElementaryDataItem meta$$lowerBound = new TemporalElementaryDataItem(Visibility.DEFAULT, false, "lowerBound", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    protected static final TemporalElementaryDataItem meta$$upperBound = new TemporalElementaryDataItem(Visibility.DEFAULT, false, "upperBound", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$lowerBound;
        field$array[1] = meta$$upperBound;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    LocalDateTime lowerBound;
    LocalDateTime upperBound;
    // auto-generated getters and setters
    public LocalDateTime getLowerBound() {
        return lowerBound;
    }
    public void setLowerBound(LocalDateTime lowerBound) {
        this.lowerBound = lowerBound;
    }
    public LocalDateTime getUpperBound() {
        return upperBound;
    }
    public void setUpperBound(LocalDateTime upperBound) {
        this.upperBound = upperBound;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$lowerBound, lowerBound);
        w.addField(meta$$upperBound, upperBound);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("lowerBound")) {
            w.addField(meta$$lowerBound, lowerBound);
            return;
        }
        if (_n.equals("upperBound")) {
            w.addField(meta$$upperBound, upperBound);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        lowerBound = p.readDayTime("lowerBound", true, false, 0);
        upperBound = p.readDayTime("upperBound", true, false, 0);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (lowerBound == null ? 0 : lowerBound.hashCode());
        _hash = 29 * _hash + (upperBound == null ? 0 : upperBound.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof TimestampFilter))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof TimestampFilter))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        TimestampFilter that = (TimestampFilter)_that;
        return super.equalsSub(_that)
        && ((lowerBound == null && that.lowerBound == null) || (lowerBound != null && lowerBound.equals(that.lowerBound)))
        && ((upperBound == null && that.upperBound == null) || (upperBound != null && upperBound.equals(that.upperBound)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public TimestampFilter() {
        super();
    }
    
    // default all-arguments constructor
    public TimestampFilter(String fieldName
    , boolean negateResult
    , LocalDateTime lowerBound
    , LocalDateTime upperBound
    ) {
        super(fieldName
        , negateResult
        );
        this.lowerBound = lowerBound;
        this.upperBound = upperBound;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == TimestampFilter.class) {
            return (T) new TimestampFilter(getFieldName(), getNegateResult(), getLowerBound(), getUpperBound());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/search/UnicodeFilter.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.app.search;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Provides filtering for Unicode text fields. Exactly one of the parameters equalsValue and likeValue must be provided, the other one must be null.
     * If both parameters are null or both are not equal to null, an "invalid search filter" parameter error is returned. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public final class UnicodeFilter extends SearchFilter
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 141164046861L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return SearchFilter.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return SearchFilter.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "app.search.UnicodeFilter";
    private static final String REVISION = null;
    private static final String PARENT = "app.search.SearchFilter";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$equalsValue = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "equalsValue", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 80, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$likeValue = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "likeValue", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 80, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$equalsValue;
        field$array[1] = meta$$likeValue;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    String equalsValue;
    String likeValue;
    // auto-generated getters and setters
    public String getEqualsValue() {
        return equalsValue;
    }
    public void setEqualsValue(String equalsValue) {
        this.equalsValue = equalsValue;
    }
    public String getLikeValue() {
        return likeValue;
    }
    public void setLikeValue(String likeValue) {
        this.likeValue = likeValue;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$equalsValue, equalsValue);
        w.addField(meta$$likeValue, likeValue);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("equalsValue")) {
            w.addField(meta$$equalsValue, equalsValue);
            return;
        }
        if (_n.equals("likeValue")) {
            w.addField(meta$$likeValue, likeValue);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        equalsValue = p.readString    ("equalsValue", true, 80, true, false, false, true);
        likeValue = p.readString    ("likeValue", true, 80, true, false, false, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (equalsValue != null) {
            if (equalsValue.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "equalsValue.length=" + equalsValue.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (likeValue != null) {
            if (likeValue.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "likeValue.length=" + likeValue.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (equalsValue == null ? 0 : equalsValue.hashCode());
        _hash = 29 * _hash + (likeValue == null ? 0 : likeValue.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof UnicodeFilter))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof UnicodeFilter))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        UnicodeFilter that = (UnicodeFilter)_that;
        return super.equalsSub(_that)
        && ((equalsValue == null && that.equalsValue == null) || (equalsValue != null && equalsValue.equals(that.equalsValue)))
        && ((likeValue == null && that.likeValue == null) || (likeValue != null && likeValue.equals(that.likeValue)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        equalsValue = _cvt.convert(equalsValue, meta$$equalsValue);
        likeValue = _cvt.convert(likeValue, meta$$likeValue);
    }
    // default no-argument constructor
    public UnicodeFilter() {
        super();
    }
    
    // default all-arguments constructor
    public UnicodeFilter(String fieldName
    , boolean negateResult
    , String equalsValue
    , String likeValue
    ) {
        super(fieldName
        , negateResult
        );
        this.equalsValue = equalsValue;
        this.likeValue = likeValue;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == UnicodeFilter.class) {
            return (T) new UnicodeFilter(getFieldName(), getNegateResult(), getEqualsValue(), getLikeValue());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/app/search/package-info.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

@XmlJavaTypeAdapters({
    @XmlJavaTypeAdapter(type=LocalDate.class,       value=LocalDateAdapter.class),
    @XmlJavaTypeAdapter(type=LocalTime.class,       value=LocalTimeAdapter.class),
    @XmlJavaTypeAdapter(type=LocalDateTime.class,   value=LocalDateTimeAdapter.class),
    @XmlJavaTypeAdapter(type=ByteArray.class,       value=ByteArrayAdapter.class)
})
package com.arvatosystems.fortytwo.app.search;

import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapters;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import org.joda.time.LocalTime;
import de.jpaw.util.ByteArray;

import de.jpaw.xml.jaxb.ByteArrayAdapter;
import de.jpaw.xml.jaxb.LocalDateAdapter;
import de.jpaw.xml.jaxb.LocalTimeAdapter;
import de.jpaw.xml.jaxb.LocalDateTimeAdapter;
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/AuthFortytwo.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Provides authentication information via Fortytwo platform specific security token. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class AuthFortytwo extends AuthenticationParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 202946972952L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return AuthenticationParameters.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return AuthenticationParameters.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.api.AuthFortytwo";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.AuthenticationParameters";
    private static final String BUNDLE = null;
    
    protected static final BinaryElementaryDataItem meta$$fortytwoToken = new BinaryElementaryDataItem(Visibility.DEFAULT, true, "fortytwoToken", Multiplicity.SCALAR, 0, 0, 0, DataCategory.BINARY,
        "ByteArray", false, 32);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$fortytwoToken;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // token for internal SSO provider !
    ByteArray fortytwoToken;
    // auto-generated getters and setters
    public ByteArray getFortytwoToken() {
        return fortytwoToken;
    }
    public void setFortytwoToken(ByteArray fortytwoToken) {
        this.fortytwoToken = fortytwoToken;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$fortytwoToken, fortytwoToken);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("fortytwoToken")) {
            w.addField(meta$$fortytwoToken, fortytwoToken);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        fortytwoToken = p.readByteArray ("fortytwoToken", false, 32);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (fortytwoToken == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "fortytwoToken", PARTIALLY_QUALIFIED_CLASS_NAME);
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (fortytwoToken == null ? 0 : fortytwoToken.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AuthFortytwo))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AuthFortytwo))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        AuthFortytwo that = (AuthFortytwo)_that;
        return super.equalsSub(_that)
        && ((fortytwoToken == null && that.fortytwoToken == null) || (fortytwoToken != null && fortytwoToken.contentEquals(that.fortytwoToken)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public AuthFortytwo() {
        super();
    }
    
    // default all-arguments constructor
    public AuthFortytwo(ByteArray fortytwoToken
    ) {
        super();
        this.fortytwoToken = fortytwoToken;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == AuthFortytwo.class) {
            return (T) new AuthFortytwo(getFortytwoToken());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/AuthSAML.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Provides authentication information via SAML v2 token. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class AuthSAML extends AuthenticationParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -42331900027L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return AuthenticationParameters.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return AuthenticationParameters.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.api.AuthSAML";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.AuthenticationParameters";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$samlToken = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "samlToken", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 4000, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$samlToken;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // SAML v2 token !
    String samlToken;
    // auto-generated getters and setters
    public String getSamlToken() {
        return samlToken;
    }
    public void setSamlToken(String samlToken) {
        this.samlToken = samlToken;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$samlToken, samlToken);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("samlToken")) {
            w.addField(meta$$samlToken, samlToken);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        samlToken = p.readString    ("samlToken", false, 4000, true, false, false, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (samlToken == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "samlToken", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (samlToken != null) {
            if (samlToken.length() > 4000)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "samlToken.length=" + samlToken.length() + " > 4000",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (samlToken == null ? 0 : samlToken.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AuthSAML))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AuthSAML))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        AuthSAML that = (AuthSAML)_that;
        return super.equalsSub(_that)
        && ((samlToken == null && that.samlToken == null) || (samlToken != null && samlToken.equals(that.samlToken)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        samlToken = _cvt.convert(samlToken, meta$$samlToken);
    }
    // default no-argument constructor
    public AuthSAML() {
        super();
    }
    
    // default all-arguments constructor
    public AuthSAML(String samlToken
    ) {
        super();
        this.samlToken = samlToken;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == AuthSAML.class) {
            return (T) new AuthSAML(getSamlToken());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/AuthX500DistinguishedName.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Provides authentication information via commonName, which has been provided by the SSL layer and taken from the peer's verified certificate. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class AuthX500DistinguishedName extends AuthenticationParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 111808839550L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return AuthenticationParameters.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return AuthenticationParameters.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.api.AuthX500DistinguishedName";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.AuthenticationParameters";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$distinguishedName = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "distinguishedName", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 255, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$distinguishedName;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // distinguished name of the SSL certificate !
    String distinguishedName;
    // auto-generated getters and setters
    public String getDistinguishedName() {
        return distinguishedName;
    }
    public void setDistinguishedName(String distinguishedName) {
        this.distinguishedName = distinguishedName;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$distinguishedName, distinguishedName);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("distinguishedName")) {
            w.addField(meta$$distinguishedName, distinguishedName);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        distinguishedName = p.readString    ("distinguishedName", false, 255, true, false, false, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (distinguishedName == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "distinguishedName", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (distinguishedName != null) {
            if (distinguishedName.length() > 255)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "distinguishedName.length=" + distinguishedName.length() + " > 255",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (distinguishedName == null ? 0 : distinguishedName.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AuthX500DistinguishedName))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AuthX500DistinguishedName))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        AuthX500DistinguishedName that = (AuthX500DistinguishedName)_that;
        return super.equalsSub(_that)
        && ((distinguishedName == null && that.distinguishedName == null) || (distinguishedName != null && distinguishedName.equals(that.distinguishedName)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        distinguishedName = _cvt.convert(distinguishedName, meta$$distinguishedName);
    }
    // default no-argument constructor
    public AuthX500DistinguishedName() {
        super();
    }
    
    // default all-arguments constructor
    public AuthX500DistinguishedName(String distinguishedName
    ) {
        super();
        this.distinguishedName = distinguishedName;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == AuthX500DistinguishedName.class) {
            return (T) new AuthX500DistinguishedName(getDistinguishedName());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/AuthenticationParameters.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** The AuthenticationParameters provide information about the authentication of a ServiceRequest. */

public abstract class AuthenticationParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -381165069L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.api.AuthenticationParameters";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(true);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(0);
        FieldDefinition [] field$array = new FieldDefinition[0];
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // auto-generated getters and setters
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AuthenticationParameters))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AuthenticationParameters))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        AuthenticationParameters that = (AuthenticationParameters)_that;
        return true
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
    }
    // default no-argument constructor
    public AuthenticationParameters() {
    }
    
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == AuthenticationParameters.class) {
            throw new IllegalArgumentException("AuthenticationParameters is abstract can cannot be supported by copyOf()");
        }
        throw new IllegalArgumentException("AuthenticationParameters does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/BatchRequest.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** The BatchRequest allows to execute a series of commands in sequence (provided all of them return a zero return code). */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class BatchRequest extends RequestParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -238253033670L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return RequestParameters.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return RequestParameters.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.api.BatchRequest";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.RequestParameters";
    private static final String BUNDLE = null;
    
    protected static final MiscElementaryDataItem meta$$allowNo = new MiscElementaryDataItem(Visibility.DEFAULT, true, "allowNo", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", true);
    protected static final ObjectReference meta$$commands = new ObjectReference(Visibility.DEFAULT, true, "commands", Multiplicity.LIST, 0, 0, 0, DataCategory.OBJECT,
        "BatchRequest", false, true, "BatchRequest");
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$allowNo;
        field$array[1] = meta$$commands;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // continue batch if technically correct, but business "no" returned (CLASS 1)? !
    boolean allowNo;
    // list of requests !
    List<BatchRequest> commands;
    // auto-generated getters and setters
    public boolean getAllowNo() {
        return allowNo;
    }
    public void setAllowNo(boolean allowNo) {
        this.allowNo = allowNo;
    }
    public List<BatchRequest> getCommands() {
        return commands;
    }
    public void setCommands(List<BatchRequest> commands) {
        this.commands = commands;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(allowNo);
        if (commands == null) {
            w.writeNullCollection(meta$$commands);
        } else {
            w.startArray(commands.size(), 0, 0);
            for (BatchRequest _i : commands)
                w.addField((BonaPortable)_i);
            w.terminateArray();
        }
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("allowNo")) {
            w.addField(allowNo);
            return;
        }
        if (_n.equals("commands")) {
            if (commands == null) {
                w.writeNullCollection(meta$$commands);
            } else {
                if (pfc.index < 0) {
                    w.startArray(commands.size(), 0, 0);
                    for (BatchRequest _i : commands) {
                        if (_i == null) {
                            w.writeNull(meta$$commands);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)_i);             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            _i.foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                    w.terminateArray();
                } else {
                    if (pfc.index < commands.size()) {
                        // output single element
                        if (commands.get(pfc.index) == null) {
                            w.writeNull(meta$$commands);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)commands.get(pfc.index));             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            commands.get(pfc.index).foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                }
            }
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        allowNo = p.readBoolean   ("allowNo", false);
        _length = p.parseArrayStart("commands", true, 0, 0);
        if (_length < 0) {
            commands = null;
        } else {
            commands = new ArrayList<BatchRequest>(_length);
            for (int _i = 0; _i < _length; ++_i)
                commands.add((BatchRequest)p.readObject("commands", BatchRequest.class, false, true));
            p.parseArrayEnd();
        }
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (commands != null)
            for (BatchRequest _i : commands)
        if (_i == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "_i", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (commands != null)
            for (BatchRequest _i : commands)
        _i.validate();      // check object (!= null checked before)
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (allowNo ? 1231 : 1237);
        _hash = 29 * _hash + (commands == null ? 0 : commands.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof BatchRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof BatchRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        BatchRequest that = (BatchRequest)_that;
        return super.equalsSub(_that)
        && allowNo == that.allowNo
        && ((commands == null && that.commands == null) || (commands != null && that.commands != null && xCompareSub$commands(that)))
        ;
    }
    private boolean xCompareSub$commands(BatchRequest that) {
        // both commands and that commands are known to be not null
        if (commands.size() != that.commands.size())
            return false;
        // indexed access is not optional, but sequential access will be left for later optimization
        for (int _i = 0; _i < commands.size(); ++_i)
            if (!(((commands.get(_i) == null && that.commands.get(_i) == null) || (commands.get(_i) != null && commands.get(_i).hasSameContentsAs(that.commands.get(_i))))))
                return false;
        return true;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        if (commands != null)
            for (BatchRequest _i : commands)
        if (_i != null)
            _i.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public BatchRequest() {
        super();
    }
    
    // default all-arguments constructor
    public BatchRequest(boolean allowNo
    , List<BatchRequest> commands
    ) {
        super();
        this.allowNo = allowNo;
        this.commands = commands;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == BatchRequest.class) {
            return (T) new BatchRequest(getAllowNo(), getCommands());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/CommunicationFormatType.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api;

import de.jpaw.util.EnumException;
import de.jpaw.enums.TokenizableEnum;

/** Defines the format of the data output. */

public enum CommunicationFormatType implements TokenizableEnum {
    BONAPARTE("B"), XML("L"), JSON("J"), NULL("N"), PDF("P"), XLS("X"), CSV("C"), TEXT("T"), XLSX("x"), UNDEFINED("?"), HTML("H"), JPG("j"), PNG("p"), GIF("g"), WAV("w"), MP3("3"), RAW("#"), USER_DEFINED("U");

    // constructor by token
    private String _token;
    private CommunicationFormatType(String _token) {
        this._token = _token;
    }

    // token retrieval
    @Override
    public String getToken() {
        return _token;
    }

    // static factory method.
    public static CommunicationFormatType factory(String _token) throws EnumException {
        if (_token != null) {
            if (_token.equals("B")) return BONAPARTE;
            if (_token.equals("L")) return XML;
            if (_token.equals("J")) return JSON;
            if (_token.equals("N")) return NULL;
            if (_token.equals("P")) return PDF;
            if (_token.equals("X")) return XLS;
            if (_token.equals("C")) return CSV;
            if (_token.equals("T")) return TEXT;
            if (_token.equals("x")) return XLSX;
            if (_token.equals("?")) return UNDEFINED;
            if (_token.equals("H")) return HTML;
            if (_token.equals("j")) return JPG;
            if (_token.equals("p")) return PNG;
            if (_token.equals("g")) return GIF;
            if (_token.equals("w")) return WAV;
            if (_token.equals("3")) return MP3;
            if (_token.equals("#")) return RAW;
            if (_token.equals("U")) return USER_DEFINED;
            throw new EnumException(EnumException.INVALID_NUM, _token);
        }
        return null;
    }

    public static CommunicationFormatType valueOf(Integer ordinal) throws EnumException {
        if (ordinal != null) {
            switch (ordinal.intValue()) {
            case 0: return BONAPARTE;
            case 1: return XML;
            case 2: return JSON;
            case 3: return NULL;
            case 4: return PDF;
            case 5: return XLS;
            case 6: return CSV;
            case 7: return TEXT;
            case 8: return XLSX;
            case 9: return UNDEFINED;
            case 10: return HTML;
            case 11: return JPG;
            case 12: return PNG;
            case 13: return GIF;
            case 14: return WAV;
            case 15: return MP3;
            case 16: return RAW;
            case 17: return USER_DEFINED;
            default: throw new EnumException(EnumException.INVALID_NUM, ordinal.toString());
            }
        }
        return null;
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/CommunicationTargetChannelType.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api;

import de.jpaw.util.EnumException;
import de.jpaw.enums.TokenizableEnum;

/** Defines the target classification. Looked up from configuration table. */

public enum CommunicationTargetChannelType implements TokenizableEnum {
    NULL("N"), FILE("F"), BIGDATA_DB("D"), QUEUE("Q"), TOPIC("T"), CAMEL("C");

    // constructor by token
    private String _token;
    private CommunicationTargetChannelType(String _token) {
        this._token = _token;
    }

    // token retrieval
    @Override
    public String getToken() {
        return _token;
    }

    // static factory method.
    public static CommunicationTargetChannelType factory(String _token) throws EnumException {
        if (_token != null) {
            if (_token.equals("N")) return NULL;
            if (_token.equals("F")) return FILE;
            if (_token.equals("D")) return BIGDATA_DB;
            if (_token.equals("Q")) return QUEUE;
            if (_token.equals("T")) return TOPIC;
            if (_token.equals("C")) return CAMEL;
            throw new EnumException(EnumException.INVALID_NUM, _token);
        }
        return null;
    }

    public static CommunicationTargetChannelType valueOf(Integer ordinal) throws EnumException {
        if (ordinal != null) {
            switch (ordinal.intValue()) {
            case 0: return NULL;
            case 1: return FILE;
            case 2: return BIGDATA_DB;
            case 3: return QUEUE;
            case 4: return TOPIC;
            case 5: return CAMEL;
            default: throw new EnumException(EnumException.INVALID_NUM, ordinal.toString());
            }
        }
        return null;
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/ErrorRequest.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Technical (internal) request which is required for logging of unparseable messages.
     * The ErrorRequest will create an error response from the parameters provided.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class ErrorRequest extends RequestParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -194958814064L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return RequestParameters.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return RequestParameters.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.api.ErrorRequest";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.RequestParameters";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$returnCode = new NumericElementaryDataItem(Visibility.DEFAULT, true, "returnCode", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", true, false, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$errorDetails = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "errorDetails", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 512, 0, null);
    protected static final BinaryElementaryDataItem meta$$originalMessage = new BinaryElementaryDataItem(Visibility.DEFAULT, false, "originalMessage", Multiplicity.SCALAR, 0, 0, 0, DataCategory.BINARY,
        "ByteArray", false, 16777216);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(3);
        FieldDefinition [] field$array = new FieldDefinition[3];
        field$array[0] = meta$$returnCode;
        field$array[1] = meta$$errorDetails;
        field$array[2] = meta$$originalMessage;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // the most significant digit provides the error category. Field contains 0 if no error occured. !
    int returnCode;
    // a data parameter which allows to localize the error condition (offending field / parameter name etc.) !
    String errorDetails;
    // the unparseable message. !
    ByteArray originalMessage;
    // auto-generated getters and setters
    public int getReturnCode() {
        return returnCode;
    }
    public void setReturnCode(int returnCode) {
        this.returnCode = returnCode;
    }
    public String getErrorDetails() {
        return errorDetails;
    }
    public void setErrorDetails(String errorDetails) {
        this.errorDetails = errorDetails;
    }
    public ByteArray getOriginalMessage() {
        return originalMessage;
    }
    public void setOriginalMessage(ByteArray originalMessage) {
        this.originalMessage = originalMessage;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(returnCode);
        w.addField(meta$$errorDetails, errorDetails);
        w.addField(meta$$originalMessage, originalMessage);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("returnCode")) {
            w.addField(returnCode);
            return;
        }
        if (_n.equals("errorDetails")) {
            w.addField(meta$$errorDetails, errorDetails);
            return;
        }
        if (_n.equals("originalMessage")) {
            w.addField(meta$$originalMessage, originalMessage);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        returnCode = p.readInteger   ("returnCode", false, false);
        errorDetails = p.readString    ("errorDetails", true, 512, true, false, false, false);
        originalMessage = p.readByteArray ("originalMessage", true, 16777216);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (errorDetails != null) {
            if (errorDetails.length() > 512)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "errorDetails.length=" + errorDetails.length() + " > 512",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + returnCode;
        _hash = 29 * _hash + (errorDetails == null ? 0 : errorDetails.hashCode());
        _hash = 29 * _hash + (originalMessage == null ? 0 : originalMessage.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ErrorRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ErrorRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        ErrorRequest that = (ErrorRequest)_that;
        return super.equalsSub(_that)
        && returnCode == that.returnCode
        && ((errorDetails == null && that.errorDetails == null) || (errorDetails != null && errorDetails.equals(that.errorDetails)))
        && ((originalMessage == null && that.originalMessage == null) || (originalMessage != null && originalMessage.contentEquals(that.originalMessage)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        errorDetails = _cvt.convert(errorDetails, meta$$errorDetails);
    }
    // default no-argument constructor
    public ErrorRequest() {
        super();
    }
    
    // default all-arguments constructor
    public ErrorRequest(int returnCode
    , String errorDetails
    , ByteArray originalMessage
    ) {
        super();
        this.returnCode = returnCode;
        this.errorDetails = errorDetails;
        this.originalMessage = originalMessage;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == ErrorRequest.class) {
            return (T) new ErrorRequest(getReturnCode(), getErrorDetails(), getOriginalMessage());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/InputCommunicationFormatType.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api;

import de.jpaw.util.EnumException;
import de.jpaw.enums.TokenizableEnum;


public enum InputCommunicationFormatType implements TokenizableEnum {
    BONAPARTE("B"), XML("L"), JSON("J"), CSV("C");

    // constructor by token
    private String _token;
    private InputCommunicationFormatType(String _token) {
        this._token = _token;
    }

    // token retrieval
    @Override
    public String getToken() {
        return _token;
    }

    // static factory method.
    public static InputCommunicationFormatType factory(String _token) throws EnumException {
        if (_token != null) {
            if (_token.equals("B")) return BONAPARTE;
            if (_token.equals("L")) return XML;
            if (_token.equals("J")) return JSON;
            if (_token.equals("C")) return CSV;
            throw new EnumException(EnumException.INVALID_NUM, _token);
        }
        return null;
    }

    public static InputCommunicationFormatType valueOf(Integer ordinal) throws EnumException {
        if (ordinal != null) {
            switch (ordinal.intValue()) {
            case 0: return BONAPARTE;
            case 1: return XML;
            case 2: return JSON;
            case 3: return CSV;
            default: throw new EnumException(EnumException.INVALID_NUM, ordinal.toString());
            }
        }
        return null;
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/InputCommunicationTargetChannelType.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api;

import de.jpaw.util.EnumException;
import de.jpaw.enums.TokenizableEnum;


public enum InputCommunicationTargetChannelType implements TokenizableEnum {
    FILE("F"), QUEUE("Q");

    // constructor by token
    private String _token;
    private InputCommunicationTargetChannelType(String _token) {
        this._token = _token;
    }

    // token retrieval
    @Override
    public String getToken() {
        return _token;
    }

    // static factory method.
    public static InputCommunicationTargetChannelType factory(String _token) throws EnumException {
        if (_token != null) {
            if (_token.equals("F")) return FILE;
            if (_token.equals("Q")) return QUEUE;
            throw new EnumException(EnumException.INVALID_NUM, _token);
        }
        return null;
    }

    public static InputCommunicationTargetChannelType valueOf(Integer ordinal) throws EnumException {
        if (ordinal != null) {
            switch (ordinal.intValue()) {
            case 0: return FILE;
            case 1: return QUEUE;
            default: throw new EnumException(EnumException.INVALID_NUM, ordinal.toString());
            }
        }
        return null;
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/JmsServiceRequestHeader.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** The JmsServiceRequestHeader is the definition of all common properties of a request sent with JMS. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class JmsServiceRequestHeader extends ServiceRequestHeader
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 65616595562L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return ServiceRequestHeader.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return ServiceRequestHeader.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.api.JmsServiceRequestHeader";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.ServiceRequestHeader";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$responseAddress = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "responseAddress", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 64, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$responseAddress;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // queue or topic target name for the service response !
    String responseAddress;
    // auto-generated getters and setters
    public String getResponseAddress() {
        return responseAddress;
    }
    public void setResponseAddress(String responseAddress) {
        this.responseAddress = responseAddress;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$responseAddress, responseAddress);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("responseAddress")) {
            w.addField(meta$$responseAddress, responseAddress);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        responseAddress = p.readString    ("responseAddress", true, 64, true, false, false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (responseAddress != null) {
            if (responseAddress.length() > 64)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "responseAddress.length=" + responseAddress.length() + " > 64",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (responseAddress == null ? 0 : responseAddress.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof JmsServiceRequestHeader))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof JmsServiceRequestHeader))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        JmsServiceRequestHeader that = (JmsServiceRequestHeader)_that;
        return super.equalsSub(_that)
        && ((responseAddress == null && that.responseAddress == null) || (responseAddress != null && responseAddress.equals(that.responseAddress)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        responseAddress = _cvt.convert(responseAddress, meta$$responseAddress);
    }
    // default no-argument constructor
    public JmsServiceRequestHeader() {
        super();
    }
    
    // default all-arguments constructor
    public JmsServiceRequestHeader(String tenantId
    , String userId
    , RetryAdvice idempotencyBehaviour
    , String languageCode
    , Integer recordNo
    , ByteArray messageId
    , LocalDateTime plannedRunDate
    , List<AuthenticationParameters> authenticationParameters
    , String responseAddress
    ) {
        super(tenantId
        , userId
        , idempotencyBehaviour
        , languageCode
        , recordNo
        , messageId
        , plannedRunDate
        , authenticationParameters
        );
        this.responseAddress = responseAddress;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == JmsServiceRequestHeader.class) {
            return (T) new JmsServiceRequestHeader(getTenantId(), getUserId(), getIdempotencyBehaviour(), getLanguageCode(), getRecordNo(), getMessageId(), getPlannedRunDate(), getAuthenticationParameters(), getResponseAddress());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/KeyValuePair.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Provides a String key / String value pair. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class KeyValuePair
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 235765053L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.api.KeyValuePair";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$key = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "key", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 16, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$value = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "value", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 255, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$key;
        field$array[1] = meta$$value;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // the token to use !
    String key;
    // the assigned value !
    String value;
    // auto-generated getters and setters
    public String getKey() {
        return key;
    }
    public void setKey(String key) {
        this.key = key;
    }
    public String getValue() {
        return value;
    }
    public void setValue(String value) {
        this.value = value;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(meta$$key, key);
        w.addField(meta$$value, value);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("key")) {
            w.addField(meta$$key, key);
            return;
        }
        if (_n.equals("value")) {
            w.addField(meta$$value, value);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        key = p.readString    ("key", false, 16, true, false, false, false);
        value = p.readString    ("value", true, 255, true, false, false, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (key == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "key", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (key != null) {
            if (key.length() > 16)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "key.length=" + key.length() + " > 16",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (value != null) {
            if (value.length() > 255)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "value.length=" + value.length() + " > 255",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (key == null ? 0 : key.hashCode());
        _hash = 29 * _hash + (value == null ? 0 : value.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof KeyValuePair))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof KeyValuePair))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        KeyValuePair that = (KeyValuePair)_that;
        return true
        && ((key == null && that.key == null) || (key != null && key.equals(that.key)))
        && ((value == null && that.value == null) || (value != null && value.equals(that.value)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        key = _cvt.convert(key, meta$$key);
        value = _cvt.convert(value, meta$$value);
    }
    // default no-argument constructor
    public KeyValuePair() {
    }
    
    // default all-arguments constructor
    public KeyValuePair(String key
    , String value
    ) {
        this.key = key;
        this.value = value;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == KeyValuePair.class) {
            return (T) new KeyValuePair(getKey(), getValue());
        }
        throw new IllegalArgumentException("KeyValuePair does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/OutputSessionParameters.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** The OutputSessionParameters are provided once per outbound file / communication.
     * They provide information required by the output processor in order to select the physical transport. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class OutputSessionParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 582761614L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.api.OutputSessionParameters";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$dataSinkId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "dataSinkId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 16, 0, null);
    protected static final TemporalElementaryDataItem meta$$asOf = new TemporalElementaryDataItem(Visibility.DEFAULT, true, "asOf", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    protected static final ObjectReference meta$$additionalParameters = new ObjectReference(Visibility.DEFAULT, false, "additionalParameters", Multiplicity.LIST, 0, 0, 0, DataCategory.OBJECT,
        "KeyValuePair", false, false, "KeyValuePair");
    protected static final NumericElementaryDataItem meta$$originatorRef = new NumericElementaryDataItem(Visibility.DEFAULT, false, "originatorRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$communicationFormatType$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "communicationFormatType$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$communicationFormatType = new EnumDataItem(Visibility.DEFAULT, false, "communicationFormatType", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "CommunicationFormatType", false, "CommunicationFormatType", null);
    protected static final NumericElementaryDataItem meta$$configurationRef = new NumericElementaryDataItem(Visibility.DEFAULT, false, "configurationRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(6);
        FieldDefinition [] field$array = new FieldDefinition[6];
        field$array[0] = meta$$dataSinkId;
        field$array[1] = meta$$asOf;
        field$array[2] = meta$$additionalParameters;
        field$array[3] = meta$$originatorRef;
        field$array[4] = meta$$communicationFormatType;
        field$array[5] = meta$$configurationRef;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // every data output is assigned a name !
    String dataSinkId;
    // (planned) run date / cutoff date for the data provided !
    LocalDateTime asOf;
    // additional application specific parameters !
    List<KeyValuePair> additionalParameters;
    // optional reference to report params, documentRef etc. !
    Long originatorRef;
    // can be used to specify output, unless defined in configuration !
    CommunicationFormatType communicationFormatType;
    // optional additional reference (report configuration, documentTemplate etc.) !
    Long configurationRef;
    // auto-generated getters and setters
    public String getDataSinkId() {
        return dataSinkId;
    }
    public void setDataSinkId(String dataSinkId) {
        this.dataSinkId = dataSinkId;
    }
    public LocalDateTime getAsOf() {
        return asOf;
    }
    public void setAsOf(LocalDateTime asOf) {
        this.asOf = asOf;
    }
    public List<KeyValuePair> getAdditionalParameters() {
        return additionalParameters;
    }
    public void setAdditionalParameters(List<KeyValuePair> additionalParameters) {
        this.additionalParameters = additionalParameters;
    }
    public Long getOriginatorRef() {
        return originatorRef;
    }
    public void setOriginatorRef(Long originatorRef) {
        this.originatorRef = originatorRef;
    }
    public CommunicationFormatType getCommunicationFormatType() {
        return communicationFormatType;
    }
    public void setCommunicationFormatType(CommunicationFormatType communicationFormatType) {
        this.communicationFormatType = communicationFormatType;
    }
    public Long getConfigurationRef() {
        return configurationRef;
    }
    public void setConfigurationRef(Long configurationRef) {
        this.configurationRef = configurationRef;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(meta$$dataSinkId, dataSinkId);
        w.addField(meta$$asOf, asOf);
        if (additionalParameters == null) {
            w.writeNullCollection(meta$$additionalParameters);
        } else {
            w.startArray(additionalParameters.size(), 0, 0);
            for (KeyValuePair _i : additionalParameters)
                w.addField((BonaPortable)_i);
            w.terminateArray();
        }
        if (originatorRef == null) w.writeNull(meta$$originatorRef); else w.addField(originatorRef);
        w.addField(meta$$communicationFormatType$token, communicationFormatType == null ? null : communicationFormatType.getToken());
        if (configurationRef == null) w.writeNull(meta$$configurationRef); else w.addField(configurationRef);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("dataSinkId")) {
            w.addField(meta$$dataSinkId, dataSinkId);
            return;
        }
        if (_n.equals("asOf")) {
            w.addField(meta$$asOf, asOf);
            return;
        }
        if (_n.equals("additionalParameters")) {
            if (additionalParameters == null) {
                w.writeNullCollection(meta$$additionalParameters);
            } else {
                if (pfc.index < 0) {
                    w.startArray(additionalParameters.size(), 0, 0);
                    for (KeyValuePair _i : additionalParameters) {
                        if (_i == null) {
                            w.writeNull(meta$$additionalParameters);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)_i);             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            _i.foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                    w.terminateArray();
                } else {
                    if (pfc.index < additionalParameters.size()) {
                        // output single element
                        if (additionalParameters.get(pfc.index) == null) {
                            w.writeNull(meta$$additionalParameters);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)additionalParameters.get(pfc.index));             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            additionalParameters.get(pfc.index).foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                }
            }
            return;
        }
        if (_n.equals("originatorRef")) {
            if (originatorRef == null) w.writeNull(meta$$originatorRef); else w.addField(originatorRef);
            return;
        }
        if (_n.equals("communicationFormatType")) {
            w.addField(meta$$communicationFormatType$token, communicationFormatType == null ? null : communicationFormatType.getToken());
            return;
        }
        if (_n.equals("configurationRef")) {
            if (configurationRef == null) w.writeNull(meta$$configurationRef); else w.addField(configurationRef);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        dataSinkId = p.readString    ("dataSinkId", false, 16, true, false, false, false);
        asOf = p.readDayTime("asOf", false, false, 0);
        _length = p.parseArrayStart("additionalParameters", true, 0, 0);
        if (_length < 0) {
            additionalParameters = null;
        } else {
            additionalParameters = new ArrayList<KeyValuePair>(_length);
            for (int _i = 0; _i < _length; ++_i)
                additionalParameters.add((KeyValuePair)p.readObject("additionalParameters", KeyValuePair.class, true, false));
            p.parseArrayEnd();
        }
        originatorRef = p.readLong      ("originatorRef", true, false);
        try {  // for possible EnumExceptions
        communicationFormatType = com.arvatosystems.fortytwo.base.api.CommunicationFormatType.factory(p.readString("communicationFormatType", true, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        configurationRef = p.readLong      ("configurationRef", true, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (dataSinkId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "dataSinkId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (asOf == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "asOf", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (additionalParameters != null)
            for (KeyValuePair _i : additionalParameters)
        if (_i != null)
            _i.validate();  // check object
        if (dataSinkId != null) {
            if (dataSinkId.length() > 16)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "dataSinkId.length=" + dataSinkId.length() + " > 16",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (dataSinkId == null ? 0 : dataSinkId.hashCode());
        _hash = 29 * _hash + (asOf == null ? 0 : asOf.hashCode());
        _hash = 29 * _hash + (additionalParameters == null ? 0 : additionalParameters.hashCode());
        _hash = 29 * _hash + (originatorRef == null ? 0 : originatorRef.hashCode());
        _hash = 29 * _hash + (communicationFormatType == null ? 0 : communicationFormatType.hashCode());
        _hash = 29 * _hash + (configurationRef == null ? 0 : configurationRef.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof OutputSessionParameters))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof OutputSessionParameters))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        OutputSessionParameters that = (OutputSessionParameters)_that;
        return true
        && ((dataSinkId == null && that.dataSinkId == null) || (dataSinkId != null && dataSinkId.equals(that.dataSinkId)))
        && ((asOf == null && that.asOf == null) || (asOf != null && asOf.equals(that.asOf)))
        && ((additionalParameters == null && that.additionalParameters == null) || (additionalParameters != null && that.additionalParameters != null && xCompareSub$additionalParameters(that)))
        && ((originatorRef == null && that.originatorRef == null) || (originatorRef != null && originatorRef.equals(that.originatorRef)))
        && ((communicationFormatType == null && that.communicationFormatType == null) || (communicationFormatType != null && communicationFormatType.equals(that.communicationFormatType)))
        && ((configurationRef == null && that.configurationRef == null) || (configurationRef != null && configurationRef.equals(that.configurationRef)))
        ;
    }
    private boolean xCompareSub$additionalParameters(OutputSessionParameters that) {
        // both additionalParameters and that additionalParameters are known to be not null
        if (additionalParameters.size() != that.additionalParameters.size())
            return false;
        // indexed access is not optional, but sequential access will be left for later optimization
        for (int _i = 0; _i < additionalParameters.size(); ++_i)
            if (!(((additionalParameters.get(_i) == null && that.additionalParameters.get(_i) == null) || (additionalParameters.get(_i) != null && additionalParameters.get(_i).hasSameContentsAs(that.additionalParameters.get(_i))))))
                return false;
        return true;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        dataSinkId = _cvt.convert(dataSinkId, meta$$dataSinkId);
        if (additionalParameters != null)
            for (KeyValuePair _i : additionalParameters)
        if (_i != null)
            _i.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public OutputSessionParameters() {
    }
    
    // default all-arguments constructor
    public OutputSessionParameters(String dataSinkId
    , LocalDateTime asOf
    , List<KeyValuePair> additionalParameters
    , Long originatorRef
    , CommunicationFormatType communicationFormatType
    , Long configurationRef
    ) {
        this.dataSinkId = dataSinkId;
        this.asOf = asOf;
        this.additionalParameters = additionalParameters;
        this.originatorRef = originatorRef;
        this.communicationFormatType = communicationFormatType;
        this.configurationRef = configurationRef;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == OutputSessionParameters.class) {
            return (T) new OutputSessionParameters(getDataSinkId(), getAsOf(), getAdditionalParameters(), getOriginatorRef(), getCommunicationFormatType(), getConfigurationRef());
        }
        throw new IllegalArgumentException("OutputSessionParameters does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/PingRequest.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** The simplest service request parameter, which provides no further information and requests just "is alive" response. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class PingRequest extends RequestParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 112861467276L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return com.arvatosystems.fortytwo.base.api.PingResponse.class;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return RequestParameters.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.api.PingRequest";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.RequestParameters";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$pingId = new NumericElementaryDataItem(Visibility.DEFAULT, false, "pingId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$delayInMillis = new NumericElementaryDataItem(Visibility.DEFAULT, false, "delayInMillis", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$pingId;
        field$array[1] = meta$$delayInMillis;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // if not null, the id will be echoed with the response !
    Integer pingId;
    // if not null, the response will be delayed by the given number of milliseconds !
    Integer delayInMillis;
    // auto-generated getters and setters
    public Integer getPingId() {
        return pingId;
    }
    public void setPingId(Integer pingId) {
        this.pingId = pingId;
    }
    public Integer getDelayInMillis() {
        return delayInMillis;
    }
    public void setDelayInMillis(Integer delayInMillis) {
        this.delayInMillis = delayInMillis;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (pingId == null) w.writeNull(meta$$pingId); else w.addField(pingId);
        if (delayInMillis == null) w.writeNull(meta$$delayInMillis); else w.addField(delayInMillis);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("pingId")) {
            if (pingId == null) w.writeNull(meta$$pingId); else w.addField(pingId);
            return;
        }
        if (_n.equals("delayInMillis")) {
            if (delayInMillis == null) w.writeNull(meta$$delayInMillis); else w.addField(delayInMillis);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        pingId = p.readInteger   ("pingId", true, false);
        delayInMillis = p.readInteger   ("delayInMillis", true, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (pingId == null ? 0 : pingId.hashCode());
        _hash = 29 * _hash + (delayInMillis == null ? 0 : delayInMillis.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof PingRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof PingRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        PingRequest that = (PingRequest)_that;
        return super.equalsSub(_that)
        && ((pingId == null && that.pingId == null) || (pingId != null && pingId.equals(that.pingId)))
        && ((delayInMillis == null && that.delayInMillis == null) || (delayInMillis != null && delayInMillis.equals(that.delayInMillis)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public PingRequest() {
        super();
    }
    
    // default all-arguments constructor
    public PingRequest(Integer pingId
    , Integer delayInMillis
    ) {
        super();
        this.pingId = pingId;
        this.delayInMillis = delayInMillis;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == PingRequest.class) {
            return (T) new PingRequest(getPingId(), getDelayInMillis());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/PingResponse.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** The response to the PingRequest just sends the instant in time when the request has been executed on the server. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class PingResponse extends ServiceResponse
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 190081127377L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return ServiceResponse.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return ServiceResponse.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.api.PingResponse";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.ServiceResponse";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$pingId = new NumericElementaryDataItem(Visibility.DEFAULT, false, "pingId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    protected static final TemporalElementaryDataItem meta$$whenExecuted = new TemporalElementaryDataItem(Visibility.DEFAULT, true, "whenExecuted", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    protected static final TemporalElementaryDataItem meta$$whenFinished = new TemporalElementaryDataItem(Visibility.DEFAULT, true, "whenFinished", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(3);
        FieldDefinition [] field$array = new FieldDefinition[3];
        field$array[0] = meta$$pingId;
        field$array[1] = meta$$whenExecuted;
        field$array[2] = meta$$whenFinished;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // the echoed pingId, if set with the request !
    Integer pingId;
    LocalDateTime whenExecuted;
    LocalDateTime whenFinished;
    // auto-generated getters and setters
    public Integer getPingId() {
        return pingId;
    }
    public void setPingId(Integer pingId) {
        this.pingId = pingId;
    }
    public LocalDateTime getWhenExecuted() {
        return whenExecuted;
    }
    public void setWhenExecuted(LocalDateTime whenExecuted) {
        this.whenExecuted = whenExecuted;
    }
    public LocalDateTime getWhenFinished() {
        return whenFinished;
    }
    public void setWhenFinished(LocalDateTime whenFinished) {
        this.whenFinished = whenFinished;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (pingId == null) w.writeNull(meta$$pingId); else w.addField(pingId);
        w.addField(meta$$whenExecuted, whenExecuted);
        w.addField(meta$$whenFinished, whenFinished);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("pingId")) {
            if (pingId == null) w.writeNull(meta$$pingId); else w.addField(pingId);
            return;
        }
        if (_n.equals("whenExecuted")) {
            w.addField(meta$$whenExecuted, whenExecuted);
            return;
        }
        if (_n.equals("whenFinished")) {
            w.addField(meta$$whenFinished, whenFinished);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        pingId = p.readInteger   ("pingId", true, false);
        whenExecuted = p.readDayTime("whenExecuted", false, false, 0);
        whenFinished = p.readDayTime("whenFinished", false, false, 0);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (whenExecuted == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "whenExecuted", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (whenFinished == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "whenFinished", PARTIALLY_QUALIFIED_CLASS_NAME);
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (pingId == null ? 0 : pingId.hashCode());
        _hash = 29 * _hash + (whenExecuted == null ? 0 : whenExecuted.hashCode());
        _hash = 29 * _hash + (whenFinished == null ? 0 : whenFinished.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof PingResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof PingResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        PingResponse that = (PingResponse)_that;
        return super.equalsSub(_that)
        && ((pingId == null && that.pingId == null) || (pingId != null && pingId.equals(that.pingId)))
        && ((whenExecuted == null && that.whenExecuted == null) || (whenExecuted != null && whenExecuted.equals(that.whenExecuted)))
        && ((whenFinished == null && that.whenFinished == null) || (whenFinished != null && whenFinished.equals(that.whenFinished)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public PingResponse() {
        super();
    }
    
    // default all-arguments constructor
    public PingResponse(ByteArray requestId
    , String tenantId
    , Long processRef
    , int returnCode
    , String errorDetails
    , String errorMessage
    , Integer pingId
    , LocalDateTime whenExecuted
    , LocalDateTime whenFinished
    ) {
        super(requestId
        , tenantId
        , processRef
        , returnCode
        , errorDetails
        , errorMessage
        );
        this.pingId = pingId;
        this.whenExecuted = whenExecuted;
        this.whenFinished = whenFinished;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == PingResponse.class) {
            return (T) new PingResponse(getRequestId(), getTenantId(), getProcessRef(), getReturnCode(), getErrorDetails(), getErrorMessage(), getPingId(), getWhenExecuted(), getWhenFinished());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/RequestParameters.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** The RequestParameters provide an artifical common base class, only required because JAXB cannot deal with interfaces (BonaPortable as common request parameter class). */

public abstract class RequestParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -1927487608L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return com.arvatosystems.fortytwo.base.api.ServiceResponse.class;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.api.RequestParameters";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(true);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(0);
        FieldDefinition [] field$array = new FieldDefinition[0];
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // auto-generated getters and setters
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof RequestParameters))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof RequestParameters))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        RequestParameters that = (RequestParameters)_that;
        return true
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
    }
    // default no-argument constructor
    public RequestParameters() {
    }
    
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == RequestParameters.class) {
            throw new IllegalArgumentException("RequestParameters is abstract can cannot be supported by copyOf()");
        }
        throw new IllegalArgumentException("RequestParameters does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/RetryAdvice.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api;

import de.jpaw.util.EnumException;
import de.jpaw.enums.TokenizableEnum;

/** Defines the behaviour how to deal with resent (duplicate sent) messages */

public enum RetryAdvice implements TokenizableEnum {
    NEVER_RETRY("N"), ALWAYS_RETRY("A"), RETRY_ON_ERROR("E");

    // constructor by token
    private String _token;
    private RetryAdvice(String _token) {
        this._token = _token;
    }

    // token retrieval
    @Override
    public String getToken() {
        return _token;
    }

    // static factory method.
    public static RetryAdvice factory(String _token) throws EnumException {
        if (_token != null) {
            if (_token.equals("N")) return NEVER_RETRY;
            if (_token.equals("A")) return ALWAYS_RETRY;
            if (_token.equals("E")) return RETRY_ON_ERROR;
            throw new EnumException(EnumException.INVALID_NUM, _token);
        }
        return null;
    }

    public static RetryAdvice valueOf(Integer ordinal) throws EnumException {
        if (ordinal != null) {
            switch (ordinal.intValue()) {
            case 0: return NEVER_RETRY;
            case 1: return ALWAYS_RETRY;
            case 2: return RETRY_ON_ERROR;
            default: throw new EnumException(EnumException.INVALID_NUM, ordinal.toString());
            }
        }
        return null;
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/ServiceRequest.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** The ServiceRequest object defines all properties of a request. It is sent for any synchronous or asynchronous request, except JMS */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class ServiceRequest
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 1539522251L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.api.ServiceRequest";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final ObjectReference meta$$requestHeader = new ObjectReference(Visibility.DEFAULT, true, "requestHeader", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "ServiceRequestHeader", false, true, "ServiceRequestHeader");
    protected static final ObjectReference meta$$requestParameters = new ObjectReference(Visibility.DEFAULT, true, "requestParameters", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "RequestParameters", false, true, "RequestParameters");
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$requestHeader;
        field$array[1] = meta$$requestParameters;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // the standardized request header (or an extended one, for example for JMS) !
    ServiceRequestHeader requestHeader;
    // arbitrary parameters to the request !
    RequestParameters requestParameters;
    // auto-generated getters and setters
    public ServiceRequestHeader getRequestHeader() {
        return requestHeader;
    }
    public void setRequestHeader(ServiceRequestHeader requestHeader) {
        this.requestHeader = requestHeader;
    }
    public RequestParameters getRequestParameters() {
        return requestParameters;
    }
    public void setRequestParameters(RequestParameters requestParameters) {
        this.requestParameters = requestParameters;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField((BonaPortable)requestHeader);
        w.addField((BonaPortable)requestParameters);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("requestHeader")) {
            if (requestHeader == null) {
                w.writeNull(meta$$requestHeader);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)requestHeader);             // full / recursive object output
            } else {
                // write a specific subcomponent
                requestHeader.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        if (_n.equals("requestParameters")) {
            if (requestParameters == null) {
                w.writeNull(meta$$requestParameters);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)requestParameters);             // full / recursive object output
            } else {
                // write a specific subcomponent
                requestParameters.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        requestHeader = (ServiceRequestHeader)p.readObject("requestHeader", ServiceRequestHeader.class, false, true);
        requestParameters = (RequestParameters)p.readObject("requestParameters", RequestParameters.class, false, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (requestHeader == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "requestHeader", PARTIALLY_QUALIFIED_CLASS_NAME);
        requestHeader.validate();      // check object (!= null checked before)
        if (requestParameters == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "requestParameters", PARTIALLY_QUALIFIED_CLASS_NAME);
        requestParameters.validate();      // check object (!= null checked before)
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (requestHeader == null ? 0 : requestHeader.hashCode());
        _hash = 29 * _hash + (requestParameters == null ? 0 : requestParameters.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ServiceRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ServiceRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        ServiceRequest that = (ServiceRequest)_that;
        return true
        && ((requestHeader == null && that.requestHeader == null) || (requestHeader != null && requestHeader.hasSameContentsAs(that.requestHeader)))
        && ((requestParameters == null && that.requestParameters == null) || (requestParameters != null && requestParameters.hasSameContentsAs(that.requestParameters)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        if (requestHeader != null)
            requestHeader.treeWalkString(_cvt);
        if (requestParameters != null)
            requestParameters.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public ServiceRequest() {
    }
    
    // default all-arguments constructor
    public ServiceRequest(ServiceRequestHeader requestHeader
    , RequestParameters requestParameters
    ) {
        this.requestHeader = requestHeader;
        this.requestParameters = requestParameters;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == ServiceRequest.class) {
            return (T) new ServiceRequest(getRequestHeader(), getRequestParameters());
        }
        throw new IllegalArgumentException("ServiceRequest does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/ServiceRequestHeader.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** The ServiceRequestHeader is the definition of all common properties of a request. It is sent for any synchronous or asynchronous request.
     * Restructured version - move relevant information for JCA connector to the front, to simplify parsing without Bonaparte generated code...
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class ServiceRequestHeader
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 1929873720L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.api.ServiceRequestHeader";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$tenantId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "tenantId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 10, 1, null);
    protected static final AlphanumericElementaryDataItem meta$$userId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "userId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 16, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$idempotencyBehaviour$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "idempotencyBehaviour$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$idempotencyBehaviour = new EnumDataItem(Visibility.DEFAULT, true, "idempotencyBehaviour", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "RetryAdvice", false, "RetryAdvice", null);
    protected static final AlphanumericElementaryDataItem meta$$languageCode = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "languageCode", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 16, 0, "[a-z][a-z](_[A-Z][A-Z](_[a-zA-Z0-9#]+)?)?");
    protected static final NumericElementaryDataItem meta$$recordNo = new NumericElementaryDataItem(Visibility.DEFAULT, false, "recordNo", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    protected static final BinaryElementaryDataItem meta$$messageId = new BinaryElementaryDataItem(Visibility.DEFAULT, false, "messageId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.BINARY,
        "ByteArray", false, 16);
    protected static final TemporalElementaryDataItem meta$$plannedRunDate = new TemporalElementaryDataItem(Visibility.DEFAULT, false, "plannedRunDate", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    protected static final ObjectReference meta$$authenticationParameters = new ObjectReference(Visibility.DEFAULT, false, "authenticationParameters", Multiplicity.LIST, 0, 0, 0, DataCategory.OBJECT,
        "AuthenticationParameters", false, true, "AuthenticationParameters");
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(8);
        FieldDefinition [] field$array = new FieldDefinition[8];
        field$array[0] = meta$$tenantId;
        field$array[1] = meta$$userId;
        field$array[2] = meta$$idempotencyBehaviour;
        field$array[3] = meta$$languageCode;
        field$array[4] = meta$$recordNo;
        field$array[5] = meta$$messageId;
        field$array[6] = meta$$plannedRunDate;
        field$array[7] = meta$$authenticationParameters;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    String tenantId;
    String userId;
    // persistence mapping for enums not available !
    RetryAdvice idempotencyBehaviour;
    // unless default language is desired, a specific language code. !
    String languageCode;
    // serial number within logical processing (file line #, request within user session...) !
    Integer recordNo;
    // a unique ID assigned by the sender or JMS transport, to allow detection of resent messages !
    ByteArray messageId;
    // set by requests initiated by the scheduler - indicates the targeted execution time. !
    LocalDateTime plannedRunDate;
    // extra parameters provided by the sender or insert by the transport layer !
    List<AuthenticationParameters> authenticationParameters;
    // auto-generated getters and setters
    public String getTenantId() {
        return tenantId;
    }
    public void setTenantId(String tenantId) {
        this.tenantId = tenantId;
    }
    public String getUserId() {
        return userId;
    }
    public void setUserId(String userId) {
        this.userId = userId;
    }
    public RetryAdvice getIdempotencyBehaviour() {
        return idempotencyBehaviour;
    }
    public void setIdempotencyBehaviour(RetryAdvice idempotencyBehaviour) {
        this.idempotencyBehaviour = idempotencyBehaviour;
    }
    public String getLanguageCode() {
        return languageCode;
    }
    public void setLanguageCode(String languageCode) {
        this.languageCode = languageCode;
    }
    public Integer getRecordNo() {
        return recordNo;
    }
    public void setRecordNo(Integer recordNo) {
        this.recordNo = recordNo;
    }
    public ByteArray getMessageId() {
        return messageId;
    }
    public void setMessageId(ByteArray messageId) {
        this.messageId = messageId;
    }
    public LocalDateTime getPlannedRunDate() {
        return plannedRunDate;
    }
    public void setPlannedRunDate(LocalDateTime plannedRunDate) {
        this.plannedRunDate = plannedRunDate;
    }
    public List<AuthenticationParameters> getAuthenticationParameters() {
        return authenticationParameters;
    }
    public void setAuthenticationParameters(List<AuthenticationParameters> authenticationParameters) {
        this.authenticationParameters = authenticationParameters;
    }
    private static final Pattern regexp$languageCode = Pattern.compile("\\A[a-z][a-z](_[A-Z][A-Z](_[a-zA-Z0-9#]+)?)?\\z");
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(meta$$tenantId, tenantId);
        w.addField(meta$$userId, userId);
        w.addField(meta$$idempotencyBehaviour$token, idempotencyBehaviour == null ? null : idempotencyBehaviour.getToken());
        w.addField(meta$$languageCode, languageCode);
        if (recordNo == null) w.writeNull(meta$$recordNo); else w.addField(recordNo);
        w.addField(meta$$messageId, messageId);
        w.addField(meta$$plannedRunDate, plannedRunDate);
        if (authenticationParameters == null) {
            w.writeNullCollection(meta$$authenticationParameters);
        } else {
            w.startArray(authenticationParameters.size(), 0, 0);
            for (AuthenticationParameters _i : authenticationParameters)
                w.addField((BonaPortable)_i);
            w.terminateArray();
        }
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("tenantId")) {
            w.addField(meta$$tenantId, tenantId);
            return;
        }
        if (_n.equals("userId")) {
            w.addField(meta$$userId, userId);
            return;
        }
        if (_n.equals("idempotencyBehaviour")) {
            w.addField(meta$$idempotencyBehaviour$token, idempotencyBehaviour == null ? null : idempotencyBehaviour.getToken());
            return;
        }
        if (_n.equals("languageCode")) {
            w.addField(meta$$languageCode, languageCode);
            return;
        }
        if (_n.equals("recordNo")) {
            if (recordNo == null) w.writeNull(meta$$recordNo); else w.addField(recordNo);
            return;
        }
        if (_n.equals("messageId")) {
            w.addField(meta$$messageId, messageId);
            return;
        }
        if (_n.equals("plannedRunDate")) {
            w.addField(meta$$plannedRunDate, plannedRunDate);
            return;
        }
        if (_n.equals("authenticationParameters")) {
            if (authenticationParameters == null) {
                w.writeNullCollection(meta$$authenticationParameters);
            } else {
                if (pfc.index < 0) {
                    w.startArray(authenticationParameters.size(), 0, 0);
                    for (AuthenticationParameters _i : authenticationParameters) {
                        if (_i == null) {
                            w.writeNull(meta$$authenticationParameters);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)_i);             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            _i.foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                    w.terminateArray();
                } else {
                    if (pfc.index < authenticationParameters.size()) {
                        // output single element
                        if (authenticationParameters.get(pfc.index) == null) {
                            w.writeNull(meta$$authenticationParameters);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)authenticationParameters.get(pfc.index));             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            authenticationParameters.get(pfc.index).foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                }
            }
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        tenantId = p.readString    ("tenantId", false, 10, true, false, false, false);
        userId = p.readString    ("userId", false, 16, true, false, false, false);
        try {  // for possible EnumExceptions
        idempotencyBehaviour = com.arvatosystems.fortytwo.base.api.RetryAdvice.factory(p.readString("idempotencyBehaviour", false, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        languageCode = p.readString    ("languageCode", true, 16, true, false, false, false);
        recordNo = p.readInteger   ("recordNo", true, false);
        messageId = p.readByteArray ("messageId", true, 16);
        plannedRunDate = p.readDayTime("plannedRunDate", true, false, 0);
        _length = p.parseArrayStart("authenticationParameters", true, 0, 0);
        if (_length < 0) {
            authenticationParameters = null;
        } else {
            authenticationParameters = new ArrayList<AuthenticationParameters>(_length);
            for (int _i = 0; _i < _length; ++_i)
                authenticationParameters.add((AuthenticationParameters)p.readObject("authenticationParameters", AuthenticationParameters.class, true, true));
            p.parseArrayEnd();
        }
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (tenantId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "tenantId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (userId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "userId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (idempotencyBehaviour == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "idempotencyBehaviour", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (authenticationParameters != null)
            for (AuthenticationParameters _i : authenticationParameters)
        if (_i != null)
            _i.validate();  // check object
        if (tenantId != null) {
            if (tenantId.length() > 10)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "tenantId.length=" + tenantId.length() + " > 10",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
            if (tenantId.length() < 1)
                throw new ObjectValidationException(ObjectValidationException.TOO_SHORT,
                                                    "tenantId.length=" + tenantId.length() + " < 1",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (userId != null) {
            if (userId.length() > 16)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "userId.length=" + userId.length() + " > 16",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (languageCode != null) {
            if (languageCode.length() > 16)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "languageCode.length=" + languageCode.length() + " > 16",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (languageCode != null) {
            Matcher _m =  regexp$languageCode.matcher(languageCode);
            if (!_m.find())
                throw new ObjectValidationException(ObjectValidationException.NO_PATTERN_MATCH,
                                                    "languageCode", PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (tenantId == null ? 0 : tenantId.hashCode());
        _hash = 29 * _hash + (userId == null ? 0 : userId.hashCode());
        _hash = 29 * _hash + (idempotencyBehaviour == null ? 0 : idempotencyBehaviour.hashCode());
        _hash = 29 * _hash + (languageCode == null ? 0 : languageCode.hashCode());
        _hash = 29 * _hash + (recordNo == null ? 0 : recordNo.hashCode());
        _hash = 29 * _hash + (messageId == null ? 0 : messageId.hashCode());
        _hash = 29 * _hash + (plannedRunDate == null ? 0 : plannedRunDate.hashCode());
        _hash = 29 * _hash + (authenticationParameters == null ? 0 : authenticationParameters.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ServiceRequestHeader))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ServiceRequestHeader))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        ServiceRequestHeader that = (ServiceRequestHeader)_that;
        return true
        && ((tenantId == null && that.tenantId == null) || (tenantId != null && tenantId.equals(that.tenantId)))
        && ((userId == null && that.userId == null) || (userId != null && userId.equals(that.userId)))
        && ((idempotencyBehaviour == null && that.idempotencyBehaviour == null) || (idempotencyBehaviour != null && idempotencyBehaviour.equals(that.idempotencyBehaviour)))
        && ((languageCode == null && that.languageCode == null) || (languageCode != null && languageCode.equals(that.languageCode)))
        && ((recordNo == null && that.recordNo == null) || (recordNo != null && recordNo.equals(that.recordNo)))
        && ((messageId == null && that.messageId == null) || (messageId != null && messageId.contentEquals(that.messageId)))
        && ((plannedRunDate == null && that.plannedRunDate == null) || (plannedRunDate != null && plannedRunDate.equals(that.plannedRunDate)))
        && ((authenticationParameters == null && that.authenticationParameters == null) || (authenticationParameters != null && that.authenticationParameters != null && xCompareSub$authenticationParameters(that)))
        ;
    }
    private boolean xCompareSub$authenticationParameters(ServiceRequestHeader that) {
        // both authenticationParameters and that authenticationParameters are known to be not null
        if (authenticationParameters.size() != that.authenticationParameters.size())
            return false;
        // indexed access is not optional, but sequential access will be left for later optimization
        for (int _i = 0; _i < authenticationParameters.size(); ++_i)
            if (!(((authenticationParameters.get(_i) == null && that.authenticationParameters.get(_i) == null) || (authenticationParameters.get(_i) != null && authenticationParameters.get(_i).hasSameContentsAs(that.authenticationParameters.get(_i))))))
                return false;
        return true;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        tenantId = _cvt.convert(tenantId, meta$$tenantId);
        userId = _cvt.convert(userId, meta$$userId);
        languageCode = _cvt.convert(languageCode, meta$$languageCode);
        if (authenticationParameters != null)
            for (AuthenticationParameters _i : authenticationParameters)
        if (_i != null)
            _i.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public ServiceRequestHeader() {
    }
    
    // default all-arguments constructor
    public ServiceRequestHeader(String tenantId
    , String userId
    , RetryAdvice idempotencyBehaviour
    , String languageCode
    , Integer recordNo
    , ByteArray messageId
    , LocalDateTime plannedRunDate
    , List<AuthenticationParameters> authenticationParameters
    ) {
        this.tenantId = tenantId;
        this.userId = userId;
        this.idempotencyBehaviour = idempotencyBehaviour;
        this.languageCode = languageCode;
        this.recordNo = recordNo;
        this.messageId = messageId;
        this.plannedRunDate = plannedRunDate;
        this.authenticationParameters = authenticationParameters;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == ServiceRequestHeader.class) {
            return (T) new ServiceRequestHeader(getTenantId(), getUserId(), getIdempotencyBehaviour(), getLanguageCode(), getRecordNo(), getMessageId(), getPlannedRunDate(), getAuthenticationParameters());
        }
        throw new IllegalArgumentException("ServiceRequestHeader does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/ServiceResponse.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** The ServiceResponse is the base class of all response objects. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class ServiceResponse
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 533483397L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.api.ServiceResponse";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final BinaryElementaryDataItem meta$$requestId = new BinaryElementaryDataItem(Visibility.DEFAULT, false, "requestId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.BINARY,
        "ByteArray", false, 16);
    protected static final AlphanumericElementaryDataItem meta$$tenantId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "tenantId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 10, 1, null);
    protected static final NumericElementaryDataItem meta$$processRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "processRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$returnCode = new NumericElementaryDataItem(Visibility.DEFAULT, true, "returnCode", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", true, false, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$errorDetails = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "errorDetails", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 512, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$errorMessage = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "errorMessage", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 512, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(6);
        FieldDefinition [] field$array = new FieldDefinition[6];
        field$array[0] = meta$$requestId;
        field$array[1] = meta$$tenantId;
        field$array[2] = meta$$processRef;
        field$array[3] = meta$$returnCode;
        field$array[4] = meta$$errorDetails;
        field$array[5] = meta$$errorMessage;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // copied from request header !
    ByteArray requestId;
    // copied from request header !
    String tenantId;
    // created internally (unique reference) !
    Long processRef;
    // the most significant digit provides the error category. Field contains 0 if no error occured. !
    int returnCode;
    // a data parameter which allows to localize the error condition (offending field / parameter name etc.) !
    String errorDetails;
    // optional lookup of the returnCode as a standard text message, as defined in FortytwoException and derived classes. Only for convenience, may be translated to the requester's language. !
    String errorMessage;
    // auto-generated getters and setters
    public ByteArray getRequestId() {
        return requestId;
    }
    public void setRequestId(ByteArray requestId) {
        this.requestId = requestId;
    }
    public String getTenantId() {
        return tenantId;
    }
    public void setTenantId(String tenantId) {
        this.tenantId = tenantId;
    }
    public Long getProcessRef() {
        return processRef;
    }
    public void setProcessRef(Long processRef) {
        this.processRef = processRef;
    }
    public int getReturnCode() {
        return returnCode;
    }
    public void setReturnCode(int returnCode) {
        this.returnCode = returnCode;
    }
    public String getErrorDetails() {
        return errorDetails;
    }
    public void setErrorDetails(String errorDetails) {
        this.errorDetails = errorDetails;
    }
    public String getErrorMessage() {
        return errorMessage;
    }
    public void setErrorMessage(String errorMessage) {
        this.errorMessage = errorMessage;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(meta$$requestId, requestId);
        w.addField(meta$$tenantId, tenantId);
        if (processRef == null) w.writeNull(meta$$processRef); else w.addField(processRef);
        w.addField(returnCode);
        w.addField(meta$$errorDetails, errorDetails);
        w.addField(meta$$errorMessage, errorMessage);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("requestId")) {
            w.addField(meta$$requestId, requestId);
            return;
        }
        if (_n.equals("tenantId")) {
            w.addField(meta$$tenantId, tenantId);
            return;
        }
        if (_n.equals("processRef")) {
            if (processRef == null) w.writeNull(meta$$processRef); else w.addField(processRef);
            return;
        }
        if (_n.equals("returnCode")) {
            w.addField(returnCode);
            return;
        }
        if (_n.equals("errorDetails")) {
            w.addField(meta$$errorDetails, errorDetails);
            return;
        }
        if (_n.equals("errorMessage")) {
            w.addField(meta$$errorMessage, errorMessage);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        requestId = p.readByteArray ("requestId", true, 16);
        tenantId = p.readString    ("tenantId", false, 10, true, false, false, false);
        processRef = p.readLong      ("processRef", false, false);
        returnCode = p.readInteger   ("returnCode", false, false);
        errorDetails = p.readString    ("errorDetails", true, 512, true, false, false, false);
        errorMessage = p.readString    ("errorMessage", true, 512, true, false, false, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (tenantId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "tenantId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (processRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "processRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (tenantId != null) {
            if (tenantId.length() > 10)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "tenantId.length=" + tenantId.length() + " > 10",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
            if (tenantId.length() < 1)
                throw new ObjectValidationException(ObjectValidationException.TOO_SHORT,
                                                    "tenantId.length=" + tenantId.length() + " < 1",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (errorDetails != null) {
            if (errorDetails.length() > 512)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "errorDetails.length=" + errorDetails.length() + " > 512",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (errorMessage != null) {
            if (errorMessage.length() > 512)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "errorMessage.length=" + errorMessage.length() + " > 512",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (requestId == null ? 0 : requestId.hashCode());
        _hash = 29 * _hash + (tenantId == null ? 0 : tenantId.hashCode());
        _hash = 29 * _hash + (processRef == null ? 0 : processRef.hashCode());
        _hash = 29 * _hash + returnCode;
        _hash = 29 * _hash + (errorDetails == null ? 0 : errorDetails.hashCode());
        _hash = 29 * _hash + (errorMessage == null ? 0 : errorMessage.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ServiceResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ServiceResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        ServiceResponse that = (ServiceResponse)_that;
        return true
        && ((requestId == null && that.requestId == null) || (requestId != null && requestId.contentEquals(that.requestId)))
        && ((tenantId == null && that.tenantId == null) || (tenantId != null && tenantId.equals(that.tenantId)))
        && ((processRef == null && that.processRef == null) || (processRef != null && processRef.equals(that.processRef)))
        && returnCode == that.returnCode
        && ((errorDetails == null && that.errorDetails == null) || (errorDetails != null && errorDetails.equals(that.errorDetails)))
        && ((errorMessage == null && that.errorMessage == null) || (errorMessage != null && errorMessage.equals(that.errorMessage)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        tenantId = _cvt.convert(tenantId, meta$$tenantId);
        errorDetails = _cvt.convert(errorDetails, meta$$errorDetails);
        errorMessage = _cvt.convert(errorMessage, meta$$errorMessage);
    }
    // default no-argument constructor
    public ServiceResponse() {
    }
    
    // default all-arguments constructor
    public ServiceResponse(ByteArray requestId
    , String tenantId
    , Long processRef
    , int returnCode
    , String errorDetails
    , String errorMessage
    ) {
        this.requestId = requestId;
        this.tenantId = tenantId;
        this.processRef = processRef;
        this.returnCode = returnCode;
        this.errorDetails = errorDetails;
        this.errorMessage = errorMessage;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == ServiceResponse.class) {
            return (T) new ServiceResponse(getRequestId(), getTenantId(), getProcessRef(), getReturnCode(), getErrorDetails(), getErrorMessage());
        }
        throw new IllegalArgumentException("ServiceResponse does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/SessionParameters.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** The SessionParameters are provided once per connection / file upload and provide information about the connecting client.
     * This is for debugging / auditing purposes only. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class SessionParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -341093681L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.api.SessionParameters";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$executable = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "executable", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 100, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$dataUrl = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "dataUrl", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 255, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$singleTenantId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "singleTenantId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 10, 1, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(3);
        FieldDefinition [] field$array = new FieldDefinition[3];
        field$array[0] = meta$$executable;
        field$array[1] = meta$$dataUrl;
        field$array[2] = meta$$singleTenantId;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // program loading the data / accepting the transmission !
    String executable;
    // filename or just protocol : port number or queue name !
    String dataUrl;
    // if non null, every request will belong to the same tenant (allows better caching) !
    String singleTenantId;
    // auto-generated getters and setters
    public String getExecutable() {
        return executable;
    }
    public void setExecutable(String executable) {
        this.executable = executable;
    }
    public String getDataUrl() {
        return dataUrl;
    }
    public void setDataUrl(String dataUrl) {
        this.dataUrl = dataUrl;
    }
    public String getSingleTenantId() {
        return singleTenantId;
    }
    public void setSingleTenantId(String singleTenantId) {
        this.singleTenantId = singleTenantId;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(meta$$executable, executable);
        w.addField(meta$$dataUrl, dataUrl);
        w.addField(meta$$singleTenantId, singleTenantId);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("executable")) {
            w.addField(meta$$executable, executable);
            return;
        }
        if (_n.equals("dataUrl")) {
            w.addField(meta$$dataUrl, dataUrl);
            return;
        }
        if (_n.equals("singleTenantId")) {
            w.addField(meta$$singleTenantId, singleTenantId);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        executable = p.readString    ("executable", false, 100, true, false, false, false);
        dataUrl = p.readString    ("dataUrl", false, 255, true, false, false, true);
        singleTenantId = p.readString    ("singleTenantId", true, 10, true, false, false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (executable == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "executable", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (dataUrl == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "dataUrl", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (executable != null) {
            if (executable.length() > 100)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "executable.length=" + executable.length() + " > 100",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (dataUrl != null) {
            if (dataUrl.length() > 255)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "dataUrl.length=" + dataUrl.length() + " > 255",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (singleTenantId != null) {
            if (singleTenantId.length() > 10)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "singleTenantId.length=" + singleTenantId.length() + " > 10",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
            if (singleTenantId.length() < 1)
                throw new ObjectValidationException(ObjectValidationException.TOO_SHORT,
                                                    "singleTenantId.length=" + singleTenantId.length() + " < 1",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (executable == null ? 0 : executable.hashCode());
        _hash = 29 * _hash + (dataUrl == null ? 0 : dataUrl.hashCode());
        _hash = 29 * _hash + (singleTenantId == null ? 0 : singleTenantId.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof SessionParameters))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof SessionParameters))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        SessionParameters that = (SessionParameters)_that;
        return true
        && ((executable == null && that.executable == null) || (executable != null && executable.equals(that.executable)))
        && ((dataUrl == null && that.dataUrl == null) || (dataUrl != null && dataUrl.equals(that.dataUrl)))
        && ((singleTenantId == null && that.singleTenantId == null) || (singleTenantId != null && singleTenantId.equals(that.singleTenantId)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        executable = _cvt.convert(executable, meta$$executable);
        dataUrl = _cvt.convert(dataUrl, meta$$dataUrl);
        singleTenantId = _cvt.convert(singleTenantId, meta$$singleTenantId);
    }
    // default no-argument constructor
    public SessionParameters() {
    }
    
    // default all-arguments constructor
    public SessionParameters(String executable
    , String dataUrl
    , String singleTenantId
    ) {
        this.executable = executable;
        this.dataUrl = dataUrl;
        this.singleTenantId = singleTenantId;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == SessionParameters.class) {
            return (T) new SessionParameters(getExecutable(), getDataUrl(), getSingleTenantId());
        }
        throw new IllegalArgumentException("SessionParameters does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/package-info.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

@XmlJavaTypeAdapters({
    @XmlJavaTypeAdapter(type=LocalDate.class,       value=LocalDateAdapter.class),
    @XmlJavaTypeAdapter(type=LocalTime.class,       value=LocalTimeAdapter.class),
    @XmlJavaTypeAdapter(type=LocalDateTime.class,   value=LocalDateTimeAdapter.class),
    @XmlJavaTypeAdapter(type=ByteArray.class,       value=ByteArrayAdapter.class)
})
/** 
 * Package which contains the definitions of all essential message elements.
 */
package com.arvatosystems.fortytwo.base.api;

import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapters;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import org.joda.time.LocalTime;
import de.jpaw.util.ByteArray;

import de.jpaw.xml.jaxb.ByteArrayAdapter;
import de.jpaw.xml.jaxb.LocalDateAdapter;
import de.jpaw.xml.jaxb.LocalTimeAdapter;
import de.jpaw.xml.jaxb.LocalDateTimeAdapter;
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/ping/BpmPingRequest.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api.ping;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.api.RequestParameters;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class BpmPingRequest extends RequestParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -103992441181L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        map.putIfAbsent("bpmId", "bpmPingService");
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return RequestParameters.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return RequestParameters.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.api.ping.BpmPingRequest";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.RequestParameters";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$iterations = new NumericElementaryDataItem(Visibility.DEFAULT, false, "iterations", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$delay = new NumericElementaryDataItem(Visibility.DEFAULT, false, "delay", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$iterations;
        field$array[1] = meta$$delay;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    Integer iterations;
    Integer delay;
    // auto-generated getters and setters
    public Integer getIterations() {
        return iterations;
    }
    public void setIterations(Integer iterations) {
        this.iterations = iterations;
    }
    public Integer getDelay() {
        return delay;
    }
    public void setDelay(Integer delay) {
        this.delay = delay;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (iterations == null) w.writeNull(meta$$iterations); else w.addField(iterations);
        if (delay == null) w.writeNull(meta$$delay); else w.addField(delay);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("iterations")) {
            if (iterations == null) w.writeNull(meta$$iterations); else w.addField(iterations);
            return;
        }
        if (_n.equals("delay")) {
            if (delay == null) w.writeNull(meta$$delay); else w.addField(delay);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        iterations = p.readInteger   ("iterations", true, false);
        delay = p.readInteger   ("delay", true, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (iterations == null ? 0 : iterations.hashCode());
        _hash = 29 * _hash + (delay == null ? 0 : delay.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof BpmPingRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof BpmPingRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        BpmPingRequest that = (BpmPingRequest)_that;
        return super.equalsSub(_that)
        && ((iterations == null && that.iterations == null) || (iterations != null && iterations.equals(that.iterations)))
        && ((delay == null && that.delay == null) || (delay != null && delay.equals(that.delay)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public BpmPingRequest() {
        super();
    }
    
    // default all-arguments constructor
    public BpmPingRequest(Integer iterations
    , Integer delay
    ) {
        super();
        this.iterations = iterations;
        this.delay = delay;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == BpmPingRequest.class) {
            return (T) new BpmPingRequest(getIterations(), getDelay());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/ping/package-info.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

@XmlJavaTypeAdapters({
    @XmlJavaTypeAdapter(type=LocalDate.class,       value=LocalDateAdapter.class),
    @XmlJavaTypeAdapter(type=LocalTime.class,       value=LocalTimeAdapter.class),
    @XmlJavaTypeAdapter(type=LocalDateTime.class,   value=LocalDateTimeAdapter.class),
    @XmlJavaTypeAdapter(type=ByteArray.class,       value=ByteArrayAdapter.class)
})
/** 
 * Package which contains the definitions of all essential message elements.
 */
package com.arvatosystems.fortytwo.base.api.ping;

import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapters;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import org.joda.time.LocalTime;
import de.jpaw.util.ByteArray;

import de.jpaw.xml.jaxb.ByteArrayAdapter;
import de.jpaw.xml.jaxb.LocalDateAdapter;
import de.jpaw.xml.jaxb.LocalTimeAdapter;
import de.jpaw.xml.jaxb.LocalDateTimeAdapter;
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/types/Crud.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api.types;

import de.jpaw.util.EnumException;
import de.jpaw.enums.TokenizableEnum;


public enum Crud implements TokenizableEnum {
    CREATE("C"), READ("R"), UPDATE("U"), DELETE("D"), INACTIVATE("I"), ACTIVATE("A");

    // constructor by token
    private String _token;
    private Crud(String _token) {
        this._token = _token;
    }

    // token retrieval
    @Override
    public String getToken() {
        return _token;
    }

    // static factory method.
    public static Crud factory(String _token) throws EnumException {
        if (_token != null) {
            if (_token.equals("C")) return CREATE;
            if (_token.equals("R")) return READ;
            if (_token.equals("U")) return UPDATE;
            if (_token.equals("D")) return DELETE;
            if (_token.equals("I")) return INACTIVATE;
            if (_token.equals("A")) return ACTIVATE;
            throw new EnumException(EnumException.INVALID_NUM, _token);
        }
        return null;
    }

    public static Crud valueOf(Integer ordinal) throws EnumException {
        if (ordinal != null) {
            switch (ordinal.intValue()) {
            case 0: return CREATE;
            case 1: return READ;
            case 2: return UPDATE;
            case 3: return DELETE;
            case 4: return INACTIVATE;
            case 5: return ACTIVATE;
            default: throw new EnumException(EnumException.INVALID_NUM, ordinal.toString());
            }
        }
        return null;
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/types/TenantIsolationCategory.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.api.types;

import de.jpaw.util.EnumException;
import de.jpaw.enums.TokenizableEnum;

/** UI relevant category of underlying entity. The token of this enum should be available from DTO classes via class$Property("tenantCategory"). */

public enum TenantIsolationCategory implements TokenizableEnum {
    GLOBAL("G"), ISOLATED("I"), ISOLATED_WITH_DEFAULT("D"), ISOLATED_WITH_ADMIN("A"), SPECIAL("S");

    // constructor by token
    private String _token;
    private TenantIsolationCategory(String _token) {
        this._token = _token;
    }

    // token retrieval
    @Override
    public String getToken() {
        return _token;
    }

    // static factory method.
    public static TenantIsolationCategory factory(String _token) throws EnumException {
        if (_token != null) {
            if (_token.equals("G")) return GLOBAL;
            if (_token.equals("I")) return ISOLATED;
            if (_token.equals("D")) return ISOLATED_WITH_DEFAULT;
            if (_token.equals("A")) return ISOLATED_WITH_ADMIN;
            if (_token.equals("S")) return SPECIAL;
            throw new EnumException(EnumException.INVALID_NUM, _token);
        }
        return null;
    }

    public static TenantIsolationCategory valueOf(Integer ordinal) throws EnumException {
        if (ordinal != null) {
            switch (ordinal.intValue()) {
            case 0: return GLOBAL;
            case 1: return ISOLATED;
            case 2: return ISOLATED_WITH_DEFAULT;
            case 3: return ISOLATED_WITH_ADMIN;
            case 4: return SPECIAL;
            default: throw new EnumException(EnumException.INVALID_NUM, ordinal.toString());
            }
        }
        return null;
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/api/types/package-info.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

package com.arvatosystems.fortytwo.base.api.types;
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/conf/AbstractConfigObject.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.conf;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** An arbitrary base class which should be inherited by specific data object which must be stored. In the UI project, a mapper
     * between the object and a stringified version must be provided, which allows maintenance of the data using the UI.
     * The default mapping used will be a JSON converter.
     */

public abstract class AbstractConfigObject
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -1985438160L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.conf.AbstractConfigObject";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(true);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(0);
        FieldDefinition [] field$array = new FieldDefinition[0];
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // auto-generated getters and setters
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AbstractConfigObject))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AbstractConfigObject))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        AbstractConfigObject that = (AbstractConfigObject)_that;
        return true
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
    }
    // default no-argument constructor
    public AbstractConfigObject() {
    }
    
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == AbstractConfigObject.class) {
            throw new IllegalArgumentException("AbstractConfigObject is abstract can cannot be supported by copyOf()");
        }
        throw new IllegalArgumentException("AbstractConfigObject does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/conf/ConfigDTO.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.conf;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;


/** A configuration record as exchanged with the frontend for a simple administration UI. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
@com.arvatosystems.fortytwo.base.TenantCategory("I")    
public class ConfigDTO extends ConfigRef
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 176107852328L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        map.putIfAbsent("tenantCategory", "I");
        map.putIfAbsent("configGroup.noupdate", "");
        map.putIfAbsent("configKey.noupdate", "");
        map.putIfAbsent("genericRef1.noupdate", "");
        map.putIfAbsent("genericRef2.noupdate", "");
        map.putIfAbsent("objectProperty.serialized", "");
        // ConfigRef.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return ConfigRef.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return ConfigRef.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || ConfigRef.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || ConfigRef.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return ConfigRef.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return ConfigRef.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.conf.ConfigDTO";
    private static final String REVISION = null;
    private static final String PARENT = "base.conf.ConfigRef";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$configGroup = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "configGroup", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 16, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$configKey = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "configKey", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 64, 0, null);
    protected static final NumericElementaryDataItem meta$$genericRef1 = new NumericElementaryDataItem(Visibility.DEFAULT, true, "genericRef1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$genericRef2 = new NumericElementaryDataItem(Visibility.DEFAULT, true, "genericRef2", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$configTypeEnum$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "configTypeEnum$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$configTypeEnum = new EnumDataItem(Visibility.DEFAULT, true, "configTypeEnum", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "ConfigTypeEnum", false, "ConfigTypeEnum", null);
    protected static final MiscElementaryDataItem meta$$booleanProperty = new MiscElementaryDataItem(Visibility.DEFAULT, false, "booleanProperty", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", false);
    protected static final NumericElementaryDataItem meta$$integerProperty = new NumericElementaryDataItem(Visibility.DEFAULT, false, "integerProperty", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$decimalProperty = new NumericElementaryDataItem(Visibility.DEFAULT, false, "decimalProperty", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "BigDecimal", false, false, 18, 6, false, false);
    protected static final AlphanumericElementaryDataItem meta$$stringProperty = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "stringProperty", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1024, 0, null);
    protected static final ObjectReference meta$$objectProperty = new ObjectReference(Visibility.DEFAULT, false, "objectProperty", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "AbstractConfigObject", false, true, "AbstractConfigObject");
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(10);
        FieldDefinition [] field$array = new FieldDefinition[10];
        field$array[0] = meta$$configGroup;
        field$array[1] = meta$$configKey;
        field$array[2] = meta$$genericRef1;
        field$array[3] = meta$$genericRef2;
        field$array[4] = meta$$configTypeEnum;
        field$array[5] = meta$$booleanProperty;
        field$array[6] = meta$$integerProperty;
        field$array[7] = meta$$decimalProperty;
        field$array[8] = meta$$stringProperty;
        field$array[9] = meta$$objectProperty;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // the fixed key (application index) !
    @com.arvatosystems.fortytwo.base.NotUpdatable
    String configGroup;
    // a concatenated key of additional key parameters, "-" if not required. !
    @com.arvatosystems.fortytwo.base.NotUpdatable
    String configKey;
    // the first generic reference, 0 if not required !
    @com.arvatosystems.fortytwo.base.NotUpdatable
    Long genericRef1;
    // the second generic reference, 0 if not required !
    @com.arvatosystems.fortytwo.base.NotUpdatable
    Long genericRef2;
    // indicator, which type of field is used !
    ConfigTypeEnum configTypeEnum;
    // a boolean type property !
    Boolean booleanProperty;
    // an integer type property !
    Long integerProperty;
    // a decimal type property !
    BigDecimal decimalProperty;
    // a string type property !
    String stringProperty;
    // any arbitrary object, stored serialized. !
    AbstractConfigObject objectProperty;
    // auto-generated getters and setters
    public String getConfigGroup() {
        return configGroup;
    }
    public void setConfigGroup(String configGroup) {
        this.configGroup = configGroup;
    }
    public String getConfigKey() {
        return configKey;
    }
    public void setConfigKey(String configKey) {
        this.configKey = configKey;
    }
    public Long getGenericRef1() {
        return genericRef1;
    }
    public void setGenericRef1(Long genericRef1) {
        this.genericRef1 = genericRef1;
    }
    public Long getGenericRef2() {
        return genericRef2;
    }
    public void setGenericRef2(Long genericRef2) {
        this.genericRef2 = genericRef2;
    }
    public ConfigTypeEnum getConfigTypeEnum() {
        return configTypeEnum;
    }
    public void setConfigTypeEnum(ConfigTypeEnum configTypeEnum) {
        this.configTypeEnum = configTypeEnum;
    }
    public Boolean getBooleanProperty() {
        return booleanProperty;
    }
    public void setBooleanProperty(Boolean booleanProperty) {
        this.booleanProperty = booleanProperty;
    }
    public Long getIntegerProperty() {
        return integerProperty;
    }
    public void setIntegerProperty(Long integerProperty) {
        this.integerProperty = integerProperty;
    }
    public BigDecimal getDecimalProperty() {
        return decimalProperty;
    }
    public void setDecimalProperty(BigDecimal decimalProperty) {
        this.decimalProperty = decimalProperty;
    }
    public String getStringProperty() {
        return stringProperty;
    }
    public void setStringProperty(String stringProperty) {
        this.stringProperty = stringProperty;
    }
    public AbstractConfigObject getObjectProperty() {
        return objectProperty;
    }
    public void setObjectProperty(AbstractConfigObject objectProperty) {
        this.objectProperty = objectProperty;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$configGroup, configGroup);
        w.addField(meta$$configKey, configKey);
        if (genericRef1 == null) w.writeNull(meta$$genericRef1); else w.addField(genericRef1);
        if (genericRef2 == null) w.writeNull(meta$$genericRef2); else w.addField(genericRef2);
        w.addField(meta$$configTypeEnum$token, configTypeEnum == null ? null : configTypeEnum.getToken());
        if (booleanProperty == null) w.writeNull(meta$$booleanProperty); else w.addField(booleanProperty);
        if (integerProperty == null) w.writeNull(meta$$integerProperty); else w.addField(integerProperty);
        w.addField(meta$$decimalProperty, decimalProperty);
        w.addField(meta$$stringProperty, stringProperty);
        w.addField((BonaPortable)objectProperty);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("configGroup")) {
            w.addField(meta$$configGroup, configGroup);
            return;
        }
        if (_n.equals("configKey")) {
            w.addField(meta$$configKey, configKey);
            return;
        }
        if (_n.equals("genericRef1")) {
            if (genericRef1 == null) w.writeNull(meta$$genericRef1); else w.addField(genericRef1);
            return;
        }
        if (_n.equals("genericRef2")) {
            if (genericRef2 == null) w.writeNull(meta$$genericRef2); else w.addField(genericRef2);
            return;
        }
        if (_n.equals("configTypeEnum")) {
            w.addField(meta$$configTypeEnum$token, configTypeEnum == null ? null : configTypeEnum.getToken());
            return;
        }
        if (_n.equals("booleanProperty")) {
            if (booleanProperty == null) w.writeNull(meta$$booleanProperty); else w.addField(booleanProperty);
            return;
        }
        if (_n.equals("integerProperty")) {
            if (integerProperty == null) w.writeNull(meta$$integerProperty); else w.addField(integerProperty);
            return;
        }
        if (_n.equals("decimalProperty")) {
            w.addField(meta$$decimalProperty, decimalProperty);
            return;
        }
        if (_n.equals("stringProperty")) {
            w.addField(meta$$stringProperty, stringProperty);
            return;
        }
        if (_n.equals("objectProperty")) {
            if (objectProperty == null) {
                w.writeNull(meta$$objectProperty);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)objectProperty);             // full / recursive object output
            } else {
                // write a specific subcomponent
                objectProperty.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        configGroup = p.readString    ("configGroup", false, 16, true, false, false, false);
        configKey = p.readString    ("configKey", false, 64, true, false, false, true);
        genericRef1 = p.readLong      ("genericRef1", false, false);
        genericRef2 = p.readLong      ("genericRef2", false, false);
        try {  // for possible EnumExceptions
        configTypeEnum = com.arvatosystems.fortytwo.base.conf.ConfigTypeEnum.factory(p.readString("configTypeEnum", false, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        booleanProperty = p.readBoolean   ("booleanProperty", true);
        integerProperty = p.readLong      ("integerProperty", true, false);
        decimalProperty = p.readBigDecimal("decimalProperty", true, 18, 6, false, false, false);
        stringProperty = p.readString    ("stringProperty", true, 1024, true, false, false, true);
        objectProperty = (AbstractConfigObject)p.readObject("objectProperty", AbstractConfigObject.class, true, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (configGroup == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "configGroup", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (configKey == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "configKey", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (genericRef1 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "genericRef1", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (genericRef2 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "genericRef2", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (configTypeEnum == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "configTypeEnum", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (objectProperty != null)
            objectProperty.validate();  // check object
        if (configGroup != null) {
            if (configGroup.length() > 16)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "configGroup.length=" + configGroup.length() + " > 16",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (configKey != null) {
            if (configKey.length() > 64)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "configKey.length=" + configKey.length() + " > 64",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (stringProperty != null) {
            if (stringProperty.length() > 1024)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "stringProperty.length=" + stringProperty.length() + " > 1024",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (configGroup == null ? 0 : configGroup.hashCode());
        _hash = 29 * _hash + (configKey == null ? 0 : configKey.hashCode());
        _hash = 29 * _hash + (genericRef1 == null ? 0 : genericRef1.hashCode());
        _hash = 29 * _hash + (genericRef2 == null ? 0 : genericRef2.hashCode());
        _hash = 29 * _hash + (configTypeEnum == null ? 0 : configTypeEnum.hashCode());
        _hash = 29 * _hash + (booleanProperty == null ? 0 : booleanProperty.hashCode());
        _hash = 29 * _hash + (integerProperty == null ? 0 : integerProperty.hashCode());
        _hash = 29 * _hash + BigDecimalTools.hashCode(decimalProperty, 6);
        _hash = 29 * _hash + (stringProperty == null ? 0 : stringProperty.hashCode());
        _hash = 29 * _hash + (objectProperty == null ? 0 : objectProperty.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ConfigDTO))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ConfigDTO))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        ConfigDTO that = (ConfigDTO)_that;
        return super.equalsSub(_that)
        && ((configGroup == null && that.configGroup == null) || (configGroup != null && configGroup.equals(that.configGroup)))
        && ((configKey == null && that.configKey == null) || (configKey != null && configKey.equals(that.configKey)))
        && ((genericRef1 == null && that.genericRef1 == null) || (genericRef1 != null && genericRef1.equals(that.genericRef1)))
        && ((genericRef2 == null && that.genericRef2 == null) || (genericRef2 != null && genericRef2.equals(that.genericRef2)))
        && ((configTypeEnum == null && that.configTypeEnum == null) || (configTypeEnum != null && configTypeEnum.equals(that.configTypeEnum)))
        && ((booleanProperty == null && that.booleanProperty == null) || (booleanProperty != null && booleanProperty.equals(that.booleanProperty)))
        && ((integerProperty == null && that.integerProperty == null) || (integerProperty != null && integerProperty.equals(that.integerProperty)))
        && ((decimalProperty == null && that.decimalProperty == null) || (decimalProperty != null && BigDecimalTools.equals(decimalProperty, 6, that.decimalProperty, 6)))
        && ((stringProperty == null && that.stringProperty == null) || (stringProperty != null && stringProperty.equals(that.stringProperty)))
        && ((objectProperty == null && that.objectProperty == null) || (objectProperty != null && objectProperty.hasSameContentsAs(that.objectProperty)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        configGroup = _cvt.convert(configGroup, meta$$configGroup);
        configKey = _cvt.convert(configKey, meta$$configKey);
        stringProperty = _cvt.convert(stringProperty, meta$$stringProperty);
        if (objectProperty != null)
            objectProperty.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public ConfigDTO() {
        super();
    }
    
    // default all-arguments constructor
    public ConfigDTO(Long objectRef
    , String configGroup
    , String configKey
    , Long genericRef1
    , Long genericRef2
    , ConfigTypeEnum configTypeEnum
    , Boolean booleanProperty
    , Long integerProperty
    , BigDecimal decimalProperty
    , String stringProperty
    , AbstractConfigObject objectProperty
    ) {
        super(objectRef
        );
        this.configGroup = configGroup;
        this.configKey = configKey;
        this.genericRef1 = genericRef1;
        this.genericRef2 = genericRef2;
        this.configTypeEnum = configTypeEnum;
        this.booleanProperty = booleanProperty;
        this.integerProperty = integerProperty;
        this.decimalProperty = decimalProperty;
        this.stringProperty = stringProperty;
        this.objectProperty = objectProperty;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == ConfigDTO.class) {
            return (T) new ConfigDTO(getObjectRef(), getConfigGroup(), getConfigKey(), getGenericRef1(), getGenericRef2(), getConfigTypeEnum(), getBooleanProperty(), getIntegerProperty(), getDecimalProperty(), getStringProperty(), getObjectProperty());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/conf/ConfigKey.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.conf;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;


/** Defines the natural key for a configuration entry. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class ConfigKey extends ConfigRef
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 176108808104L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // ConfigRef.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return ConfigRef.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return ConfigRef.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || ConfigRef.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || ConfigRef.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return ConfigRef.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return ConfigRef.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.conf.ConfigKey";
    private static final String REVISION = null;
    private static final String PARENT = "base.conf.ConfigRef";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$configGroup = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "configGroup", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 16, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$configKey = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "configKey", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 64, 0, null);
    protected static final NumericElementaryDataItem meta$$genericRef1 = new NumericElementaryDataItem(Visibility.DEFAULT, true, "genericRef1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$genericRef2 = new NumericElementaryDataItem(Visibility.DEFAULT, true, "genericRef2", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(4);
        FieldDefinition [] field$array = new FieldDefinition[4];
        field$array[0] = meta$$configGroup;
        field$array[1] = meta$$configKey;
        field$array[2] = meta$$genericRef1;
        field$array[3] = meta$$genericRef2;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // the fixed key (application index) !
    String configGroup;
    // a concatenated key of additional key parameters, "-" if not required. !
    String configKey;
    // the first generic reference, 0 if not required !
    Long genericRef1;
    // the second generic reference, 0 if not required !
    Long genericRef2;
    // auto-generated getters and setters
    public String getConfigGroup() {
        return configGroup;
    }
    public void setConfigGroup(String configGroup) {
        this.configGroup = configGroup;
    }
    public String getConfigKey() {
        return configKey;
    }
    public void setConfigKey(String configKey) {
        this.configKey = configKey;
    }
    public Long getGenericRef1() {
        return genericRef1;
    }
    public void setGenericRef1(Long genericRef1) {
        this.genericRef1 = genericRef1;
    }
    public Long getGenericRef2() {
        return genericRef2;
    }
    public void setGenericRef2(Long genericRef2) {
        this.genericRef2 = genericRef2;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$configGroup, configGroup);
        w.addField(meta$$configKey, configKey);
        if (genericRef1 == null) w.writeNull(meta$$genericRef1); else w.addField(genericRef1);
        if (genericRef2 == null) w.writeNull(meta$$genericRef2); else w.addField(genericRef2);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("configGroup")) {
            w.addField(meta$$configGroup, configGroup);
            return;
        }
        if (_n.equals("configKey")) {
            w.addField(meta$$configKey, configKey);
            return;
        }
        if (_n.equals("genericRef1")) {
            if (genericRef1 == null) w.writeNull(meta$$genericRef1); else w.addField(genericRef1);
            return;
        }
        if (_n.equals("genericRef2")) {
            if (genericRef2 == null) w.writeNull(meta$$genericRef2); else w.addField(genericRef2);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        configGroup = p.readString    ("configGroup", false, 16, true, false, false, false);
        configKey = p.readString    ("configKey", false, 64, true, false, false, true);
        genericRef1 = p.readLong      ("genericRef1", false, false);
        genericRef2 = p.readLong      ("genericRef2", false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (configGroup == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "configGroup", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (configKey == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "configKey", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (genericRef1 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "genericRef1", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (genericRef2 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "genericRef2", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (configGroup != null) {
            if (configGroup.length() > 16)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "configGroup.length=" + configGroup.length() + " > 16",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (configKey != null) {
            if (configKey.length() > 64)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "configKey.length=" + configKey.length() + " > 64",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (configGroup == null ? 0 : configGroup.hashCode());
        _hash = 29 * _hash + (configKey == null ? 0 : configKey.hashCode());
        _hash = 29 * _hash + (genericRef1 == null ? 0 : genericRef1.hashCode());
        _hash = 29 * _hash + (genericRef2 == null ? 0 : genericRef2.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ConfigKey))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ConfigKey))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        ConfigKey that = (ConfigKey)_that;
        return super.equalsSub(_that)
        && ((configGroup == null && that.configGroup == null) || (configGroup != null && configGroup.equals(that.configGroup)))
        && ((configKey == null && that.configKey == null) || (configKey != null && configKey.equals(that.configKey)))
        && ((genericRef1 == null && that.genericRef1 == null) || (genericRef1 != null && genericRef1.equals(that.genericRef1)))
        && ((genericRef2 == null && that.genericRef2 == null) || (genericRef2 != null && genericRef2.equals(that.genericRef2)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        configGroup = _cvt.convert(configGroup, meta$$configGroup);
        configKey = _cvt.convert(configKey, meta$$configKey);
    }
    // default no-argument constructor
    public ConfigKey() {
        super();
    }
    
    // default all-arguments constructor
    public ConfigKey(Long objectRef
    , String configGroup
    , String configKey
    , Long genericRef1
    , Long genericRef2
    ) {
        super(objectRef
        );
        this.configGroup = configGroup;
        this.configKey = configKey;
        this.genericRef1 = genericRef1;
        this.genericRef2 = genericRef2;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == ConfigKey.class) {
            return (T) new ConfigKey(getObjectRef(), getConfigGroup(), getConfigKey(), getGenericRef1(), getGenericRef2());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/conf/ConfigRef.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.conf;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;


/** A reference to a single configuration entry. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class ConfigRef extends Ref
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 87073744248L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // Ref.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return Ref.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return Ref.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.conf.ConfigRef";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.Ref";
    private static final String BUNDLE = null;
    
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(0);
        FieldDefinition [] field$array = new FieldDefinition[0];
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // auto-generated getters and setters
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ConfigRef))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ConfigRef))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        ConfigRef that = (ConfigRef)_that;
        return super.equalsSub(_that)
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public ConfigRef() {
        super();
    }
    
    // default all-arguments constructor
    public ConfigRef(Long objectRef
    ) {
        super(objectRef
        );
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == ConfigRef.class) {
            return (T) new ConfigRef(getObjectRef());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/conf/ConfigTypeEnum.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.conf;

import de.jpaw.util.EnumException;
import de.jpaw.enums.TokenizableEnum;

/** The ConfigTypeEnum indicates, which kind of information is stored in the configuration record.
     * It is a policy that only a single of the value fields is used per record.
     */

public enum ConfigTypeEnum implements TokenizableEnum {
    BOOLEAN("B"), INTEGRAL("I"), REFERENCE("R"), FRACTIONAL("F"), TEXT("T"), OBJECT("O");

    // constructor by token
    private String _token;
    private ConfigTypeEnum(String _token) {
        this._token = _token;
    }

    // token retrieval
    @Override
    public String getToken() {
        return _token;
    }

    // static factory method.
    public static ConfigTypeEnum factory(String _token) throws EnumException {
        if (_token != null) {
            if (_token.equals("B")) return BOOLEAN;
            if (_token.equals("I")) return INTEGRAL;
            if (_token.equals("R")) return REFERENCE;
            if (_token.equals("F")) return FRACTIONAL;
            if (_token.equals("T")) return TEXT;
            if (_token.equals("O")) return OBJECT;
            throw new EnumException(EnumException.INVALID_NUM, _token);
        }
        return null;
    }

    public static ConfigTypeEnum valueOf(Integer ordinal) throws EnumException {
        if (ordinal != null) {
            switch (ordinal.intValue()) {
            case 0: return BOOLEAN;
            case 1: return INTEGRAL;
            case 2: return REFERENCE;
            case 3: return FRACTIONAL;
            case 4: return TEXT;
            case 5: return OBJECT;
            default: throw new EnumException(EnumException.INVALID_NUM, ordinal.toString());
            }
        }
        return null;
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/conf/ReadConfigMultipleEntriesRequest.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.conf;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.api.RequestParameters;


/** If multiple entries exist for the same configGroup (i.e. are required by the same process), multiple separate READs
     * should be avoided and the whole available set read instead in a single JPA query, using this API.
     * Depending on the setting of readGlobal, only the default settings (stored with the @ tenant) will be read, or the tenant
     * specific entries. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class ReadConfigMultipleEntriesRequest extends RequestParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -94083712924L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // RequestParameters.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RequestParameters.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RequestParameters.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || RequestParameters.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || RequestParameters.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return RequestParameters.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return RequestParameters.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.conf.ReadConfigMultipleEntriesRequest";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.RequestParameters";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$configGroup = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "configGroup", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 16, 0, null);
    protected static final MiscElementaryDataItem meta$$readGlobalTenant = new MiscElementaryDataItem(Visibility.DEFAULT, true, "readGlobalTenant", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", true);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$configGroup;
        field$array[1] = meta$$readGlobalTenant;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // the fixed key (application index) !
    String configGroup;
    // if true, the application defaults will be read, else the entries of the default tenant !
    boolean readGlobalTenant;
    // auto-generated getters and setters
    public String getConfigGroup() {
        return configGroup;
    }
    public void setConfigGroup(String configGroup) {
        this.configGroup = configGroup;
    }
    public boolean getReadGlobalTenant() {
        return readGlobalTenant;
    }
    public void setReadGlobalTenant(boolean readGlobalTenant) {
        this.readGlobalTenant = readGlobalTenant;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$configGroup, configGroup);
        w.addField(readGlobalTenant);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("configGroup")) {
            w.addField(meta$$configGroup, configGroup);
            return;
        }
        if (_n.equals("readGlobalTenant")) {
            w.addField(readGlobalTenant);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        configGroup = p.readString    ("configGroup", false, 16, true, false, false, false);
        readGlobalTenant = p.readBoolean   ("readGlobalTenant", false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (configGroup == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "configGroup", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (configGroup != null) {
            if (configGroup.length() > 16)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "configGroup.length=" + configGroup.length() + " > 16",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (configGroup == null ? 0 : configGroup.hashCode());
        _hash = 29 * _hash + (readGlobalTenant ? 1231 : 1237);
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ReadConfigMultipleEntriesRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ReadConfigMultipleEntriesRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        ReadConfigMultipleEntriesRequest that = (ReadConfigMultipleEntriesRequest)_that;
        return super.equalsSub(_that)
        && ((configGroup == null && that.configGroup == null) || (configGroup != null && configGroup.equals(that.configGroup)))
        && readGlobalTenant == that.readGlobalTenant
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        configGroup = _cvt.convert(configGroup, meta$$configGroup);
    }
    // default no-argument constructor
    public ReadConfigMultipleEntriesRequest() {
        super();
    }
    
    // default all-arguments constructor
    public ReadConfigMultipleEntriesRequest(String configGroup
    , boolean readGlobalTenant
    ) {
        super();
        this.configGroup = configGroup;
        this.readGlobalTenant = readGlobalTenant;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == ReadConfigMultipleEntriesRequest.class) {
            return (T) new ReadConfigMultipleEntriesRequest(getConfigGroup(), getReadGlobalTenant());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/conf/ReadConfigMultipleEntriesResponse.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.conf;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.api.ServiceResponse;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class ReadConfigMultipleEntriesResponse extends ServiceResponse
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -36171585287L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // ServiceResponse.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return ServiceResponse.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return ServiceResponse.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || ServiceResponse.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || ServiceResponse.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return ServiceResponse.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return ServiceResponse.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.conf.ReadConfigMultipleEntriesResponse";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.ServiceResponse";
    private static final String BUNDLE = null;
    
    protected static final ObjectReference meta$$entries = new ObjectReference(Visibility.DEFAULT, true, "entries", Multiplicity.LIST, 0, 0, 0, DataCategory.OBJECT,
        "ConfigDTO", false, true, "ConfigDTO");
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$entries;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    List<ConfigDTO> entries;
    // auto-generated getters and setters
    public List<ConfigDTO> getEntries() {
        return entries;
    }
    public void setEntries(List<ConfigDTO> entries) {
        this.entries = entries;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (entries == null) {
            w.writeNullCollection(meta$$entries);
        } else {
            w.startArray(entries.size(), 0, 0);
            for (ConfigDTO _i : entries)
                w.addField((BonaPortable)_i);
            w.terminateArray();
        }
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("entries")) {
            if (entries == null) {
                w.writeNullCollection(meta$$entries);
            } else {
                if (pfc.index < 0) {
                    w.startArray(entries.size(), 0, 0);
                    for (ConfigDTO _i : entries) {
                        if (_i == null) {
                            w.writeNull(meta$$entries);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)_i);             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            _i.foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                    w.terminateArray();
                } else {
                    if (pfc.index < entries.size()) {
                        // output single element
                        if (entries.get(pfc.index) == null) {
                            w.writeNull(meta$$entries);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)entries.get(pfc.index));             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            entries.get(pfc.index).foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                }
            }
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        _length = p.parseArrayStart("entries", true, 0, 0);
        if (_length < 0) {
            entries = null;
        } else {
            entries = new ArrayList<ConfigDTO>(_length);
            for (int _i = 0; _i < _length; ++_i)
                entries.add((ConfigDTO)p.readObject("entries", ConfigDTO.class, false, true));
            p.parseArrayEnd();
        }
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (entries != null)
            for (ConfigDTO _i : entries)
        if (_i == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "_i", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (entries != null)
            for (ConfigDTO _i : entries)
        _i.validate();      // check object (!= null checked before)
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (entries == null ? 0 : entries.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ReadConfigMultipleEntriesResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ReadConfigMultipleEntriesResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        ReadConfigMultipleEntriesResponse that = (ReadConfigMultipleEntriesResponse)_that;
        return super.equalsSub(_that)
        && ((entries == null && that.entries == null) || (entries != null && that.entries != null && xCompareSub$entries(that)))
        ;
    }
    private boolean xCompareSub$entries(ReadConfigMultipleEntriesResponse that) {
        // both entries and that entries are known to be not null
        if (entries.size() != that.entries.size())
            return false;
        // indexed access is not optional, but sequential access will be left for later optimization
        for (int _i = 0; _i < entries.size(); ++_i)
            if (!(((entries.get(_i) == null && that.entries.get(_i) == null) || (entries.get(_i) != null && entries.get(_i).hasSameContentsAs(that.entries.get(_i))))))
                return false;
        return true;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        if (entries != null)
            for (ConfigDTO _i : entries)
        if (_i != null)
            _i.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public ReadConfigMultipleEntriesResponse() {
        super();
    }
    
    // default all-arguments constructor
    public ReadConfigMultipleEntriesResponse(ByteArray requestId
    , String tenantId
    , Long processRef
    , int returnCode
    , String errorDetails
    , String errorMessage
    , List<ConfigDTO> entries
    ) {
        super(requestId
        , tenantId
        , processRef
        , returnCode
        , errorDetails
        , errorMessage
        );
        this.entries = entries;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == ReadConfigMultipleEntriesResponse.class) {
            return (T) new ReadConfigMultipleEntriesResponse(getRequestId(), getTenantId(), getProcessRef(), getReturnCode(), getErrorDetails(), getErrorMessage(), getEntries());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/conf/ReadConfigWithDefaultsRequest.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.conf;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.api.RequestParameters;


/** A service request to read a single configuration value, and to fall back to specific defaults if no entry is found.
     * If no entry is found with the specific key, the fields genericRef2, 1, configKey and tenantRef will be set to default values (if configured) as follows:
     * genericRef2 - 0
     * genericRef1 - 0
     * tenantRef - 1001 (GLOBAL_TENANT_REF)
     * 
     * In case the specific parameter did have the according value already, of course no second redundant SELECT will be performed. 
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class ReadConfigWithDefaultsRequest extends RequestParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -120210789154L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // RequestParameters.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RequestParameters.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RequestParameters.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || RequestParameters.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || RequestParameters.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return RequestParameters.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return RequestParameters.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.conf.ReadConfigWithDefaultsRequest";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.RequestParameters";
    private static final String BUNDLE = null;
    
    protected static final ObjectReference meta$$key = new ObjectReference(Visibility.DEFAULT, false, "key", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "ConfigKey", false, false, "ConfigKey");
    protected static final MiscElementaryDataItem meta$$retryWithDefaultRef2 = new MiscElementaryDataItem(Visibility.DEFAULT, true, "retryWithDefaultRef2", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", true);
    protected static final MiscElementaryDataItem meta$$retryWithDefaultRef1 = new MiscElementaryDataItem(Visibility.DEFAULT, true, "retryWithDefaultRef1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", true);
    protected static final MiscElementaryDataItem meta$$retryWithDefaultTenant = new MiscElementaryDataItem(Visibility.DEFAULT, true, "retryWithDefaultTenant", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", true);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(4);
        FieldDefinition [] field$array = new FieldDefinition[4];
        field$array[0] = meta$$key;
        field$array[1] = meta$$retryWithDefaultRef2;
        field$array[2] = meta$$retryWithDefaultRef1;
        field$array[3] = meta$$retryWithDefaultTenant;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // the desired key data !
    ConfigKey key;
    // if TRUE, a retry will be done with genericRef2 = 0, else not. !
    boolean retryWithDefaultRef2;
    // if TRUE, a retry will be done with genericRef1 = 0, else not. !
    boolean retryWithDefaultRef1;
    // if TRUE, a retry will be done with tenantRef = GLOBAL_TENANT_REF, else not. !
    boolean retryWithDefaultTenant;
    // auto-generated getters and setters
    public ConfigKey getKey() {
        return key;
    }
    public void setKey(ConfigKey key) {
        this.key = key;
    }
    public boolean getRetryWithDefaultRef2() {
        return retryWithDefaultRef2;
    }
    public void setRetryWithDefaultRef2(boolean retryWithDefaultRef2) {
        this.retryWithDefaultRef2 = retryWithDefaultRef2;
    }
    public boolean getRetryWithDefaultRef1() {
        return retryWithDefaultRef1;
    }
    public void setRetryWithDefaultRef1(boolean retryWithDefaultRef1) {
        this.retryWithDefaultRef1 = retryWithDefaultRef1;
    }
    public boolean getRetryWithDefaultTenant() {
        return retryWithDefaultTenant;
    }
    public void setRetryWithDefaultTenant(boolean retryWithDefaultTenant) {
        this.retryWithDefaultTenant = retryWithDefaultTenant;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField((BonaPortable)key);
        w.addField(retryWithDefaultRef2);
        w.addField(retryWithDefaultRef1);
        w.addField(retryWithDefaultTenant);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("key")) {
            if (key == null) {
                w.writeNull(meta$$key);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)key);             // full / recursive object output
            } else {
                // write a specific subcomponent
                key.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        if (_n.equals("retryWithDefaultRef2")) {
            w.addField(retryWithDefaultRef2);
            return;
        }
        if (_n.equals("retryWithDefaultRef1")) {
            w.addField(retryWithDefaultRef1);
            return;
        }
        if (_n.equals("retryWithDefaultTenant")) {
            w.addField(retryWithDefaultTenant);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        key = (ConfigKey)p.readObject("key", ConfigKey.class, true, false);
        retryWithDefaultRef2 = p.readBoolean   ("retryWithDefaultRef2", false);
        retryWithDefaultRef1 = p.readBoolean   ("retryWithDefaultRef1", false);
        retryWithDefaultTenant = p.readBoolean   ("retryWithDefaultTenant", false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (key != null)
            key.validate();  // check object
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (key == null ? 0 : key.hashCode());
        _hash = 29 * _hash + (retryWithDefaultRef2 ? 1231 : 1237);
        _hash = 29 * _hash + (retryWithDefaultRef1 ? 1231 : 1237);
        _hash = 29 * _hash + (retryWithDefaultTenant ? 1231 : 1237);
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ReadConfigWithDefaultsRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ReadConfigWithDefaultsRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        ReadConfigWithDefaultsRequest that = (ReadConfigWithDefaultsRequest)_that;
        return super.equalsSub(_that)
        && ((key == null && that.key == null) || (key != null && key.hasSameContentsAs(that.key)))
        && retryWithDefaultRef2 == that.retryWithDefaultRef2
        && retryWithDefaultRef1 == that.retryWithDefaultRef1
        && retryWithDefaultTenant == that.retryWithDefaultTenant
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        if (key != null)
            key.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public ReadConfigWithDefaultsRequest() {
        super();
    }
    
    // default all-arguments constructor
    public ReadConfigWithDefaultsRequest(ConfigKey key
    , boolean retryWithDefaultRef2
    , boolean retryWithDefaultRef1
    , boolean retryWithDefaultTenant
    ) {
        super();
        this.key = key;
        this.retryWithDefaultRef2 = retryWithDefaultRef2;
        this.retryWithDefaultRef1 = retryWithDefaultRef1;
        this.retryWithDefaultTenant = retryWithDefaultTenant;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == ReadConfigWithDefaultsRequest.class) {
            return (T) new ReadConfigWithDefaultsRequest(getKey(), getRetryWithDefaultRef2(), getRetryWithDefaultRef1(), getRetryWithDefaultTenant());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/conf/ReadConfigWithDefaultsResponse.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.conf;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.api.ServiceResponse;


/** Returns the selected record. The defaultsUsed flag shows, if the record is specific (false) or less specific (true). 
     *  The configurationResult is empty (null) if no record has been found.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class ReadConfigWithDefaultsResponse extends ServiceResponse
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 279170483135L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // ServiceResponse.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return ServiceResponse.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return ServiceResponse.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || ServiceResponse.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || ServiceResponse.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return ServiceResponse.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return ServiceResponse.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.conf.ReadConfigWithDefaultsResponse";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.ServiceResponse";
    private static final String BUNDLE = null;
    
    protected static final ObjectReference meta$$configurationResult = new ObjectReference(Visibility.DEFAULT, false, "configurationResult", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "ConfigDTO", false, true, "ConfigDTO");
    protected static final MiscElementaryDataItem meta$$defaultsUsed = new MiscElementaryDataItem(Visibility.DEFAULT, true, "defaultsUsed", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", true);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$configurationResult;
        field$array[1] = meta$$defaultsUsed;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // if null, no configuration has been found for the key !
    ConfigDTO configurationResult;
    // if FALSE, the specific entry was found, otherwise at least one value was set to defaults !
    boolean defaultsUsed;
    // auto-generated getters and setters
    public ConfigDTO getConfigurationResult() {
        return configurationResult;
    }
    public void setConfigurationResult(ConfigDTO configurationResult) {
        this.configurationResult = configurationResult;
    }
    public boolean getDefaultsUsed() {
        return defaultsUsed;
    }
    public void setDefaultsUsed(boolean defaultsUsed) {
        this.defaultsUsed = defaultsUsed;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField((BonaPortable)configurationResult);
        w.addField(defaultsUsed);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("configurationResult")) {
            if (configurationResult == null) {
                w.writeNull(meta$$configurationResult);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)configurationResult);             // full / recursive object output
            } else {
                // write a specific subcomponent
                configurationResult.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        if (_n.equals("defaultsUsed")) {
            w.addField(defaultsUsed);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        configurationResult = (ConfigDTO)p.readObject("configurationResult", ConfigDTO.class, true, true);
        defaultsUsed = p.readBoolean   ("defaultsUsed", false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (configurationResult != null)
            configurationResult.validate();  // check object
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (configurationResult == null ? 0 : configurationResult.hashCode());
        _hash = 29 * _hash + (defaultsUsed ? 1231 : 1237);
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ReadConfigWithDefaultsResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ReadConfigWithDefaultsResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        ReadConfigWithDefaultsResponse that = (ReadConfigWithDefaultsResponse)_that;
        return super.equalsSub(_that)
        && ((configurationResult == null && that.configurationResult == null) || (configurationResult != null && configurationResult.hasSameContentsAs(that.configurationResult)))
        && defaultsUsed == that.defaultsUsed
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        if (configurationResult != null)
            configurationResult.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public ReadConfigWithDefaultsResponse() {
        super();
    }
    
    // default all-arguments constructor
    public ReadConfigWithDefaultsResponse(ByteArray requestId
    , String tenantId
    , Long processRef
    , int returnCode
    , String errorDetails
    , String errorMessage
    , ConfigDTO configurationResult
    , boolean defaultsUsed
    ) {
        super(requestId
        , tenantId
        , processRef
        , returnCode
        , errorDetails
        , errorMessage
        );
        this.configurationResult = configurationResult;
        this.defaultsUsed = defaultsUsed;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == ReadConfigWithDefaultsResponse.class) {
            return (T) new ReadConfigWithDefaultsResponse(getRequestId(), getTenantId(), getProcessRef(), getReturnCode(), getErrorDetails(), getErrorMessage(), getConfigurationResult(), getDefaultsUsed());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/conf/package-info.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

@XmlJavaTypeAdapters({
    @XmlJavaTypeAdapter(type=LocalDate.class,       value=LocalDateAdapter.class),
    @XmlJavaTypeAdapter(type=LocalTime.class,       value=LocalTimeAdapter.class),
    @XmlJavaTypeAdapter(type=LocalDateTime.class,   value=LocalDateTimeAdapter.class),
    @XmlJavaTypeAdapter(type=ByteArray.class,       value=ByteArrayAdapter.class)
})
package com.arvatosystems.fortytwo.base.conf;

import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapters;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import org.joda.time.LocalTime;
import de.jpaw.util.ByteArray;

import de.jpaw.xml.jaxb.ByteArrayAdapter;
import de.jpaw.xml.jaxb.LocalDateAdapter;
import de.jpaw.xml.jaxb.LocalTimeAdapter;
import de.jpaw.xml.jaxb.LocalDateTimeAdapter;
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/core/Ascii_.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.core;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class Ascii_
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -778098464L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.core.Ascii_";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$value = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "value", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, false, false, true, true, 4000, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$value;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    String value;
    // auto-generated getters and setters
    public String getValue() {
        return value;
    }
    public void setValue(String value) {
        this.value = value;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(meta$$value, value);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("value")) {
            w.addField(meta$$value, value);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        value = p.readString    ("value", true, 4000, false, false, false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (value != null) {
            if (value.length() > 4000)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "value.length=" + value.length() + " > 4000",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (value == null ? 0 : value.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Ascii_))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Ascii_))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        Ascii_ that = (Ascii_)_that;
        return true
        && ((value == null && that.value == null) || (value != null && value.equals(that.value)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        value = _cvt.convert(value, meta$$value);
    }
    // default no-argument constructor
    public Ascii_() {
    }
    
    // default all-arguments constructor
    public Ascii_(String value
    ) {
        this.value = value;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Ascii_.class) {
            return (T) new Ascii_(getValue());
        }
        throw new IllegalArgumentException("Ascii_ does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/core/Boolean_.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.core;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class Boolean_
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -1889312151L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.core.Boolean_";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final MiscElementaryDataItem meta$$value = new MiscElementaryDataItem(Visibility.DEFAULT, false, "value", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$value;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    Boolean value;
    // auto-generated getters and setters
    public Boolean getValue() {
        return value;
    }
    public void setValue(Boolean value) {
        this.value = value;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        if (value == null) w.writeNull(meta$$value); else w.addField(value);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("value")) {
            if (value == null) w.writeNull(meta$$value); else w.addField(value);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        value = p.readBoolean   ("value", true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (value == null ? 0 : value.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Boolean_))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Boolean_))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        Boolean_ that = (Boolean_)_that;
        return true
        && ((value == null && that.value == null) || (value != null && value.equals(that.value)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
    }
    // default no-argument constructor
    public Boolean_() {
    }
    
    // default all-arguments constructor
    public Boolean_(Boolean value
    ) {
        this.value = value;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Boolean_.class) {
            return (T) new Boolean_(getValue());
        }
        throw new IllegalArgumentException("Boolean_ does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/core/Day_.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.core;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class Day_
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -1922522507L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.core.Day_";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final TemporalElementaryDataItem meta$$value = new TemporalElementaryDataItem(Visibility.DEFAULT, false, "value", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDate", false, 0, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$value;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    LocalDate value;
    // auto-generated getters and setters
    public LocalDate getValue() {
        return value;
    }
    public void setValue(LocalDate value) {
        this.value = value;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(meta$$value, value);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("value")) {
            w.addField(meta$$value, value);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        value = p.readDay("value", true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (value == null ? 0 : value.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Day_))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Day_))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        Day_ that = (Day_)_that;
        return true
        && ((value == null && that.value == null) || (value != null && value.equals(that.value)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
    }
    // default no-argument constructor
    public Day_() {
    }
    
    // default all-arguments constructor
    public Day_(LocalDate value
    ) {
        this.value = value;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Day_.class) {
            return (T) new Day_(getValue());
        }
        throw new IllegalArgumentException("Day_ does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/core/Decimal_.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.core;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class Decimal_
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 965124192L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.core.Decimal_";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$value = new NumericElementaryDataItem(Visibility.DEFAULT, false, "value", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "BigDecimal", false, true, 18, 6, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$value;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    BigDecimal value;
    // auto-generated getters and setters
    public BigDecimal getValue() {
        return value;
    }
    public void setValue(BigDecimal value) {
        this.value = value;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(meta$$value, value);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("value")) {
            w.addField(meta$$value, value);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        value = p.readBigDecimal("value", true, 18, 6, true, false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + BigDecimalTools.hashCode(value, 6);
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Decimal_))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Decimal_))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        Decimal_ that = (Decimal_)_that;
        return true
        && ((value == null && that.value == null) || (value != null && BigDecimalTools.equals(value, 6, that.value, 6)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
    }
    // default no-argument constructor
    public Decimal_() {
    }
    
    // default all-arguments constructor
    public Decimal_(BigDecimal value
    ) {
        this.value = value;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Decimal_.class) {
            return (T) new Decimal_(getValue());
        }
        throw new IllegalArgumentException("Decimal_ does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/core/Double_.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.core;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class Double_
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -81803460L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.core.Double_";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$value = new NumericElementaryDataItem(Visibility.DEFAULT, false, "value", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Double", false, true, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$value;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    Double value;
    // auto-generated getters and setters
    public Double getValue() {
        return value;
    }
    public void setValue(Double value) {
        this.value = value;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        if (value == null) w.writeNull(meta$$value); else w.addField(value);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("value")) {
            if (value == null) w.writeNull(meta$$value); else w.addField(value);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        value = p.readDouble    ("value", true, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (value == null ? 0 : value.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Double_))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Double_))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        Double_ that = (Double_)_that;
        return true
        && ((value == null && that.value == null) || (value != null && value.equals(that.value)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
    }
    // default no-argument constructor
    public Double_() {
    }
    
    // default all-arguments constructor
    public Double_(Double value
    ) {
        this.value = value;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Double_.class) {
            return (T) new Double_(getValue());
        }
        throw new IllegalArgumentException("Double_ does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/core/Enum_.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.core;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class Enum_
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 532651916L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.core.Enum_";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$clazz = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "clazz", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, false, false, true, true, 300, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$name = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "name", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, false, false, true, true, 100, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$clazz;
        field$array[1] = meta$$name;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    String clazz;
    String name;
    // auto-generated getters and setters
    public String getClazz() {
        return clazz;
    }
    public void setClazz(String clazz) {
        this.clazz = clazz;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(meta$$clazz, clazz);
        w.addField(meta$$name, name);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("clazz")) {
            w.addField(meta$$clazz, clazz);
            return;
        }
        if (_n.equals("name")) {
            w.addField(meta$$name, name);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        clazz = p.readString    ("clazz", true, 300, false, false, false, false);
        name = p.readString    ("name", true, 100, false, false, false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (clazz != null) {
            if (clazz.length() > 300)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "clazz.length=" + clazz.length() + " > 300",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (name != null) {
            if (name.length() > 100)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "name.length=" + name.length() + " > 100",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (clazz == null ? 0 : clazz.hashCode());
        _hash = 29 * _hash + (name == null ? 0 : name.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Enum_))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Enum_))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        Enum_ that = (Enum_)_that;
        return true
        && ((clazz == null && that.clazz == null) || (clazz != null && clazz.equals(that.clazz)))
        && ((name == null && that.name == null) || (name != null && name.equals(that.name)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        clazz = _cvt.convert(clazz, meta$$clazz);
        name = _cvt.convert(name, meta$$name);
    }
    // default no-argument constructor
    public Enum_() {
    }
    
    // default all-arguments constructor
    public Enum_(String clazz
    , String name
    ) {
        this.clazz = clazz;
        this.name = name;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Enum_.class) {
            return (T) new Enum_(getClazz(), getName());
        }
        throw new IllegalArgumentException("Enum_ does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/core/Integer_.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.core;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class Integer_
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 969666579L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.core.Integer_";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$value = new NumericElementaryDataItem(Visibility.DEFAULT, false, "value", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, true, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$value;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    Integer value;
    // auto-generated getters and setters
    public Integer getValue() {
        return value;
    }
    public void setValue(Integer value) {
        this.value = value;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        if (value == null) w.writeNull(meta$$value); else w.addField(value);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("value")) {
            if (value == null) w.writeNull(meta$$value); else w.addField(value);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        value = p.readInteger   ("value", true, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (value == null ? 0 : value.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Integer_))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Integer_))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        Integer_ that = (Integer_)_that;
        return true
        && ((value == null && that.value == null) || (value != null && value.equals(that.value)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
    }
    // default no-argument constructor
    public Integer_() {
    }
    
    // default all-arguments constructor
    public Integer_(Integer value
    ) {
        this.value = value;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Integer_.class) {
            return (T) new Integer_(getValue());
        }
        throw new IllegalArgumentException("Integer_ does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/core/Long_.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.core;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class Long_
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 539139441L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.core.Long_";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$value = new NumericElementaryDataItem(Visibility.DEFAULT, false, "value", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, true, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$value;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    Long value;
    // auto-generated getters and setters
    public Long getValue() {
        return value;
    }
    public void setValue(Long value) {
        this.value = value;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        if (value == null) w.writeNull(meta$$value); else w.addField(value);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("value")) {
            if (value == null) w.writeNull(meta$$value); else w.addField(value);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        value = p.readLong      ("value", true, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (value == null ? 0 : value.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Long_))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Long_))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        Long_ that = (Long_)_that;
        return true
        && ((value == null && that.value == null) || (value != null && value.equals(that.value)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
    }
    // default no-argument constructor
    public Long_() {
    }
    
    // default all-arguments constructor
    public Long_(Long value
    ) {
        this.value = value;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Long_.class) {
            return (T) new Long_(getValue());
        }
        throw new IllegalArgumentException("Long_ does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/core/SingleValueBase.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.core;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



public abstract class SingleValueBase
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 1012871944L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.core.SingleValueBase";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(true);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(0);
        FieldDefinition [] field$array = new FieldDefinition[0];
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // auto-generated getters and setters
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof SingleValueBase))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof SingleValueBase))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        SingleValueBase that = (SingleValueBase)_that;
        return true
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
    }
    // default no-argument constructor
    public SingleValueBase() {
    }
    
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == SingleValueBase.class) {
            throw new IllegalArgumentException("SingleValueBase is abstract can cannot be supported by copyOf()");
        }
        throw new IllegalArgumentException("SingleValueBase does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/core/Timestamp_.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.core;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class Timestamp_
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -830488901L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.core.Timestamp_";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final TemporalElementaryDataItem meta$$value = new TemporalElementaryDataItem(Visibility.DEFAULT, false, "value", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$value;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    LocalDateTime value;
    // auto-generated getters and setters
    public LocalDateTime getValue() {
        return value;
    }
    public void setValue(LocalDateTime value) {
        this.value = value;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(meta$$value, value);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("value")) {
            w.addField(meta$$value, value);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        value = p.readDayTime("value", true, false, 0);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (value == null ? 0 : value.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Timestamp_))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Timestamp_))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        Timestamp_ that = (Timestamp_)_that;
        return true
        && ((value == null && that.value == null) || (value != null && value.equals(that.value)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
    }
    // default no-argument constructor
    public Timestamp_() {
    }
    
    // default all-arguments constructor
    public Timestamp_(LocalDateTime value
    ) {
        this.value = value;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Timestamp_.class) {
            return (T) new Timestamp_(getValue());
        }
        throw new IllegalArgumentException("Timestamp_ does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/core/Unicode_.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.core;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class Unicode_
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 92023380L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.core.Unicode_";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$value = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "value", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, false, false, true, false, 4000, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$value;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    String value;
    // auto-generated getters and setters
    public String getValue() {
        return value;
    }
    public void setValue(String value) {
        this.value = value;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(meta$$value, value);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("value")) {
            w.addField(meta$$value, value);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        value = p.readString    ("value", true, 4000, false, false, true, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (value != null) {
            if (value.length() > 4000)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "value.length=" + value.length() + " > 4000",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (value == null ? 0 : value.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Unicode_))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Unicode_))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        Unicode_ that = (Unicode_)_that;
        return true
        && ((value == null && that.value == null) || (value != null && value.equals(that.value)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        value = _cvt.convert(value, meta$$value);
    }
    // default no-argument constructor
    public Unicode_() {
    }
    
    // default all-arguments constructor
    public Unicode_(String value
    ) {
        this.value = value;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Unicode_.class) {
            return (T) new Unicode_(getValue());
        }
        throw new IllegalArgumentException("Unicode_ does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/core/Uppercase_.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.core;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class Uppercase_
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 94858367L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.core.Uppercase_";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$value = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "value", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, false, false, true, true, 3, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$value;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    String value;
    // auto-generated getters and setters
    public String getValue() {
        return value;
    }
    public void setValue(String value) {
        this.value = value;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(meta$$value, value);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("value")) {
            w.addField(meta$$value, value);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        value = p.readString    ("value", true, 3, false, false, false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (value != null) {
            if (value.length() > 3)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "value.length=" + value.length() + " > 3",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (value == null ? 0 : value.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Uppercase_))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Uppercase_))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        Uppercase_ that = (Uppercase_)_that;
        return true
        && ((value == null && that.value == null) || (value != null && value.equals(that.value)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        value = _cvt.convert(value, meta$$value);
    }
    // default no-argument constructor
    public Uppercase_() {
    }
    
    // default all-arguments constructor
    public Uppercase_(String value
    ) {
        this.value = value;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Uppercase_.class) {
            return (T) new Uppercase_(getValue());
        }
        throw new IllegalArgumentException("Uppercase_ does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/core/package-info.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

@XmlJavaTypeAdapters({
    @XmlJavaTypeAdapter(type=LocalDate.class,       value=LocalDateAdapter.class),
    @XmlJavaTypeAdapter(type=LocalTime.class,       value=LocalTimeAdapter.class),
    @XmlJavaTypeAdapter(type=LocalDateTime.class,   value=LocalDateTimeAdapter.class),
    @XmlJavaTypeAdapter(type=ByteArray.class,       value=ByteArrayAdapter.class)
})
package com.arvatosystems.fortytwo.base.core;

import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapters;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import org.joda.time.LocalTime;
import de.jpaw.util.ByteArray;

import de.jpaw.xml.jaxb.ByteArrayAdapter;
import de.jpaw.xml.jaxb.LocalDateAdapter;
import de.jpaw.xml.jaxb.LocalTimeAdapter;
import de.jpaw.xml.jaxb.LocalDateTimeAdapter;
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/AdditionalHistoryTableColumns.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.api.types.Crud;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class AdditionalHistoryTableColumns
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -2009085931L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.data.AdditionalHistoryTableColumns";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$crud$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "crud$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$crud = new EnumDataItem(Visibility.DEFAULT, true, "crud", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "Crud", false, "Crud", null);
    protected static final NumericElementaryDataItem meta$$historyNo = new NumericElementaryDataItem(Visibility.DEFAULT, true, "historyNo", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", true, false, 0, 0, false, false);
    protected static final TemporalElementaryDataItem meta$$localTimestamp = new TemporalElementaryDataItem(Visibility.DEFAULT, true, "localTimestamp", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(3);
        FieldDefinition [] field$array = new FieldDefinition[3];
        field$array[0] = meta$$crud;
        field$array[1] = meta$$historyNo;
        field$array[2] = meta$$localTimestamp;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    Crud crud;
    // maybe we do not need this, because we have the version now !
    long historyNo;
    LocalDateTime localTimestamp;
    // auto-generated getters and setters
    public Crud getCrud() {
        return crud;
    }
    public void setCrud(Crud crud) {
        this.crud = crud;
    }
    public long getHistoryNo() {
        return historyNo;
    }
    public void setHistoryNo(long historyNo) {
        this.historyNo = historyNo;
    }
    public LocalDateTime getLocalTimestamp() {
        return localTimestamp;
    }
    public void setLocalTimestamp(LocalDateTime localTimestamp) {
        this.localTimestamp = localTimestamp;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(meta$$crud$token, crud == null ? null : crud.getToken());
        w.addField(historyNo);
        w.addField(meta$$localTimestamp, localTimestamp);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("crud")) {
            w.addField(meta$$crud$token, crud == null ? null : crud.getToken());
            return;
        }
        if (_n.equals("historyNo")) {
            w.addField(historyNo);
            return;
        }
        if (_n.equals("localTimestamp")) {
            w.addField(meta$$localTimestamp, localTimestamp);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        try {  // for possible EnumExceptions
        crud = com.arvatosystems.fortytwo.base.api.types.Crud.factory(p.readString("crud", false, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        historyNo = p.readLong      ("historyNo", false, false);
        localTimestamp = p.readDayTime("localTimestamp", false, false, 0);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (crud == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "crud", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (localTimestamp == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "localTimestamp", PARTIALLY_QUALIFIED_CLASS_NAME);
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (crud == null ? 0 : crud.hashCode());
        _hash = 29 * _hash + (int)(historyNo^(historyNo>>>32));
        _hash = 29 * _hash + (localTimestamp == null ? 0 : localTimestamp.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AdditionalHistoryTableColumns))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AdditionalHistoryTableColumns))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        AdditionalHistoryTableColumns that = (AdditionalHistoryTableColumns)_that;
        return true
        && ((crud == null && that.crud == null) || (crud != null && crud.equals(that.crud)))
        && historyNo == that.historyNo
        && ((localTimestamp == null && that.localTimestamp == null) || (localTimestamp != null && localTimestamp.equals(that.localTimestamp)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
    }
    // default no-argument constructor
    public AdditionalHistoryTableColumns() {
    }
    
    // default all-arguments constructor
    public AdditionalHistoryTableColumns(Crud crud
    , long historyNo
    , LocalDateTime localTimestamp
    ) {
        this.crud = crud;
        this.historyNo = historyNo;
        this.localTimestamp = localTimestamp;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == AdditionalHistoryTableColumns.class) {
            return (T) new AdditionalHistoryTableColumns(getCrud(), getHistoryNo(), getLocalTimestamp());
        }
        throw new IllegalArgumentException("AdditionalHistoryTableColumns does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/AuthenticationType.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import de.jpaw.util.EnumException;
import de.jpaw.enums.TokenizableEnum;

/**
     * The types of authentication the system shall support.
     */

public enum AuthenticationType implements TokenizableEnum {
    LDAP("L"), SSO("S"), AD("A"), DB("D"), X509("X");

    // constructor by token
    private String _token;
    private AuthenticationType(String _token) {
        this._token = _token;
    }

    // token retrieval
    @Override
    public String getToken() {
        return _token;
    }

    // static factory method.
    public static AuthenticationType factory(String _token) throws EnumException {
        if (_token != null) {
            if (_token.equals("L")) return LDAP;
            if (_token.equals("S")) return SSO;
            if (_token.equals("A")) return AD;
            if (_token.equals("D")) return DB;
            if (_token.equals("X")) return X509;
            throw new EnumException(EnumException.INVALID_NUM, _token);
        }
        return null;
    }

    public static AuthenticationType valueOf(Integer ordinal) throws EnumException {
        if (ordinal != null) {
            switch (ordinal.intValue()) {
            case 0: return LDAP;
            case 1: return SSO;
            case 2: return AD;
            case 3: return DB;
            case 4: return X509;
            default: throw new EnumException(EnumException.INVALID_NUM, ordinal.toString());
            }
        }
        return null;
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/Customization.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Stores the customization for a tenant - head record */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class Customization extends Ref
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 73820531888L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // Ref.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return Ref.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return Ref.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.data.Customization";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.Ref";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$customizationId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "customizationId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 100, 1, null);
    protected static final NumericElementaryDataItem meta$$parentRef = new NumericElementaryDataItem(Visibility.DEFAULT, false, "parentRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$customizationType$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "customizationType$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$customizationType = new EnumDataItem(Visibility.DEFAULT, true, "customizationType", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "CustomizationType", false, "CustomizationType", null);
    protected static final AlphanumericElementaryDataItem meta$$name = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "name", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 80, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(4);
        FieldDefinition [] field$array = new FieldDefinition[4];
        field$array[0] = meta$$customizationId;
        field$array[1] = meta$$parentRef;
        field$array[2] = meta$$customizationType;
        field$array[3] = meta$$name;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 82;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    String customizationId;
    Long parentRef;
    CustomizationType customizationType;
    String name;
    // auto-generated getters and setters
    public String getCustomizationId() {
        return customizationId;
    }
    public void setCustomizationId(String customizationId) {
        this.customizationId = customizationId;
    }
    public Long getParentRef() {
        return parentRef;
    }
    public void setParentRef(Long parentRef) {
        this.parentRef = parentRef;
    }
    public CustomizationType getCustomizationType() {
        return customizationType;
    }
    public void setCustomizationType(CustomizationType customizationType) {
        this.customizationType = customizationType;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$customizationId, customizationId);
        if (parentRef == null) w.writeNull(meta$$parentRef); else w.addField(parentRef);
        w.addField(meta$$customizationType$token, customizationType == null ? null : customizationType.getToken());
        w.addField(meta$$name, name);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("customizationId")) {
            w.addField(meta$$customizationId, customizationId);
            return;
        }
        if (_n.equals("parentRef")) {
            if (parentRef == null) w.writeNull(meta$$parentRef); else w.addField(parentRef);
            return;
        }
        if (_n.equals("customizationType")) {
            w.addField(meta$$customizationType$token, customizationType == null ? null : customizationType.getToken());
            return;
        }
        if (_n.equals("name")) {
            w.addField(meta$$name, name);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        customizationId = p.readString    ("customizationId", false, 100, true, false, false, false);
        parentRef = p.readLong      ("parentRef", true, false);
        try {  // for possible EnumExceptions
        customizationType = com.arvatosystems.fortytwo.base.data.CustomizationType.factory(p.readString("customizationType", false, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        name = p.readString    ("name", false, 80, true, false, false, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (customizationId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "customizationId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (customizationType == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "customizationType", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (name == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "name", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (customizationId != null) {
            if (customizationId.length() > 100)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "customizationId.length=" + customizationId.length() + " > 100",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
            if (customizationId.length() < 1)
                throw new ObjectValidationException(ObjectValidationException.TOO_SHORT,
                                                    "customizationId.length=" + customizationId.length() + " < 1",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (name != null) {
            if (name.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "name.length=" + name.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (customizationId == null ? 0 : customizationId.hashCode());
        _hash = 29 * _hash + (parentRef == null ? 0 : parentRef.hashCode());
        _hash = 29 * _hash + (customizationType == null ? 0 : customizationType.hashCode());
        _hash = 29 * _hash + (name == null ? 0 : name.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Customization))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Customization))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        Customization that = (Customization)_that;
        return super.equalsSub(_that)
        && ((customizationId == null && that.customizationId == null) || (customizationId != null && customizationId.equals(that.customizationId)))
        && ((parentRef == null && that.parentRef == null) || (parentRef != null && parentRef.equals(that.parentRef)))
        && ((customizationType == null && that.customizationType == null) || (customizationType != null && customizationType.equals(that.customizationType)))
        && ((name == null && that.name == null) || (name != null && name.equals(that.name)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        customizationId = _cvt.convert(customizationId, meta$$customizationId);
        name = _cvt.convert(name, meta$$name);
    }
    // default no-argument constructor
    public Customization() {
        super();
    }
    
    // default all-arguments constructor
    public Customization(Long objectRef
    , String customizationId
    , Long parentRef
    , CustomizationType customizationType
    , String name
    ) {
        super(objectRef
        );
        this.customizationId = customizationId;
        this.parentRef = parentRef;
        this.customizationType = customizationType;
        this.name = name;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Customization.class) {
            return (T) new Customization(getObjectRef(), getCustomizationId(), getParentRef(), getCustomizationType(), getName());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/CustomizationType.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import de.jpaw.util.EnumException;
import de.jpaw.enums.TokenizableEnum;

/**
     * The types of customization the system shall support.
     */

public enum CustomizationType implements TokenizableEnum {
    BACKEND("B"), UI_ONLY("U"), REPORTING_ONLY("R");

    // constructor by token
    private String _token;
    private CustomizationType(String _token) {
        this._token = _token;
    }

    // token retrieval
    @Override
    public String getToken() {
        return _token;
    }

    // static factory method.
    public static CustomizationType factory(String _token) throws EnumException {
        if (_token != null) {
            if (_token.equals("B")) return BACKEND;
            if (_token.equals("U")) return UI_ONLY;
            if (_token.equals("R")) return REPORTING_ONLY;
            throw new EnumException(EnumException.INVALID_NUM, _token);
        }
        return null;
    }

    public static CustomizationType valueOf(Integer ordinal) throws EnumException {
        if (ordinal != null) {
            switch (ordinal.intValue()) {
            case 0: return BACKEND;
            case 1: return UI_ONLY;
            case 2: return REPORTING_ONLY;
            default: throw new EnumException(EnumException.INVALID_NUM, ordinal.toString());
            }
        }
        return null;
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/EntityCustomizationEntry.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Stores the customization for a specific entity */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class EntityCustomizationEntry
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -2015960791L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.data.EntityCustomizationEntry";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$customizationRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "customizationRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$rtti = new NumericElementaryDataItem(Visibility.DEFAULT, true, "rtti", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$dataTransferObjClassName = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "dataTransferObjClassName", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 80, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$entityClassName = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "entityClassName", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 80, 0, null);
    protected static final MiscElementaryDataItem meta$$isInherited = new MiscElementaryDataItem(Visibility.DEFAULT, true, "isInherited", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", true);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(5);
        FieldDefinition [] field$array = new FieldDefinition[5];
        field$array[0] = meta$$customizationRef;
        field$array[1] = meta$$rtti;
        field$array[2] = meta$$dataTransferObjClassName;
        field$array[3] = meta$$entityClassName;
        field$array[4] = meta$$isInherited;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // Points to customization head record !
    Long customizationRef;
    // RTTI of the data transfer object !
    Integer rtti;
    // Class name or UI screen name !
    String dataTransferObjClassName;
    // Class name or UI screen name !
    String entityClassName;
    // if inherited, propagate !
    boolean isInherited;
    // auto-generated getters and setters
    public Long getCustomizationRef() {
        return customizationRef;
    }
    public void setCustomizationRef(Long customizationRef) {
        this.customizationRef = customizationRef;
    }
    public Integer getRtti() {
        return rtti;
    }
    public void setRtti(Integer rtti) {
        this.rtti = rtti;
    }
    public String getDataTransferObjClassName() {
        return dataTransferObjClassName;
    }
    public void setDataTransferObjClassName(String dataTransferObjClassName) {
        this.dataTransferObjClassName = dataTransferObjClassName;
    }
    public String getEntityClassName() {
        return entityClassName;
    }
    public void setEntityClassName(String entityClassName) {
        this.entityClassName = entityClassName;
    }
    public boolean getIsInherited() {
        return isInherited;
    }
    public void setIsInherited(boolean isInherited) {
        this.isInherited = isInherited;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        if (customizationRef == null) w.writeNull(meta$$customizationRef); else w.addField(customizationRef);
        if (rtti == null) w.writeNull(meta$$rtti); else w.addField(rtti);
        w.addField(meta$$dataTransferObjClassName, dataTransferObjClassName);
        w.addField(meta$$entityClassName, entityClassName);
        w.addField(isInherited);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("customizationRef")) {
            if (customizationRef == null) w.writeNull(meta$$customizationRef); else w.addField(customizationRef);
            return;
        }
        if (_n.equals("rtti")) {
            if (rtti == null) w.writeNull(meta$$rtti); else w.addField(rtti);
            return;
        }
        if (_n.equals("dataTransferObjClassName")) {
            w.addField(meta$$dataTransferObjClassName, dataTransferObjClassName);
            return;
        }
        if (_n.equals("entityClassName")) {
            w.addField(meta$$entityClassName, entityClassName);
            return;
        }
        if (_n.equals("isInherited")) {
            w.addField(isInherited);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        customizationRef = p.readLong      ("customizationRef", false, false);
        rtti = p.readInteger   ("rtti", false, false);
        dataTransferObjClassName = p.readString    ("dataTransferObjClassName", false, 80, true, false, false, false);
        entityClassName = p.readString    ("entityClassName", false, 80, true, false, false, false);
        isInherited = p.readBoolean   ("isInherited", false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (customizationRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "customizationRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (rtti == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "rtti", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (dataTransferObjClassName == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "dataTransferObjClassName", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (entityClassName == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "entityClassName", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (dataTransferObjClassName != null) {
            if (dataTransferObjClassName.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "dataTransferObjClassName.length=" + dataTransferObjClassName.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (entityClassName != null) {
            if (entityClassName.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "entityClassName.length=" + entityClassName.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (customizationRef == null ? 0 : customizationRef.hashCode());
        _hash = 29 * _hash + (rtti == null ? 0 : rtti.hashCode());
        _hash = 29 * _hash + (dataTransferObjClassName == null ? 0 : dataTransferObjClassName.hashCode());
        _hash = 29 * _hash + (entityClassName == null ? 0 : entityClassName.hashCode());
        _hash = 29 * _hash + (isInherited ? 1231 : 1237);
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof EntityCustomizationEntry))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof EntityCustomizationEntry))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        EntityCustomizationEntry that = (EntityCustomizationEntry)_that;
        return true
        && ((customizationRef == null && that.customizationRef == null) || (customizationRef != null && customizationRef.equals(that.customizationRef)))
        && ((rtti == null && that.rtti == null) || (rtti != null && rtti.equals(that.rtti)))
        && ((dataTransferObjClassName == null && that.dataTransferObjClassName == null) || (dataTransferObjClassName != null && dataTransferObjClassName.equals(that.dataTransferObjClassName)))
        && ((entityClassName == null && that.entityClassName == null) || (entityClassName != null && entityClassName.equals(that.entityClassName)))
        && isInherited == that.isInherited
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        dataTransferObjClassName = _cvt.convert(dataTransferObjClassName, meta$$dataTransferObjClassName);
        entityClassName = _cvt.convert(entityClassName, meta$$entityClassName);
    }
    // default no-argument constructor
    public EntityCustomizationEntry() {
    }
    
    // default all-arguments constructor
    public EntityCustomizationEntry(Long customizationRef
    , Integer rtti
    , String dataTransferObjClassName
    , String entityClassName
    , boolean isInherited
    ) {
        this.customizationRef = customizationRef;
        this.rtti = rtti;
        this.dataTransferObjClassName = dataTransferObjClassName;
        this.entityClassName = entityClassName;
        this.isInherited = isInherited;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == EntityCustomizationEntry.class) {
            return (T) new EntityCustomizationEntry(getCustomizationRef(), getRtti(), getDataTransferObjClassName(), getEntityClassName(), getIsInherited());
        }
        throw new IllegalArgumentException("EntityCustomizationEntry does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/FullTracking.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Tracking data for read/write tables, using pessimistic locking. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class FullTracking extends WriteTracking
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -218780289453L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        map.putIfAbsent("mTechUserId.currentUser", "");
        map.putIfAbsent("mTimestamp.currentTimestamp", "");
        // WriteTracking.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return WriteTracking.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return WriteTracking.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || WriteTracking.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || WriteTracking.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return WriteTracking.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return WriteTracking.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.data.FullTracking";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.WriteTracking";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$mTechUserId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "mTechUserId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 8, 0, null);
    protected static final NumericElementaryDataItem meta$$mAppUserRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "mAppUserRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final TemporalElementaryDataItem meta$$mTimestamp = new TemporalElementaryDataItem(Visibility.DEFAULT, true, "mTimestamp", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    protected static final NumericElementaryDataItem meta$$mProcessRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "mProcessRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(4);
        FieldDefinition [] field$array = new FieldDefinition[4];
        field$array[0] = meta$$mTechUserId;
        field$array[1] = meta$$mAppUserRef;
        field$array[2] = meta$$mTimestamp;
        field$array[3] = meta$$mProcessRef;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // noupdate, noinsert removed, causes problems with H2 unit tests !
    String mTechUserId;
    Long mAppUserRef;
    LocalDateTime mTimestamp;
    Long mProcessRef;
    // auto-generated getters and setters
    public String getMTechUserId() {
        return mTechUserId;
    }
    public String getmTechUserId() {
        return mTechUserId;
    }
    public void setMTechUserId(String mTechUserId) {
        this.mTechUserId = mTechUserId;
    }
    public void setmTechUserId(String mTechUserId) {
        this.mTechUserId = mTechUserId;
    }
    public Long getMAppUserRef() {
        return mAppUserRef;
    }
    public Long getmAppUserRef() {
        return mAppUserRef;
    }
    public void setMAppUserRef(Long mAppUserRef) {
        this.mAppUserRef = mAppUserRef;
    }
    public void setmAppUserRef(Long mAppUserRef) {
        this.mAppUserRef = mAppUserRef;
    }
    public LocalDateTime getMTimestamp() {
        return mTimestamp;
    }
    public LocalDateTime getmTimestamp() {
        return mTimestamp;
    }
    public void setMTimestamp(LocalDateTime mTimestamp) {
        this.mTimestamp = mTimestamp;
    }
    public void setmTimestamp(LocalDateTime mTimestamp) {
        this.mTimestamp = mTimestamp;
    }
    public Long getMProcessRef() {
        return mProcessRef;
    }
    public Long getmProcessRef() {
        return mProcessRef;
    }
    public void setMProcessRef(Long mProcessRef) {
        this.mProcessRef = mProcessRef;
    }
    public void setmProcessRef(Long mProcessRef) {
        this.mProcessRef = mProcessRef;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$mTechUserId, mTechUserId);
        if (mAppUserRef == null) w.writeNull(meta$$mAppUserRef); else w.addField(mAppUserRef);
        w.addField(meta$$mTimestamp, mTimestamp);
        if (mProcessRef == null) w.writeNull(meta$$mProcessRef); else w.addField(mProcessRef);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("mTechUserId")) {
            w.addField(meta$$mTechUserId, mTechUserId);
            return;
        }
        if (_n.equals("mAppUserRef")) {
            if (mAppUserRef == null) w.writeNull(meta$$mAppUserRef); else w.addField(mAppUserRef);
            return;
        }
        if (_n.equals("mTimestamp")) {
            w.addField(meta$$mTimestamp, mTimestamp);
            return;
        }
        if (_n.equals("mProcessRef")) {
            if (mProcessRef == null) w.writeNull(meta$$mProcessRef); else w.addField(mProcessRef);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        mTechUserId = p.readString    ("mTechUserId", false, 8, true, false, false, false);
        mAppUserRef = p.readLong      ("mAppUserRef", false, false);
        mTimestamp = p.readDayTime("mTimestamp", false, false, 0);
        mProcessRef = p.readLong      ("mProcessRef", false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (mTechUserId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "mTechUserId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (mAppUserRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "mAppUserRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (mTimestamp == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "mTimestamp", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (mProcessRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "mProcessRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (mTechUserId != null) {
            if (mTechUserId.length() > 8)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "mTechUserId.length=" + mTechUserId.length() + " > 8",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (mTechUserId == null ? 0 : mTechUserId.hashCode());
        _hash = 29 * _hash + (mAppUserRef == null ? 0 : mAppUserRef.hashCode());
        _hash = 29 * _hash + (mTimestamp == null ? 0 : mTimestamp.hashCode());
        _hash = 29 * _hash + (mProcessRef == null ? 0 : mProcessRef.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof FullTracking))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof FullTracking))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        FullTracking that = (FullTracking)_that;
        return super.equalsSub(_that)
        && ((mTechUserId == null && that.mTechUserId == null) || (mTechUserId != null && mTechUserId.equals(that.mTechUserId)))
        && ((mAppUserRef == null && that.mAppUserRef == null) || (mAppUserRef != null && mAppUserRef.equals(that.mAppUserRef)))
        && ((mTimestamp == null && that.mTimestamp == null) || (mTimestamp != null && mTimestamp.equals(that.mTimestamp)))
        && ((mProcessRef == null && that.mProcessRef == null) || (mProcessRef != null && mProcessRef.equals(that.mProcessRef)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        mTechUserId = _cvt.convert(mTechUserId, meta$$mTechUserId);
    }
    // default no-argument constructor
    public FullTracking() {
        super();
    }
    
    // default all-arguments constructor
    public FullTracking(String cTechUserId
    , Long cAppUserRef
    , LocalDateTime cTimestamp
    , Long cProcessRef
    , String mTechUserId
    , Long mAppUserRef
    , LocalDateTime mTimestamp
    , Long mProcessRef
    ) {
        super(cTechUserId
        , cAppUserRef
        , cTimestamp
        , cProcessRef
        );
        this.mTechUserId = mTechUserId;
        this.mAppUserRef = mAppUserRef;
        this.mTimestamp = mTimestamp;
        this.mProcessRef = mProcessRef;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == FullTracking.class) {
            return (T) new FullTracking(getCTechUserId(), getCAppUserRef(), getCTimestamp(), getCProcessRef(), getMTechUserId(), getMAppUserRef(), getMTimestamp(), getMProcessRef());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/FullTrackingWithActiveColumn.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Tracking data for read/write tables, using pessimistic locking, and an active column (usually masterdata). */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class FullTrackingWithActiveColumn extends FullTracking
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -407031257312L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        map.putIfAbsent("isActive.active", "");
        // FullTracking.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return FullTracking.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return FullTracking.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || FullTracking.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || FullTracking.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return FullTracking.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return FullTracking.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.data.FullTrackingWithActiveColumn";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.FullTracking";
    private static final String BUNDLE = null;
    
    protected static final MiscElementaryDataItem meta$$isActive = new MiscElementaryDataItem(Visibility.DEFAULT, true, "isActive", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", true);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$isActive;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    boolean isActive;
    // auto-generated getters and setters
    public boolean getIsActive() {
        return isActive;
    }
    public void setIsActive(boolean isActive) {
        this.isActive = isActive;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(isActive);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("isActive")) {
            w.addField(isActive);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        isActive = p.readBoolean   ("isActive", false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (isActive ? 1231 : 1237);
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof FullTrackingWithActiveColumn))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof FullTrackingWithActiveColumn))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        FullTrackingWithActiveColumn that = (FullTrackingWithActiveColumn)_that;
        return super.equalsSub(_that)
        && isActive == that.isActive
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public FullTrackingWithActiveColumn() {
        super();
    }
    
    // default all-arguments constructor
    public FullTrackingWithActiveColumn(String cTechUserId
    , Long cAppUserRef
    , LocalDateTime cTimestamp
    , Long cProcessRef
    , String mTechUserId
    , Long mAppUserRef
    , LocalDateTime mTimestamp
    , Long mProcessRef
    , boolean isActive
    ) {
        super(cTechUserId
        , cAppUserRef
        , cTimestamp
        , cProcessRef
        , mTechUserId
        , mAppUserRef
        , mTimestamp
        , mProcessRef
        );
        this.isActive = isActive;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == FullTrackingWithActiveColumn.class) {
            return (T) new FullTrackingWithActiveColumn(getCTechUserId(), getCAppUserRef(), getCTimestamp(), getCProcessRef(), getMTechUserId(), getMAppUserRef(), getMTimestamp(), getMProcessRef(), getIsActive());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/FullTrackingWithActiveColumnAndVersion.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Tracking data for read/write tables, using optimistic locking, and an active column (usually configuration data). */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class FullTrackingWithActiveColumnAndVersion extends FullTrackingWithActiveColumn
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -387243916912L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        map.putIfAbsent("version.version", "");
        // FullTrackingWithActiveColumn.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return FullTrackingWithActiveColumn.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return FullTrackingWithActiveColumn.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || FullTrackingWithActiveColumn.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || FullTrackingWithActiveColumn.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return FullTrackingWithActiveColumn.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return FullTrackingWithActiveColumn.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.data.FullTrackingWithActiveColumnAndVersion";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.FullTrackingWithActiveColumn";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$version = new NumericElementaryDataItem(Visibility.DEFAULT, true, "version", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", true, false, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$version;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    int version;
    // auto-generated getters and setters
    public int getVersion() {
        return version;
    }
    public void setVersion(int version) {
        this.version = version;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(version);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("version")) {
            w.addField(version);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        version = p.readInteger   ("version", false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + version;
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof FullTrackingWithActiveColumnAndVersion))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof FullTrackingWithActiveColumnAndVersion))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        FullTrackingWithActiveColumnAndVersion that = (FullTrackingWithActiveColumnAndVersion)_that;
        return super.equalsSub(_that)
        && version == that.version
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public FullTrackingWithActiveColumnAndVersion() {
        super();
    }
    
    // default all-arguments constructor
    public FullTrackingWithActiveColumnAndVersion(String cTechUserId
    , Long cAppUserRef
    , LocalDateTime cTimestamp
    , Long cProcessRef
    , String mTechUserId
    , Long mAppUserRef
    , LocalDateTime mTimestamp
    , Long mProcessRef
    , boolean isActive
    , int version
    ) {
        super(cTechUserId
        , cAppUserRef
        , cTimestamp
        , cProcessRef
        , mTechUserId
        , mAppUserRef
        , mTimestamp
        , mProcessRef
        , isActive
        );
        this.version = version;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == FullTrackingWithActiveColumnAndVersion.class) {
            return (T) new FullTrackingWithActiveColumnAndVersion(getCTechUserId(), getCAppUserRef(), getCTimestamp(), getCProcessRef(), getMTechUserId(), getMAppUserRef(), getMTimestamp(), getMProcessRef(), getIsActive(), getVersion());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/FullTrackingWithVersion.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Tracking data for read/write tables, using optimistic locking, but no active column (usually transaction data). */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class FullTrackingWithVersion extends FullTracking
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -274976077726L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        map.putIfAbsent("version.version", "");
        // FullTracking.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return FullTracking.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return FullTracking.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || FullTracking.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || FullTracking.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return FullTracking.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return FullTracking.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.data.FullTrackingWithVersion";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.FullTracking";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$version = new NumericElementaryDataItem(Visibility.DEFAULT, true, "version", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", true, false, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$version;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    int version;
    // auto-generated getters and setters
    public int getVersion() {
        return version;
    }
    public void setVersion(int version) {
        this.version = version;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(version);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("version")) {
            w.addField(version);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        version = p.readInteger   ("version", false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + version;
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof FullTrackingWithVersion))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof FullTrackingWithVersion))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        FullTrackingWithVersion that = (FullTrackingWithVersion)_that;
        return super.equalsSub(_that)
        && version == that.version
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public FullTrackingWithVersion() {
        super();
    }
    
    // default all-arguments constructor
    public FullTrackingWithVersion(String cTechUserId
    , Long cAppUserRef
    , LocalDateTime cTimestamp
    , Long cProcessRef
    , String mTechUserId
    , Long mAppUserRef
    , LocalDateTime mTimestamp
    , Long mProcessRef
    , int version
    ) {
        super(cTechUserId
        , cAppUserRef
        , cTimestamp
        , cProcessRef
        , mTechUserId
        , mAppUserRef
        , mTimestamp
        , mProcessRef
        );
        this.version = version;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == FullTrackingWithVersion.class) {
            return (T) new FullTrackingWithVersion(getCTechUserId(), getCAppUserRef(), getCTimestamp(), getCProcessRef(), getMTechUserId(), getMAppUserRef(), getMTimestamp(), getMProcessRef(), getVersion());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/NaturalKeyBase.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Inheritance root object for all DTOs / JPA entities which have a natural key.
     * (A natural key is a key which consists of one or more fields which are assigned values related to business meaning
     * or other object references.)
     */

public abstract class NaturalKeyBase
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 1305994670L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.data.NaturalKeyBase";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(true);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(0);
        FieldDefinition [] field$array = new FieldDefinition[0];
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // auto-generated getters and setters
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof NaturalKeyBase))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof NaturalKeyBase))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        NaturalKeyBase that = (NaturalKeyBase)_that;
        return true
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
    }
    // default no-argument constructor
    public NaturalKeyBase() {
    }
    
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == NaturalKeyBase.class) {
            throw new IllegalArgumentException("NaturalKeyBase is abstract can cannot be supported by copyOf()");
        }
        throw new IllegalArgumentException("NaturalKeyBase does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/NaturalKeyRef.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Inheritance root object for all keys of DTOs / JPA entities which have a natural key.
     * (A natural key is a key which consists of one or more fields which are assigned values related to business meaning
     * or other object references.)
     */

public abstract class NaturalKeyRef
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 2120354326L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.data.NaturalKeyRef";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(true);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(0);
        FieldDefinition [] field$array = new FieldDefinition[0];
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // auto-generated getters and setters
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof NaturalKeyRef))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof NaturalKeyRef))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        NaturalKeyRef that = (NaturalKeyRef)_that;
        return true
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
    }
    // default no-argument constructor
    public NaturalKeyRef() {
    }
    
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == NaturalKeyRef.class) {
            throw new IllegalArgumentException("NaturalKeyRef is abstract can cannot be supported by copyOf()");
        }
        throw new IllegalArgumentException("NaturalKeyRef does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/NoTracking.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Base class for all JPA entity tracking classes. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class NoTracking
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -1217601697L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.data.NoTracking";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(0);
        FieldDefinition [] field$array = new FieldDefinition[0];
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // auto-generated getters and setters
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof NoTracking))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof NoTracking))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        NoTracking that = (NoTracking)_that;
        return true
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
    }
    // default no-argument constructor
    public NoTracking() {
    }
    
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == NoTracking.class) {
            return (T) new NoTracking();
        }
        throw new IllegalArgumentException("NoTracking does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/Password.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class Password extends Ref
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 129448487954L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // Ref.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return Ref.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return Ref.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.data.Password";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.Ref";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$passwordSerialNumber = new NumericElementaryDataItem(Visibility.DEFAULT, true, "passwordSerialNumber", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    protected static final BinaryElementaryDataItem meta$$passwordHash = new BinaryElementaryDataItem(Visibility.DEFAULT, true, "passwordHash", Multiplicity.SCALAR, 0, 0, 0, DataCategory.BINARY,
        "ByteArray", false, 64);
    protected static final TemporalElementaryDataItem meta$$passwordExpiry = new TemporalElementaryDataItem(Visibility.DEFAULT, true, "passwordExpiry", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    protected static final TemporalElementaryDataItem meta$$userExpiry = new TemporalElementaryDataItem(Visibility.DEFAULT, true, "userExpiry", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    protected static final TemporalElementaryDataItem meta$$passwordCreation = new TemporalElementaryDataItem(Visibility.DEFAULT, true, "passwordCreation", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    protected static final NumericElementaryDataItem meta$$passwordSetByUser = new NumericElementaryDataItem(Visibility.DEFAULT, true, "passwordSetByUser", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(6);
        FieldDefinition [] field$array = new FieldDefinition[6];
        field$array[0] = meta$$passwordSerialNumber;
        field$array[1] = meta$$passwordHash;
        field$array[2] = meta$$passwordExpiry;
        field$array[3] = meta$$userExpiry;
        field$array[4] = meta$$passwordCreation;
        field$array[5] = meta$$passwordSetByUser;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 85;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // 1..n for 1st password, ... !
    Integer passwordSerialNumber;
    // salted hash !
    ByteArray passwordHash;
    // when this date is reached, the only allowed action is to renew the password !
    LocalDateTime passwordExpiry;
    // when this date is reached, the user cannot log in any more (but every activity resets it) !
    LocalDateTime userExpiry;
    // when this password was set !
    LocalDateTime passwordCreation;
    // reference of (technical) user who set this password !
    Long passwordSetByUser;
    // auto-generated getters and setters
    public Integer getPasswordSerialNumber() {
        return passwordSerialNumber;
    }
    public void setPasswordSerialNumber(Integer passwordSerialNumber) {
        this.passwordSerialNumber = passwordSerialNumber;
    }
    public ByteArray getPasswordHash() {
        return passwordHash;
    }
    public void setPasswordHash(ByteArray passwordHash) {
        this.passwordHash = passwordHash;
    }
    public LocalDateTime getPasswordExpiry() {
        return passwordExpiry;
    }
    public void setPasswordExpiry(LocalDateTime passwordExpiry) {
        this.passwordExpiry = passwordExpiry;
    }
    public LocalDateTime getUserExpiry() {
        return userExpiry;
    }
    public void setUserExpiry(LocalDateTime userExpiry) {
        this.userExpiry = userExpiry;
    }
    public LocalDateTime getPasswordCreation() {
        return passwordCreation;
    }
    public void setPasswordCreation(LocalDateTime passwordCreation) {
        this.passwordCreation = passwordCreation;
    }
    public Long getPasswordSetByUser() {
        return passwordSetByUser;
    }
    public void setPasswordSetByUser(Long passwordSetByUser) {
        this.passwordSetByUser = passwordSetByUser;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (passwordSerialNumber == null) w.writeNull(meta$$passwordSerialNumber); else w.addField(passwordSerialNumber);
        w.addField(meta$$passwordHash, passwordHash);
        w.addField(meta$$passwordExpiry, passwordExpiry);
        w.addField(meta$$userExpiry, userExpiry);
        w.addField(meta$$passwordCreation, passwordCreation);
        if (passwordSetByUser == null) w.writeNull(meta$$passwordSetByUser); else w.addField(passwordSetByUser);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("passwordSerialNumber")) {
            if (passwordSerialNumber == null) w.writeNull(meta$$passwordSerialNumber); else w.addField(passwordSerialNumber);
            return;
        }
        if (_n.equals("passwordHash")) {
            w.addField(meta$$passwordHash, passwordHash);
            return;
        }
        if (_n.equals("passwordExpiry")) {
            w.addField(meta$$passwordExpiry, passwordExpiry);
            return;
        }
        if (_n.equals("userExpiry")) {
            w.addField(meta$$userExpiry, userExpiry);
            return;
        }
        if (_n.equals("passwordCreation")) {
            w.addField(meta$$passwordCreation, passwordCreation);
            return;
        }
        if (_n.equals("passwordSetByUser")) {
            if (passwordSetByUser == null) w.writeNull(meta$$passwordSetByUser); else w.addField(passwordSetByUser);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        passwordSerialNumber = p.readInteger   ("passwordSerialNumber", false, false);
        passwordHash = p.readByteArray ("passwordHash", false, 64);
        passwordExpiry = p.readDayTime("passwordExpiry", false, false, 0);
        userExpiry = p.readDayTime("userExpiry", false, false, 0);
        passwordCreation = p.readDayTime("passwordCreation", false, false, 0);
        passwordSetByUser = p.readLong      ("passwordSetByUser", false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (passwordSerialNumber == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "passwordSerialNumber", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (passwordHash == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "passwordHash", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (passwordExpiry == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "passwordExpiry", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (userExpiry == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "userExpiry", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (passwordCreation == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "passwordCreation", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (passwordSetByUser == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "passwordSetByUser", PARTIALLY_QUALIFIED_CLASS_NAME);
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (passwordSerialNumber == null ? 0 : passwordSerialNumber.hashCode());
        _hash = 29 * _hash + (passwordHash == null ? 0 : passwordHash.hashCode());
        _hash = 29 * _hash + (passwordExpiry == null ? 0 : passwordExpiry.hashCode());
        _hash = 29 * _hash + (userExpiry == null ? 0 : userExpiry.hashCode());
        _hash = 29 * _hash + (passwordCreation == null ? 0 : passwordCreation.hashCode());
        _hash = 29 * _hash + (passwordSetByUser == null ? 0 : passwordSetByUser.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Password))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Password))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        Password that = (Password)_that;
        return super.equalsSub(_that)
        && ((passwordSerialNumber == null && that.passwordSerialNumber == null) || (passwordSerialNumber != null && passwordSerialNumber.equals(that.passwordSerialNumber)))
        && ((passwordHash == null && that.passwordHash == null) || (passwordHash != null && passwordHash.contentEquals(that.passwordHash)))
        && ((passwordExpiry == null && that.passwordExpiry == null) || (passwordExpiry != null && passwordExpiry.equals(that.passwordExpiry)))
        && ((userExpiry == null && that.userExpiry == null) || (userExpiry != null && userExpiry.equals(that.userExpiry)))
        && ((passwordCreation == null && that.passwordCreation == null) || (passwordCreation != null && passwordCreation.equals(that.passwordCreation)))
        && ((passwordSetByUser == null && that.passwordSetByUser == null) || (passwordSetByUser != null && passwordSetByUser.equals(that.passwordSetByUser)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public Password() {
        super();
    }
    
    // default all-arguments constructor
    public Password(Long objectRef
    , Integer passwordSerialNumber
    , ByteArray passwordHash
    , LocalDateTime passwordExpiry
    , LocalDateTime userExpiry
    , LocalDateTime passwordCreation
    , Long passwordSetByUser
    ) {
        super(objectRef
        );
        this.passwordSerialNumber = passwordSerialNumber;
        this.passwordHash = passwordHash;
        this.passwordExpiry = passwordExpiry;
        this.userExpiry = userExpiry;
        this.passwordCreation = passwordCreation;
        this.passwordSetByUser = passwordSetByUser;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Password.class) {
            return (T) new Password(getObjectRef(), getPasswordSerialNumber(), getPasswordHash(), getPasswordExpiry(), getUserExpiry(), getPasswordCreation(), getPasswordSetByUser());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/Ref.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Inheritance root object for all DTOs / JPA entities which have an artificial key.
     * (An artificial key is a key which is of type Long and is assigned a value from a sequence by the
     * genericRefGenerator.)
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class Ref
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -1962198356L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        map.putIfAbsent("objectRef.noupdate", "");
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.data.Ref";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$objectRef = new NumericElementaryDataItem(Visibility.DEFAULT, false, "objectRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$objectRef;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    @com.arvatosystems.fortytwo.base.NotUpdatable
    Long objectRef;
    // auto-generated getters and setters
    public Long getObjectRef() {
        return objectRef;
    }
    public void setObjectRef(Long objectRef) {
        this.objectRef = objectRef;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        if (objectRef == null) w.writeNull(meta$$objectRef); else w.addField(objectRef);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("objectRef")) {
            if (objectRef == null) w.writeNull(meta$$objectRef); else w.addField(objectRef);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        objectRef = p.readLong      ("objectRef", true, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (objectRef == null ? 0 : objectRef.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Ref))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Ref))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        Ref that = (Ref)_that;
        return true
        && ((objectRef == null && that.objectRef == null) || (objectRef != null && objectRef.equals(that.objectRef)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
    }
    // default no-argument constructor
    public Ref() {
    }
    
    // default all-arguments constructor
    public Ref(Long objectRef
    ) {
        this.objectRef = objectRef;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Ref.class) {
            return (T) new Ref(getObjectRef());
        }
        throw new IllegalArgumentException("Ref does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/RequestHandlerCustomizationEntry.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Stores the mapping between service requests and their appropriate (potentially customized) request handlers */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class RequestHandlerCustomizationEntry
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 692817409L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.data.RequestHandlerCustomizationEntry";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$customizationRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "customizationRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$requestClassName = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "requestClassName", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 80, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$requestHandlerClassName = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "requestHandlerClassName", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 80, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(3);
        FieldDefinition [] field$array = new FieldDefinition[3];
        field$array[0] = meta$$customizationRef;
        field$array[1] = meta$$requestClassName;
        field$array[2] = meta$$requestHandlerClassName;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // Points to customization head record !
    Long customizationRef;
    // Class name or UI screen name !
    String requestClassName;
    // Class name or UI screen name !
    String requestHandlerClassName;
    // auto-generated getters and setters
    public Long getCustomizationRef() {
        return customizationRef;
    }
    public void setCustomizationRef(Long customizationRef) {
        this.customizationRef = customizationRef;
    }
    public String getRequestClassName() {
        return requestClassName;
    }
    public void setRequestClassName(String requestClassName) {
        this.requestClassName = requestClassName;
    }
    public String getRequestHandlerClassName() {
        return requestHandlerClassName;
    }
    public void setRequestHandlerClassName(String requestHandlerClassName) {
        this.requestHandlerClassName = requestHandlerClassName;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        if (customizationRef == null) w.writeNull(meta$$customizationRef); else w.addField(customizationRef);
        w.addField(meta$$requestClassName, requestClassName);
        w.addField(meta$$requestHandlerClassName, requestHandlerClassName);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("customizationRef")) {
            if (customizationRef == null) w.writeNull(meta$$customizationRef); else w.addField(customizationRef);
            return;
        }
        if (_n.equals("requestClassName")) {
            w.addField(meta$$requestClassName, requestClassName);
            return;
        }
        if (_n.equals("requestHandlerClassName")) {
            w.addField(meta$$requestHandlerClassName, requestHandlerClassName);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        customizationRef = p.readLong      ("customizationRef", false, false);
        requestClassName = p.readString    ("requestClassName", false, 80, true, false, false, false);
        requestHandlerClassName = p.readString    ("requestHandlerClassName", false, 80, true, false, false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (customizationRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "customizationRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (requestClassName == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "requestClassName", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (requestHandlerClassName == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "requestHandlerClassName", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (requestClassName != null) {
            if (requestClassName.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "requestClassName.length=" + requestClassName.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (requestHandlerClassName != null) {
            if (requestHandlerClassName.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "requestHandlerClassName.length=" + requestHandlerClassName.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (customizationRef == null ? 0 : customizationRef.hashCode());
        _hash = 29 * _hash + (requestClassName == null ? 0 : requestClassName.hashCode());
        _hash = 29 * _hash + (requestHandlerClassName == null ? 0 : requestHandlerClassName.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof RequestHandlerCustomizationEntry))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof RequestHandlerCustomizationEntry))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        RequestHandlerCustomizationEntry that = (RequestHandlerCustomizationEntry)_that;
        return true
        && ((customizationRef == null && that.customizationRef == null) || (customizationRef != null && customizationRef.equals(that.customizationRef)))
        && ((requestClassName == null && that.requestClassName == null) || (requestClassName != null && requestClassName.equals(that.requestClassName)))
        && ((requestHandlerClassName == null && that.requestHandlerClassName == null) || (requestHandlerClassName != null && requestHandlerClassName.equals(that.requestHandlerClassName)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        requestClassName = _cvt.convert(requestClassName, meta$$requestClassName);
        requestHandlerClassName = _cvt.convert(requestHandlerClassName, meta$$requestHandlerClassName);
    }
    // default no-argument constructor
    public RequestHandlerCustomizationEntry() {
    }
    
    // default all-arguments constructor
    public RequestHandlerCustomizationEntry(Long customizationRef
    , String requestClassName
    , String requestHandlerClassName
    ) {
        this.customizationRef = customizationRef;
        this.requestClassName = requestClassName;
        this.requestHandlerClassName = requestHandlerClassName;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == RequestHandlerCustomizationEntry.class) {
            return (T) new RequestHandlerCustomizationEntry(getCustomizationRef(), getRequestClassName(), getRequestHandlerClassName());
        }
        throw new IllegalArgumentException("RequestHandlerCustomizationEntry does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/Tenant.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class Tenant extends TenantRef
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -156668366683L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        map.putIfAbsent("tenantId.noupdate", "");
        map.putIfAbsent("tenantId.findBy", "");
        // TenantRef.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return TenantRef.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return TenantRef.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || TenantRef.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || TenantRef.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return TenantRef.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return TenantRef.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.data.Tenant";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.TenantRef";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$tenantId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "tenantId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 10, 1, null);
    protected static final AlphanumericElementaryDataItem meta$$name = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "name", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 80, 0, null);
    protected static final NumericElementaryDataItem meta$$customizationRef = new NumericElementaryDataItem(Visibility.DEFAULT, false, "customizationRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$customizationUIRef = new NumericElementaryDataItem(Visibility.DEFAULT, false, "customizationUIRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$customizationRepRef = new NumericElementaryDataItem(Visibility.DEFAULT, false, "customizationRepRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$passwordMinimumLength = new NumericElementaryDataItem(Visibility.DEFAULT, false, "passwordMinimumLength", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$passwordDifferPreviousN = new NumericElementaryDataItem(Visibility.DEFAULT, false, "passwordDifferPreviousN", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$passwordExpirationInDays = new NumericElementaryDataItem(Visibility.DEFAULT, false, "passwordExpirationInDays", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$passwordResetDurationInSec = new NumericElementaryDataItem(Visibility.DEFAULT, false, "passwordResetDurationInSec", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$passwordThrottlingAfterX = new NumericElementaryDataItem(Visibility.DEFAULT, false, "passwordThrottlingAfterX", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$passwordThrottlingDuration = new NumericElementaryDataItem(Visibility.DEFAULT, false, "passwordThrottlingDuration", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$passwordBlockingPeriod = new NumericElementaryDataItem(Visibility.DEFAULT, false, "passwordBlockingPeriod", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(12);
        FieldDefinition [] field$array = new FieldDefinition[12];
        field$array[0] = meta$$tenantId;
        field$array[1] = meta$$name;
        field$array[2] = meta$$customizationRef;
        field$array[3] = meta$$customizationUIRef;
        field$array[4] = meta$$customizationRepRef;
        field$array[5] = meta$$passwordMinimumLength;
        field$array[6] = meta$$passwordDifferPreviousN;
        field$array[7] = meta$$passwordExpirationInDays;
        field$array[8] = meta$$passwordResetDurationInSec;
        field$array[9] = meta$$passwordThrottlingAfterX;
        field$array[10] = meta$$passwordThrottlingDuration;
        field$array[11] = meta$$passwordBlockingPeriod;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // tenant Id in this special case not implicit !
    @com.arvatosystems.fortytwo.base.NotUpdatable
    String tenantId;
    // tenant name !
    String name;
    // null is standard, else points to specific customization !
    Long customizationRef;
    // null is standard, else points to specific customization for UI !
    Long customizationUIRef;
    // null is standard, else points to specific customization for reporting !
    Long customizationRepRef;
    // minimum length for a password in characters (default 10) !
    Integer passwordMinimumLength = 10;
    // from how many previous passwords must this one be different? (default 3) !
    Integer passwordDifferPreviousN = 3;
    // after how many days does a password expired? (0 to disable expiry, 60 is default) !
    Integer passwordExpirationInDays = 60;
    // how long is a reset password valid? Default 86400 (1 day) !
    Integer passwordResetDurationInSec = 86400;
    // after how many incorrect attempts is the access throttled? (default 3) !
    Integer passwordThrottlingAfterX = 3;
    // for how many seconds does the account not accept any login attempt after throttling? (60) !
    Integer passwordThrottlingDuration = 60;
    // Period in days saying how long an old password will be blocked before it can be used again. "0" Disables this feature !
    Integer passwordBlockingPeriod = 0;
    // auto-generated getters and setters
    public String getTenantId() {
        return tenantId;
    }
    public void setTenantId(String tenantId) {
        this.tenantId = tenantId;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Long getCustomizationRef() {
        return customizationRef;
    }
    public void setCustomizationRef(Long customizationRef) {
        this.customizationRef = customizationRef;
    }
    public Long getCustomizationUIRef() {
        return customizationUIRef;
    }
    public void setCustomizationUIRef(Long customizationUIRef) {
        this.customizationUIRef = customizationUIRef;
    }
    public Long getCustomizationRepRef() {
        return customizationRepRef;
    }
    public void setCustomizationRepRef(Long customizationRepRef) {
        this.customizationRepRef = customizationRepRef;
    }
    public Integer getPasswordMinimumLength() {
        return passwordMinimumLength;
    }
    public void setPasswordMinimumLength(Integer passwordMinimumLength) {
        this.passwordMinimumLength = passwordMinimumLength;
    }
    public Integer getPasswordDifferPreviousN() {
        return passwordDifferPreviousN;
    }
    public void setPasswordDifferPreviousN(Integer passwordDifferPreviousN) {
        this.passwordDifferPreviousN = passwordDifferPreviousN;
    }
    public Integer getPasswordExpirationInDays() {
        return passwordExpirationInDays;
    }
    public void setPasswordExpirationInDays(Integer passwordExpirationInDays) {
        this.passwordExpirationInDays = passwordExpirationInDays;
    }
    public Integer getPasswordResetDurationInSec() {
        return passwordResetDurationInSec;
    }
    public void setPasswordResetDurationInSec(Integer passwordResetDurationInSec) {
        this.passwordResetDurationInSec = passwordResetDurationInSec;
    }
    public Integer getPasswordThrottlingAfterX() {
        return passwordThrottlingAfterX;
    }
    public void setPasswordThrottlingAfterX(Integer passwordThrottlingAfterX) {
        this.passwordThrottlingAfterX = passwordThrottlingAfterX;
    }
    public Integer getPasswordThrottlingDuration() {
        return passwordThrottlingDuration;
    }
    public void setPasswordThrottlingDuration(Integer passwordThrottlingDuration) {
        this.passwordThrottlingDuration = passwordThrottlingDuration;
    }
    public Integer getPasswordBlockingPeriod() {
        return passwordBlockingPeriod;
    }
    public void setPasswordBlockingPeriod(Integer passwordBlockingPeriod) {
        this.passwordBlockingPeriod = passwordBlockingPeriod;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$tenantId, tenantId);
        w.addField(meta$$name, name);
        if (customizationRef == null) w.writeNull(meta$$customizationRef); else w.addField(customizationRef);
        if (customizationUIRef == null) w.writeNull(meta$$customizationUIRef); else w.addField(customizationUIRef);
        if (customizationRepRef == null) w.writeNull(meta$$customizationRepRef); else w.addField(customizationRepRef);
        if (passwordMinimumLength == null) w.writeNull(meta$$passwordMinimumLength); else w.addField(passwordMinimumLength);
        if (passwordDifferPreviousN == null) w.writeNull(meta$$passwordDifferPreviousN); else w.addField(passwordDifferPreviousN);
        if (passwordExpirationInDays == null) w.writeNull(meta$$passwordExpirationInDays); else w.addField(passwordExpirationInDays);
        if (passwordResetDurationInSec == null) w.writeNull(meta$$passwordResetDurationInSec); else w.addField(passwordResetDurationInSec);
        if (passwordThrottlingAfterX == null) w.writeNull(meta$$passwordThrottlingAfterX); else w.addField(passwordThrottlingAfterX);
        if (passwordThrottlingDuration == null) w.writeNull(meta$$passwordThrottlingDuration); else w.addField(passwordThrottlingDuration);
        if (passwordBlockingPeriod == null) w.writeNull(meta$$passwordBlockingPeriod); else w.addField(passwordBlockingPeriod);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("tenantId")) {
            w.addField(meta$$tenantId, tenantId);
            return;
        }
        if (_n.equals("name")) {
            w.addField(meta$$name, name);
            return;
        }
        if (_n.equals("customizationRef")) {
            if (customizationRef == null) w.writeNull(meta$$customizationRef); else w.addField(customizationRef);
            return;
        }
        if (_n.equals("customizationUIRef")) {
            if (customizationUIRef == null) w.writeNull(meta$$customizationUIRef); else w.addField(customizationUIRef);
            return;
        }
        if (_n.equals("customizationRepRef")) {
            if (customizationRepRef == null) w.writeNull(meta$$customizationRepRef); else w.addField(customizationRepRef);
            return;
        }
        if (_n.equals("passwordMinimumLength")) {
            if (passwordMinimumLength == null) w.writeNull(meta$$passwordMinimumLength); else w.addField(passwordMinimumLength);
            return;
        }
        if (_n.equals("passwordDifferPreviousN")) {
            if (passwordDifferPreviousN == null) w.writeNull(meta$$passwordDifferPreviousN); else w.addField(passwordDifferPreviousN);
            return;
        }
        if (_n.equals("passwordExpirationInDays")) {
            if (passwordExpirationInDays == null) w.writeNull(meta$$passwordExpirationInDays); else w.addField(passwordExpirationInDays);
            return;
        }
        if (_n.equals("passwordResetDurationInSec")) {
            if (passwordResetDurationInSec == null) w.writeNull(meta$$passwordResetDurationInSec); else w.addField(passwordResetDurationInSec);
            return;
        }
        if (_n.equals("passwordThrottlingAfterX")) {
            if (passwordThrottlingAfterX == null) w.writeNull(meta$$passwordThrottlingAfterX); else w.addField(passwordThrottlingAfterX);
            return;
        }
        if (_n.equals("passwordThrottlingDuration")) {
            if (passwordThrottlingDuration == null) w.writeNull(meta$$passwordThrottlingDuration); else w.addField(passwordThrottlingDuration);
            return;
        }
        if (_n.equals("passwordBlockingPeriod")) {
            if (passwordBlockingPeriod == null) w.writeNull(meta$$passwordBlockingPeriod); else w.addField(passwordBlockingPeriod);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        tenantId = p.readString    ("tenantId", false, 10, true, false, false, false);
        name = p.readString    ("name", false, 80, true, false, false, true);
        customizationRef = p.readLong      ("customizationRef", true, false);
        customizationUIRef = p.readLong      ("customizationUIRef", true, false);
        customizationRepRef = p.readLong      ("customizationRepRef", true, false);
        passwordMinimumLength = p.readInteger   ("passwordMinimumLength", true, false);
        passwordDifferPreviousN = p.readInteger   ("passwordDifferPreviousN", true, false);
        passwordExpirationInDays = p.readInteger   ("passwordExpirationInDays", true, false);
        passwordResetDurationInSec = p.readInteger   ("passwordResetDurationInSec", true, false);
        passwordThrottlingAfterX = p.readInteger   ("passwordThrottlingAfterX", true, false);
        passwordThrottlingDuration = p.readInteger   ("passwordThrottlingDuration", true, false);
        passwordBlockingPeriod = p.readInteger   ("passwordBlockingPeriod", true, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (tenantId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "tenantId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (name == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "name", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (tenantId != null) {
            if (tenantId.length() > 10)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "tenantId.length=" + tenantId.length() + " > 10",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
            if (tenantId.length() < 1)
                throw new ObjectValidationException(ObjectValidationException.TOO_SHORT,
                                                    "tenantId.length=" + tenantId.length() + " < 1",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (name != null) {
            if (name.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "name.length=" + name.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (tenantId == null ? 0 : tenantId.hashCode());
        _hash = 29 * _hash + (name == null ? 0 : name.hashCode());
        _hash = 29 * _hash + (customizationRef == null ? 0 : customizationRef.hashCode());
        _hash = 29 * _hash + (customizationUIRef == null ? 0 : customizationUIRef.hashCode());
        _hash = 29 * _hash + (customizationRepRef == null ? 0 : customizationRepRef.hashCode());
        _hash = 29 * _hash + (passwordMinimumLength == null ? 0 : passwordMinimumLength.hashCode());
        _hash = 29 * _hash + (passwordDifferPreviousN == null ? 0 : passwordDifferPreviousN.hashCode());
        _hash = 29 * _hash + (passwordExpirationInDays == null ? 0 : passwordExpirationInDays.hashCode());
        _hash = 29 * _hash + (passwordResetDurationInSec == null ? 0 : passwordResetDurationInSec.hashCode());
        _hash = 29 * _hash + (passwordThrottlingAfterX == null ? 0 : passwordThrottlingAfterX.hashCode());
        _hash = 29 * _hash + (passwordThrottlingDuration == null ? 0 : passwordThrottlingDuration.hashCode());
        _hash = 29 * _hash + (passwordBlockingPeriod == null ? 0 : passwordBlockingPeriod.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Tenant))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Tenant))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        Tenant that = (Tenant)_that;
        return super.equalsSub(_that)
        && ((tenantId == null && that.tenantId == null) || (tenantId != null && tenantId.equals(that.tenantId)))
        && ((name == null && that.name == null) || (name != null && name.equals(that.name)))
        && ((customizationRef == null && that.customizationRef == null) || (customizationRef != null && customizationRef.equals(that.customizationRef)))
        && ((customizationUIRef == null && that.customizationUIRef == null) || (customizationUIRef != null && customizationUIRef.equals(that.customizationUIRef)))
        && ((customizationRepRef == null && that.customizationRepRef == null) || (customizationRepRef != null && customizationRepRef.equals(that.customizationRepRef)))
        && ((passwordMinimumLength == null && that.passwordMinimumLength == null) || (passwordMinimumLength != null && passwordMinimumLength.equals(that.passwordMinimumLength)))
        && ((passwordDifferPreviousN == null && that.passwordDifferPreviousN == null) || (passwordDifferPreviousN != null && passwordDifferPreviousN.equals(that.passwordDifferPreviousN)))
        && ((passwordExpirationInDays == null && that.passwordExpirationInDays == null) || (passwordExpirationInDays != null && passwordExpirationInDays.equals(that.passwordExpirationInDays)))
        && ((passwordResetDurationInSec == null && that.passwordResetDurationInSec == null) || (passwordResetDurationInSec != null && passwordResetDurationInSec.equals(that.passwordResetDurationInSec)))
        && ((passwordThrottlingAfterX == null && that.passwordThrottlingAfterX == null) || (passwordThrottlingAfterX != null && passwordThrottlingAfterX.equals(that.passwordThrottlingAfterX)))
        && ((passwordThrottlingDuration == null && that.passwordThrottlingDuration == null) || (passwordThrottlingDuration != null && passwordThrottlingDuration.equals(that.passwordThrottlingDuration)))
        && ((passwordBlockingPeriod == null && that.passwordBlockingPeriod == null) || (passwordBlockingPeriod != null && passwordBlockingPeriod.equals(that.passwordBlockingPeriod)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        tenantId = _cvt.convert(tenantId, meta$$tenantId);
        name = _cvt.convert(name, meta$$name);
    }
    // default no-argument constructor
    public Tenant() {
        super();
    }
    
    // default all-arguments constructor
    public Tenant(Long objectRef
    , String tenantId
    , String name
    , Long customizationRef
    , Long customizationUIRef
    , Long customizationRepRef
    , Integer passwordMinimumLength
    , Integer passwordDifferPreviousN
    , Integer passwordExpirationInDays
    , Integer passwordResetDurationInSec
    , Integer passwordThrottlingAfterX
    , Integer passwordThrottlingDuration
    , Integer passwordBlockingPeriod
    ) {
        super(objectRef
        );
        this.tenantId = tenantId;
        this.name = name;
        this.customizationRef = customizationRef;
        this.customizationUIRef = customizationUIRef;
        this.customizationRepRef = customizationRepRef;
        this.passwordMinimumLength = passwordMinimumLength;
        this.passwordDifferPreviousN = passwordDifferPreviousN;
        this.passwordExpirationInDays = passwordExpirationInDays;
        this.passwordResetDurationInSec = passwordResetDurationInSec;
        this.passwordThrottlingAfterX = passwordThrottlingAfterX;
        this.passwordThrottlingDuration = passwordThrottlingDuration;
        this.passwordBlockingPeriod = passwordBlockingPeriod;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Tenant.class) {
            return (T) new Tenant(getObjectRef(), getTenantId(), getName(), getCustomizationRef(), getCustomizationUIRef(), getCustomizationRepRef(), getPasswordMinimumLength(), getPasswordDifferPreviousN(), getPasswordExpirationInDays(), getPasswordResetDurationInSec(), getPasswordThrottlingAfterX(), getPasswordThrottlingDuration(), getPasswordBlockingPeriod());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/TenantKey.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public final class TenantKey extends TenantRef
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 26272281948L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // TenantRef.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return TenantRef.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return TenantRef.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || TenantRef.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || TenantRef.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return TenantRef.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return TenantRef.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.data.TenantKey";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.TenantRef";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$tenantId = new AlphanumericElementaryDataItem(Visibility.PUBLIC, true, "tenantId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 10, 1, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$tenantId;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // tenant Id in this special case not implicit !
    public String tenantId;
    // auto-generated getters and setters
    public String getTenantId() {
        return tenantId;
    }
    public void setTenantId(String tenantId) {
        this.tenantId = tenantId;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$tenantId, tenantId);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("tenantId")) {
            w.addField(meta$$tenantId, tenantId);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        tenantId = p.readString    ("tenantId", false, 10, true, false, false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (tenantId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "tenantId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (tenantId != null) {
            if (tenantId.length() > 10)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "tenantId.length=" + tenantId.length() + " > 10",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
            if (tenantId.length() < 1)
                throw new ObjectValidationException(ObjectValidationException.TOO_SHORT,
                                                    "tenantId.length=" + tenantId.length() + " < 1",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (tenantId == null ? 0 : tenantId.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof TenantKey))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof TenantKey))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        TenantKey that = (TenantKey)_that;
        return super.equalsSub(_that)
        && ((tenantId == null && that.tenantId == null) || (tenantId != null && tenantId.equals(that.tenantId)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        tenantId = _cvt.convert(tenantId, meta$$tenantId);
    }
    // default no-argument constructor
    public TenantKey() {
        super();
    }
    
    // default all-arguments constructor
    public TenantKey(Long objectRef
    , String tenantId
    ) {
        super(objectRef
        );
        this.tenantId = tenantId;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == TenantKey.class) {
            return (T) new TenantKey(getObjectRef(), getTenantId());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/TenantRef.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class TenantRef extends Ref
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 12155481170L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // Ref.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return Ref.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return Ref.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.data.TenantRef";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.Ref";
    private static final String BUNDLE = null;
    
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(0);
        FieldDefinition [] field$array = new FieldDefinition[0];
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 81;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // auto-generated getters and setters
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof TenantRef))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof TenantRef))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        TenantRef that = (TenantRef)_that;
        return super.equalsSub(_that)
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public TenantRef() {
        super();
    }
    
    // default all-arguments constructor
    public TenantRef(Long objectRef
    ) {
        super(objectRef
        );
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == TenantRef.class) {
            return (T) new TenantRef(getObjectRef());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/TranslationDTO.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.annotation.RelatedKey;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
@RelatedKey(com.arvatosystems.fortytwo.base.data.TranslationKey.class)
public class TranslationDTO extends NaturalKeyBase
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 87198455117L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        map.putIfAbsent("targetObjectRef.nochange", "");
        map.putIfAbsent("targetObjectRef.listBy", "");
        map.putIfAbsent("languageCode.nochange", "");
        map.putIfAbsent("tenantRef.nochange", "");
        // NaturalKeyBase.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return NaturalKeyBase.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return NaturalKeyBase.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || NaturalKeyBase.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || NaturalKeyBase.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return NaturalKeyBase.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return com.arvatosystems.fortytwo.base.data.TranslationKey.class;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.data.TranslationDTO";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.NaturalKeyBase";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$targetObjectRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "targetObjectRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$languageCode = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "languageCode", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 16, 0, "[a-z][a-z](_[A-Z][A-Z](_[a-zA-Z0-9#]+)?)?");
    protected static final NumericElementaryDataItem meta$$tenantRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "tenantRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$name = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "name", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 80, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(4);
        FieldDefinition [] field$array = new FieldDefinition[4];
        field$array[0] = meta$$targetObjectRef;
        field$array[1] = meta$$languageCode;
        field$array[2] = meta$$tenantRef;
        field$array[3] = meta$$name;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // 1:1 long key of masterdata or transaction data !
    Long targetObjectRef;
    // language code !
    String languageCode;
    // just for separation purposes, not part of any key !
    Long tenantRef;
    String name;
    // auto-generated getters and setters
    public Long getTargetObjectRef() {
        return targetObjectRef;
    }
    public void setTargetObjectRef(Long targetObjectRef) {
        this.targetObjectRef = targetObjectRef;
    }
    public String getLanguageCode() {
        return languageCode;
    }
    public void setLanguageCode(String languageCode) {
        this.languageCode = languageCode;
    }
    public Long getTenantRef() {
        return tenantRef;
    }
    public void setTenantRef(Long tenantRef) {
        this.tenantRef = tenantRef;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    private static final Pattern regexp$languageCode = Pattern.compile("\\A[a-z][a-z](_[A-Z][A-Z](_[a-zA-Z0-9#]+)?)?\\z");
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (targetObjectRef == null) w.writeNull(meta$$targetObjectRef); else w.addField(targetObjectRef);
        w.addField(meta$$languageCode, languageCode);
        if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
        w.addField(meta$$name, name);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("targetObjectRef")) {
            if (targetObjectRef == null) w.writeNull(meta$$targetObjectRef); else w.addField(targetObjectRef);
            return;
        }
        if (_n.equals("languageCode")) {
            w.addField(meta$$languageCode, languageCode);
            return;
        }
        if (_n.equals("tenantRef")) {
            if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
            return;
        }
        if (_n.equals("name")) {
            w.addField(meta$$name, name);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        targetObjectRef = p.readLong      ("targetObjectRef", false, false);
        languageCode = p.readString    ("languageCode", false, 16, true, false, false, false);
        tenantRef = p.readLong      ("tenantRef", false, false);
        name = p.readString    ("name", true, 80, true, false, false, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (targetObjectRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "targetObjectRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (languageCode == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "languageCode", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (tenantRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "tenantRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (languageCode != null) {
            if (languageCode.length() > 16)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "languageCode.length=" + languageCode.length() + " > 16",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (languageCode != null) {
            Matcher _m =  regexp$languageCode.matcher(languageCode);
            if (!_m.find())
                throw new ObjectValidationException(ObjectValidationException.NO_PATTERN_MATCH,
                                                    "languageCode", PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (name != null) {
            if (name.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "name.length=" + name.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (targetObjectRef == null ? 0 : targetObjectRef.hashCode());
        _hash = 29 * _hash + (languageCode == null ? 0 : languageCode.hashCode());
        _hash = 29 * _hash + (tenantRef == null ? 0 : tenantRef.hashCode());
        _hash = 29 * _hash + (name == null ? 0 : name.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof TranslationDTO))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof TranslationDTO))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        TranslationDTO that = (TranslationDTO)_that;
        return super.equalsSub(_that)
        && ((targetObjectRef == null && that.targetObjectRef == null) || (targetObjectRef != null && targetObjectRef.equals(that.targetObjectRef)))
        && ((languageCode == null && that.languageCode == null) || (languageCode != null && languageCode.equals(that.languageCode)))
        && ((tenantRef == null && that.tenantRef == null) || (tenantRef != null && tenantRef.equals(that.tenantRef)))
        && ((name == null && that.name == null) || (name != null && name.equals(that.name)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        languageCode = _cvt.convert(languageCode, meta$$languageCode);
        name = _cvt.convert(name, meta$$name);
    }
    // default no-argument constructor
    public TranslationDTO() {
        super();
    }
    
    // default all-arguments constructor
    public TranslationDTO(Long targetObjectRef
    , String languageCode
    , Long tenantRef
    , String name
    ) {
        super();
        this.targetObjectRef = targetObjectRef;
        this.languageCode = languageCode;
        this.tenantRef = tenantRef;
        this.name = name;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == TranslationDTO.class) {
            return (T) new TranslationDTO(getTargetObjectRef(), getLanguageCode(), getTenantRef(), getName());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/TranslationKey.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public final class TranslationKey extends NaturalKeyRef
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 88013770549L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // NaturalKeyRef.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return NaturalKeyRef.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return NaturalKeyRef.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || NaturalKeyRef.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || NaturalKeyRef.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return NaturalKeyRef.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return NaturalKeyRef.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.data.TranslationKey";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.NaturalKeyRef";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$targetObjectRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "targetObjectRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$languageCode = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "languageCode", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 16, 0, "[a-z][a-z](_[A-Z][A-Z](_[a-zA-Z0-9#]+)?)?");
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$targetObjectRef;
        field$array[1] = meta$$languageCode;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // 1:1 long key of masterdata or transaction data !
    Long targetObjectRef;
    // language code !
    String languageCode;
    // auto-generated getters and setters
    public Long getTargetObjectRef() {
        return targetObjectRef;
    }
    public void setTargetObjectRef(Long targetObjectRef) {
        this.targetObjectRef = targetObjectRef;
    }
    public String getLanguageCode() {
        return languageCode;
    }
    public void setLanguageCode(String languageCode) {
        this.languageCode = languageCode;
    }
    private static final Pattern regexp$languageCode = Pattern.compile("\\A[a-z][a-z](_[A-Z][A-Z](_[a-zA-Z0-9#]+)?)?\\z");
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (targetObjectRef == null) w.writeNull(meta$$targetObjectRef); else w.addField(targetObjectRef);
        w.addField(meta$$languageCode, languageCode);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("targetObjectRef")) {
            if (targetObjectRef == null) w.writeNull(meta$$targetObjectRef); else w.addField(targetObjectRef);
            return;
        }
        if (_n.equals("languageCode")) {
            w.addField(meta$$languageCode, languageCode);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        targetObjectRef = p.readLong      ("targetObjectRef", false, false);
        languageCode = p.readString    ("languageCode", false, 16, true, false, false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (targetObjectRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "targetObjectRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (languageCode == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "languageCode", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (languageCode != null) {
            if (languageCode.length() > 16)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "languageCode.length=" + languageCode.length() + " > 16",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (languageCode != null) {
            Matcher _m =  regexp$languageCode.matcher(languageCode);
            if (!_m.find())
                throw new ObjectValidationException(ObjectValidationException.NO_PATTERN_MATCH,
                                                    "languageCode", PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (targetObjectRef == null ? 0 : targetObjectRef.hashCode());
        _hash = 29 * _hash + (languageCode == null ? 0 : languageCode.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof TranslationKey))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof TranslationKey))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        TranslationKey that = (TranslationKey)_that;
        return super.equalsSub(_that)
        && ((targetObjectRef == null && that.targetObjectRef == null) || (targetObjectRef != null && targetObjectRef.equals(that.targetObjectRef)))
        && ((languageCode == null && that.languageCode == null) || (languageCode != null && languageCode.equals(that.languageCode)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        languageCode = _cvt.convert(languageCode, meta$$languageCode);
    }
    // default no-argument constructor
    public TranslationKey() {
        super();
    }
    
    // default all-arguments constructor
    public TranslationKey(Long targetObjectRef
    , String languageCode
    ) {
        super();
        this.targetObjectRef = targetObjectRef;
        this.languageCode = languageCode;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == TranslationKey.class) {
            return (T) new TranslationKey(getTargetObjectRef(), getLanguageCode());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/User.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
@com.arvatosystems.fortytwo.base.TenantCategory("G")    
public class User extends UserRef
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -95496275515L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        map.putIfAbsent("tenantCategory", "G");
        map.putIfAbsent("userId.noupdate", "");
        map.putIfAbsent("userId.findBy", "");
        // UserRef.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return UserRef.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return UserRef.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || UserRef.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || UserRef.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return UserRef.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return UserRef.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.data.User";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.UserRef";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$userId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "userId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 16, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$username = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "username", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 255, 0, null);
    protected static final MiscElementaryDataItem meta$$isTechnical = new MiscElementaryDataItem(Visibility.DEFAULT, true, "isTechnical", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", true);
    protected static final AlphanumericElementaryDataItem meta$$tenantId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "tenantId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 10, 1, null);
    protected static final NumericElementaryDataItem meta$$personRef = new NumericElementaryDataItem(Visibility.DEFAULT, false, "personRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$fullName = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "fullName", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 80, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$emailAddress = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "emailAddress", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 255, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$authenticationType$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "authenticationType$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$authenticationType = new EnumDataItem(Visibility.DEFAULT, true, "authenticationType", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "AuthenticationType", false, "AuthenticationType", null);
    protected static final AlphanumericElementaryDataItem meta$$phoneNo = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "phoneNo", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 80, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$commonName = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "commonName", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 255, 0, null);
    protected static final MiscElementaryDataItem meta$$noLogging = new MiscElementaryDataItem(Visibility.DEFAULT, true, "noLogging", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", true);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(11);
        FieldDefinition [] field$array = new FieldDefinition[11];
        field$array[0] = meta$$userId;
        field$array[1] = meta$$username;
        field$array[2] = meta$$isTechnical;
        field$array[3] = meta$$tenantId;
        field$array[4] = meta$$personRef;
        field$array[5] = meta$$fullName;
        field$array[6] = meta$$emailAddress;
        field$array[7] = meta$$authenticationType;
        field$array[8] = meta$$phoneNo;
        field$array[9] = meta$$commonName;
        field$array[10] = meta$$noLogging;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // User id to be used for login !
    @com.arvatosystems.fortytwo.base.NotUpdatable
    String userId;
    // Open id related username !
    String username;
    // true if this is a technical user used for file processing, socket servers etc. !
    boolean isTechnical;
    // not implicit because it could differ from tenant setting (ALL or NONE) !
    String tenantId;
    // if user is a b2c customer (self service login) !
    Long personRef;
    // christian name, surname !
    String fullName;
    // email address of user, if known !
    String emailAddress;
    // specifies the authentication type !
    AuthenticationType authenticationType;
    // phone no !
    String phoneNo;
    // distinguishedName name which must match the one in the SSL certificate, if access via X509 is done !
    String commonName;
    // do not store requests for this user in message_log (for privacy or performance) !
    boolean noLogging;
    // auto-generated getters and setters
    public String getUserId() {
        return userId;
    }
    public void setUserId(String userId) {
        this.userId = userId;
    }
    public String getUsername() {
        return username;
    }
    public void setUsername(String username) {
        this.username = username;
    }
    public boolean getIsTechnical() {
        return isTechnical;
    }
    public void setIsTechnical(boolean isTechnical) {
        this.isTechnical = isTechnical;
    }
    public String getTenantId() {
        return tenantId;
    }
    public void setTenantId(String tenantId) {
        this.tenantId = tenantId;
    }
    public Long getPersonRef() {
        return personRef;
    }
    public void setPersonRef(Long personRef) {
        this.personRef = personRef;
    }
    public String getFullName() {
        return fullName;
    }
    public void setFullName(String fullName) {
        this.fullName = fullName;
    }
    public String getEmailAddress() {
        return emailAddress;
    }
    public void setEmailAddress(String emailAddress) {
        this.emailAddress = emailAddress;
    }
    public AuthenticationType getAuthenticationType() {
        return authenticationType;
    }
    public void setAuthenticationType(AuthenticationType authenticationType) {
        this.authenticationType = authenticationType;
    }
    public String getPhoneNo() {
        return phoneNo;
    }
    public void setPhoneNo(String phoneNo) {
        this.phoneNo = phoneNo;
    }
    public String getCommonName() {
        return commonName;
    }
    public void setCommonName(String commonName) {
        this.commonName = commonName;
    }
    public boolean getNoLogging() {
        return noLogging;
    }
    public void setNoLogging(boolean noLogging) {
        this.noLogging = noLogging;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$userId, userId);
        w.addField(meta$$username, username);
        w.addField(isTechnical);
        w.addField(meta$$tenantId, tenantId);
        if (personRef == null) w.writeNull(meta$$personRef); else w.addField(personRef);
        w.addField(meta$$fullName, fullName);
        w.addField(meta$$emailAddress, emailAddress);
        w.addField(meta$$authenticationType$token, authenticationType == null ? null : authenticationType.getToken());
        w.addField(meta$$phoneNo, phoneNo);
        w.addField(meta$$commonName, commonName);
        w.addField(noLogging);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("userId")) {
            w.addField(meta$$userId, userId);
            return;
        }
        if (_n.equals("username")) {
            w.addField(meta$$username, username);
            return;
        }
        if (_n.equals("isTechnical")) {
            w.addField(isTechnical);
            return;
        }
        if (_n.equals("tenantId")) {
            w.addField(meta$$tenantId, tenantId);
            return;
        }
        if (_n.equals("personRef")) {
            if (personRef == null) w.writeNull(meta$$personRef); else w.addField(personRef);
            return;
        }
        if (_n.equals("fullName")) {
            w.addField(meta$$fullName, fullName);
            return;
        }
        if (_n.equals("emailAddress")) {
            w.addField(meta$$emailAddress, emailAddress);
            return;
        }
        if (_n.equals("authenticationType")) {
            w.addField(meta$$authenticationType$token, authenticationType == null ? null : authenticationType.getToken());
            return;
        }
        if (_n.equals("phoneNo")) {
            w.addField(meta$$phoneNo, phoneNo);
            return;
        }
        if (_n.equals("commonName")) {
            w.addField(meta$$commonName, commonName);
            return;
        }
        if (_n.equals("noLogging")) {
            w.addField(noLogging);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        userId = p.readString    ("userId", false, 16, true, false, false, false);
        username = p.readString    ("username", false, 255, true, false, false, false);
        isTechnical = p.readBoolean   ("isTechnical", false);
        tenantId = p.readString    ("tenantId", false, 10, true, false, false, false);
        personRef = p.readLong      ("personRef", true, false);
        fullName = p.readString    ("fullName", true, 80, true, false, false, true);
        emailAddress = p.readString    ("emailAddress", true, 255, true, false, false, false);
        try {  // for possible EnumExceptions
        authenticationType = com.arvatosystems.fortytwo.base.data.AuthenticationType.factory(p.readString("authenticationType", false, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        phoneNo = p.readString    ("phoneNo", true, 80, true, false, false, true);
        commonName = p.readString    ("commonName", true, 255, true, false, false, true);
        noLogging = p.readBoolean   ("noLogging", false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (userId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "userId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (username == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "username", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (tenantId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "tenantId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (authenticationType == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "authenticationType", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (userId != null) {
            if (userId.length() > 16)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "userId.length=" + userId.length() + " > 16",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (username != null) {
            if (username.length() > 255)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "username.length=" + username.length() + " > 255",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (tenantId != null) {
            if (tenantId.length() > 10)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "tenantId.length=" + tenantId.length() + " > 10",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
            if (tenantId.length() < 1)
                throw new ObjectValidationException(ObjectValidationException.TOO_SHORT,
                                                    "tenantId.length=" + tenantId.length() + " < 1",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (fullName != null) {
            if (fullName.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "fullName.length=" + fullName.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (emailAddress != null) {
            if (emailAddress.length() > 255)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "emailAddress.length=" + emailAddress.length() + " > 255",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (phoneNo != null) {
            if (phoneNo.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "phoneNo.length=" + phoneNo.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (commonName != null) {
            if (commonName.length() > 255)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "commonName.length=" + commonName.length() + " > 255",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (userId == null ? 0 : userId.hashCode());
        _hash = 29 * _hash + (username == null ? 0 : username.hashCode());
        _hash = 29 * _hash + (isTechnical ? 1231 : 1237);
        _hash = 29 * _hash + (tenantId == null ? 0 : tenantId.hashCode());
        _hash = 29 * _hash + (personRef == null ? 0 : personRef.hashCode());
        _hash = 29 * _hash + (fullName == null ? 0 : fullName.hashCode());
        _hash = 29 * _hash + (emailAddress == null ? 0 : emailAddress.hashCode());
        _hash = 29 * _hash + (authenticationType == null ? 0 : authenticationType.hashCode());
        _hash = 29 * _hash + (phoneNo == null ? 0 : phoneNo.hashCode());
        _hash = 29 * _hash + (commonName == null ? 0 : commonName.hashCode());
        _hash = 29 * _hash + (noLogging ? 1231 : 1237);
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof User))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof User))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        User that = (User)_that;
        return super.equalsSub(_that)
        && ((userId == null && that.userId == null) || (userId != null && userId.equals(that.userId)))
        && ((username == null && that.username == null) || (username != null && username.equals(that.username)))
        && isTechnical == that.isTechnical
        && ((tenantId == null && that.tenantId == null) || (tenantId != null && tenantId.equals(that.tenantId)))
        && ((personRef == null && that.personRef == null) || (personRef != null && personRef.equals(that.personRef)))
        && ((fullName == null && that.fullName == null) || (fullName != null && fullName.equals(that.fullName)))
        && ((emailAddress == null && that.emailAddress == null) || (emailAddress != null && emailAddress.equals(that.emailAddress)))
        && ((authenticationType == null && that.authenticationType == null) || (authenticationType != null && authenticationType.equals(that.authenticationType)))
        && ((phoneNo == null && that.phoneNo == null) || (phoneNo != null && phoneNo.equals(that.phoneNo)))
        && ((commonName == null && that.commonName == null) || (commonName != null && commonName.equals(that.commonName)))
        && noLogging == that.noLogging
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        userId = _cvt.convert(userId, meta$$userId);
        username = _cvt.convert(username, meta$$username);
        tenantId = _cvt.convert(tenantId, meta$$tenantId);
        fullName = _cvt.convert(fullName, meta$$fullName);
        emailAddress = _cvt.convert(emailAddress, meta$$emailAddress);
        phoneNo = _cvt.convert(phoneNo, meta$$phoneNo);
        commonName = _cvt.convert(commonName, meta$$commonName);
    }
    // default no-argument constructor
    public User() {
        super();
    }
    
    // default all-arguments constructor
    public User(Long objectRef
    , String userId
    , String username
    , boolean isTechnical
    , String tenantId
    , Long personRef
    , String fullName
    , String emailAddress
    , AuthenticationType authenticationType
    , String phoneNo
    , String commonName
    , boolean noLogging
    ) {
        super(objectRef
        );
        this.userId = userId;
        this.username = username;
        this.isTechnical = isTechnical;
        this.tenantId = tenantId;
        this.personRef = personRef;
        this.fullName = fullName;
        this.emailAddress = emailAddress;
        this.authenticationType = authenticationType;
        this.phoneNo = phoneNo;
        this.commonName = commonName;
        this.noLogging = noLogging;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == User.class) {
            return (T) new User(getObjectRef(), getUserId(), getUsername(), getIsTechnical(), getTenantId(), getPersonRef(), getFullName(), getEmailAddress(), getAuthenticationType(), getPhoneNo(), getCommonName(), getNoLogging());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/UserKey.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public final class UserKey extends UserRef
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -6023188138L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // UserRef.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return UserRef.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return UserRef.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || UserRef.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || UserRef.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return UserRef.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return UserRef.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.data.UserKey";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.UserRef";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$userId = new AlphanumericElementaryDataItem(Visibility.PUBLIC, true, "userId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 16, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$userId;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // User id to be used for login !
    public String userId;
    // auto-generated getters and setters
    public String getUserId() {
        return userId;
    }
    public void setUserId(String userId) {
        this.userId = userId;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$userId, userId);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("userId")) {
            w.addField(meta$$userId, userId);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        userId = p.readString    ("userId", false, 16, true, false, false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (userId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "userId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (userId != null) {
            if (userId.length() > 16)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "userId.length=" + userId.length() + " > 16",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (userId == null ? 0 : userId.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof UserKey))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof UserKey))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        UserKey that = (UserKey)_that;
        return super.equalsSub(_that)
        && ((userId == null && that.userId == null) || (userId != null && userId.equals(that.userId)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        userId = _cvt.convert(userId, meta$$userId);
    }
    // default no-argument constructor
    public UserKey() {
        super();
    }
    
    // default all-arguments constructor
    public UserKey(Long objectRef
    , String userId
    ) {
        super(objectRef
        );
        this.userId = userId;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == UserKey.class) {
            return (T) new UserKey(getObjectRef(), getUserId());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/UserRef.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class UserRef extends Ref
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -3992253873L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // Ref.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return Ref.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return Ref.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.data.UserRef";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.Ref";
    private static final String BUNDLE = null;
    
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(0);
        FieldDefinition [] field$array = new FieldDefinition[0];
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 80;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // auto-generated getters and setters
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof UserRef))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof UserRef))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        UserRef that = (UserRef)_that;
        return super.equalsSub(_that)
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public UserRef() {
        super();
    }
    
    // default all-arguments constructor
    public UserRef(Long objectRef
    ) {
        super(objectRef
        );
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == UserRef.class) {
            return (T) new UserRef(getObjectRef());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/UserStatus.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** 
     * The UserStatus shares the same value for the primary key as the User, the corresponding database table holds data which
     * Updated authentication request handler, added features:
     * is frequently changing and therefore not suitable to keep in the User configuration table. It also does only exist if the
     * user authenticates via the internal password logic, not if a user uses some external SSO or LDAP.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class UserStatus extends Ref
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -271228799272L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // Ref.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return Ref.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return Ref.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.data.UserStatus";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.Ref";
    private static final String BUNDLE = null;
    
    protected static final TemporalElementaryDataItem meta$$lastSuccessfulLogin = new TemporalElementaryDataItem(Visibility.DEFAULT, true, "lastSuccessfulLogin", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    protected static final NumericElementaryDataItem meta$$currentPasswordSerialNumber = new NumericElementaryDataItem(Visibility.DEFAULT, true, "currentPasswordSerialNumber", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$numberOfIncorrectAttempts = new NumericElementaryDataItem(Visibility.DEFAULT, true, "numberOfIncorrectAttempts", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    protected static final TemporalElementaryDataItem meta$$accountThrottledUntil = new TemporalElementaryDataItem(Visibility.DEFAULT, false, "accountThrottledUntil", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(4);
        FieldDefinition [] field$array = new FieldDefinition[4];
        field$array[0] = meta$$lastSuccessfulLogin;
        field$array[1] = meta$$currentPasswordSerialNumber;
        field$array[2] = meta$$numberOfIncorrectAttempts;
        field$array[3] = meta$$accountThrottledUntil;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 88;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // for information to the user !
    LocalDateTime lastSuccessfulLogin;
    // current valid password serial number; allows a single fetch join !
    Integer currentPasswordSerialNumber;
    // for information to the user, also required to configure throttling of retries !
    Integer numberOfIncorrectAttempts;
    // set after n unsuccessful attempts, locks out user for 1 minute. !
    LocalDateTime accountThrottledUntil;
    // auto-generated getters and setters
    public LocalDateTime getLastSuccessfulLogin() {
        return lastSuccessfulLogin;
    }
    public void setLastSuccessfulLogin(LocalDateTime lastSuccessfulLogin) {
        this.lastSuccessfulLogin = lastSuccessfulLogin;
    }
    public Integer getCurrentPasswordSerialNumber() {
        return currentPasswordSerialNumber;
    }
    public void setCurrentPasswordSerialNumber(Integer currentPasswordSerialNumber) {
        this.currentPasswordSerialNumber = currentPasswordSerialNumber;
    }
    public Integer getNumberOfIncorrectAttempts() {
        return numberOfIncorrectAttempts;
    }
    public void setNumberOfIncorrectAttempts(Integer numberOfIncorrectAttempts) {
        this.numberOfIncorrectAttempts = numberOfIncorrectAttempts;
    }
    public LocalDateTime getAccountThrottledUntil() {
        return accountThrottledUntil;
    }
    public void setAccountThrottledUntil(LocalDateTime accountThrottledUntil) {
        this.accountThrottledUntil = accountThrottledUntil;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$lastSuccessfulLogin, lastSuccessfulLogin);
        if (currentPasswordSerialNumber == null) w.writeNull(meta$$currentPasswordSerialNumber); else w.addField(currentPasswordSerialNumber);
        if (numberOfIncorrectAttempts == null) w.writeNull(meta$$numberOfIncorrectAttempts); else w.addField(numberOfIncorrectAttempts);
        w.addField(meta$$accountThrottledUntil, accountThrottledUntil);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("lastSuccessfulLogin")) {
            w.addField(meta$$lastSuccessfulLogin, lastSuccessfulLogin);
            return;
        }
        if (_n.equals("currentPasswordSerialNumber")) {
            if (currentPasswordSerialNumber == null) w.writeNull(meta$$currentPasswordSerialNumber); else w.addField(currentPasswordSerialNumber);
            return;
        }
        if (_n.equals("numberOfIncorrectAttempts")) {
            if (numberOfIncorrectAttempts == null) w.writeNull(meta$$numberOfIncorrectAttempts); else w.addField(numberOfIncorrectAttempts);
            return;
        }
        if (_n.equals("accountThrottledUntil")) {
            w.addField(meta$$accountThrottledUntil, accountThrottledUntil);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        lastSuccessfulLogin = p.readDayTime("lastSuccessfulLogin", false, false, 0);
        currentPasswordSerialNumber = p.readInteger   ("currentPasswordSerialNumber", false, false);
        numberOfIncorrectAttempts = p.readInteger   ("numberOfIncorrectAttempts", false, false);
        accountThrottledUntil = p.readDayTime("accountThrottledUntil", true, false, 0);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (lastSuccessfulLogin == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "lastSuccessfulLogin", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (currentPasswordSerialNumber == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "currentPasswordSerialNumber", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (numberOfIncorrectAttempts == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "numberOfIncorrectAttempts", PARTIALLY_QUALIFIED_CLASS_NAME);
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (lastSuccessfulLogin == null ? 0 : lastSuccessfulLogin.hashCode());
        _hash = 29 * _hash + (currentPasswordSerialNumber == null ? 0 : currentPasswordSerialNumber.hashCode());
        _hash = 29 * _hash + (numberOfIncorrectAttempts == null ? 0 : numberOfIncorrectAttempts.hashCode());
        _hash = 29 * _hash + (accountThrottledUntil == null ? 0 : accountThrottledUntil.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof UserStatus))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof UserStatus))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        UserStatus that = (UserStatus)_that;
        return super.equalsSub(_that)
        && ((lastSuccessfulLogin == null && that.lastSuccessfulLogin == null) || (lastSuccessfulLogin != null && lastSuccessfulLogin.equals(that.lastSuccessfulLogin)))
        && ((currentPasswordSerialNumber == null && that.currentPasswordSerialNumber == null) || (currentPasswordSerialNumber != null && currentPasswordSerialNumber.equals(that.currentPasswordSerialNumber)))
        && ((numberOfIncorrectAttempts == null && that.numberOfIncorrectAttempts == null) || (numberOfIncorrectAttempts != null && numberOfIncorrectAttempts.equals(that.numberOfIncorrectAttempts)))
        && ((accountThrottledUntil == null && that.accountThrottledUntil == null) || (accountThrottledUntil != null && accountThrottledUntil.equals(that.accountThrottledUntil)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public UserStatus() {
        super();
    }
    
    // default all-arguments constructor
    public UserStatus(Long objectRef
    , LocalDateTime lastSuccessfulLogin
    , Integer currentPasswordSerialNumber
    , Integer numberOfIncorrectAttempts
    , LocalDateTime accountThrottledUntil
    ) {
        super(objectRef
        );
        this.lastSuccessfulLogin = lastSuccessfulLogin;
        this.currentPasswordSerialNumber = currentPasswordSerialNumber;
        this.numberOfIncorrectAttempts = numberOfIncorrectAttempts;
        this.accountThrottledUntil = accountThrottledUntil;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == UserStatus.class) {
            return (T) new UserStatus(getObjectRef(), getLastSuccessfulLogin(), getCurrentPasswordSerialNumber(), getNumberOfIncorrectAttempts(), getAccountThrottledUntil());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/WriteTracking.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.data;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Tracking data for write-only tables. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class WriteTracking extends NoTracking
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -215358558580L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        map.putIfAbsent("cTechUserId.noupdate", "");
        map.putIfAbsent("cTechUserId.currentUser", "");
        map.putIfAbsent("cAppUserRef.noupdate", "");
        map.putIfAbsent("cTimestamp.noupdate", "");
        map.putIfAbsent("cTimestamp.currentTimestamp", "");
        map.putIfAbsent("cProcessRef.noupdate", "");
        // NoTracking.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return NoTracking.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return NoTracking.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || NoTracking.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || NoTracking.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return NoTracking.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return NoTracking.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.data.WriteTracking";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.NoTracking";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$cTechUserId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "cTechUserId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 8, 0, null);
    protected static final NumericElementaryDataItem meta$$cAppUserRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "cAppUserRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final TemporalElementaryDataItem meta$$cTimestamp = new TemporalElementaryDataItem(Visibility.DEFAULT, true, "cTimestamp", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    protected static final NumericElementaryDataItem meta$$cProcessRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "cProcessRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(4);
        FieldDefinition [] field$array = new FieldDefinition[4];
        field$array[0] = meta$$cTechUserId;
        field$array[1] = meta$$cAppUserRef;
        field$array[2] = meta$$cTimestamp;
        field$array[3] = meta$$cProcessRef;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // noinsert removed, causes problems with H2 unit tests !
    @com.arvatosystems.fortytwo.base.NotUpdatable
    String cTechUserId;
    @com.arvatosystems.fortytwo.base.NotUpdatable
    Long cAppUserRef;
    // noinsert removed, causes problems with H2 unit tests !
    @com.arvatosystems.fortytwo.base.NotUpdatable
    LocalDateTime cTimestamp;
    @com.arvatosystems.fortytwo.base.NotUpdatable
    Long cProcessRef;
    // auto-generated getters and setters
    public String getCTechUserId() {
        return cTechUserId;
    }
    public String getcTechUserId() {
        return cTechUserId;
    }
    public void setCTechUserId(String cTechUserId) {
        this.cTechUserId = cTechUserId;
    }
    public void setcTechUserId(String cTechUserId) {
        this.cTechUserId = cTechUserId;
    }
    public Long getCAppUserRef() {
        return cAppUserRef;
    }
    public Long getcAppUserRef() {
        return cAppUserRef;
    }
    public void setCAppUserRef(Long cAppUserRef) {
        this.cAppUserRef = cAppUserRef;
    }
    public void setcAppUserRef(Long cAppUserRef) {
        this.cAppUserRef = cAppUserRef;
    }
    public LocalDateTime getCTimestamp() {
        return cTimestamp;
    }
    public LocalDateTime getcTimestamp() {
        return cTimestamp;
    }
    public void setCTimestamp(LocalDateTime cTimestamp) {
        this.cTimestamp = cTimestamp;
    }
    public void setcTimestamp(LocalDateTime cTimestamp) {
        this.cTimestamp = cTimestamp;
    }
    public Long getCProcessRef() {
        return cProcessRef;
    }
    public Long getcProcessRef() {
        return cProcessRef;
    }
    public void setCProcessRef(Long cProcessRef) {
        this.cProcessRef = cProcessRef;
    }
    public void setcProcessRef(Long cProcessRef) {
        this.cProcessRef = cProcessRef;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$cTechUserId, cTechUserId);
        if (cAppUserRef == null) w.writeNull(meta$$cAppUserRef); else w.addField(cAppUserRef);
        w.addField(meta$$cTimestamp, cTimestamp);
        if (cProcessRef == null) w.writeNull(meta$$cProcessRef); else w.addField(cProcessRef);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("cTechUserId")) {
            w.addField(meta$$cTechUserId, cTechUserId);
            return;
        }
        if (_n.equals("cAppUserRef")) {
            if (cAppUserRef == null) w.writeNull(meta$$cAppUserRef); else w.addField(cAppUserRef);
            return;
        }
        if (_n.equals("cTimestamp")) {
            w.addField(meta$$cTimestamp, cTimestamp);
            return;
        }
        if (_n.equals("cProcessRef")) {
            if (cProcessRef == null) w.writeNull(meta$$cProcessRef); else w.addField(cProcessRef);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        cTechUserId = p.readString    ("cTechUserId", false, 8, true, false, false, false);
        cAppUserRef = p.readLong      ("cAppUserRef", false, false);
        cTimestamp = p.readDayTime("cTimestamp", false, false, 0);
        cProcessRef = p.readLong      ("cProcessRef", false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (cTechUserId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "cTechUserId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (cAppUserRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "cAppUserRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (cTimestamp == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "cTimestamp", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (cProcessRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "cProcessRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (cTechUserId != null) {
            if (cTechUserId.length() > 8)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "cTechUserId.length=" + cTechUserId.length() + " > 8",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (cTechUserId == null ? 0 : cTechUserId.hashCode());
        _hash = 29 * _hash + (cAppUserRef == null ? 0 : cAppUserRef.hashCode());
        _hash = 29 * _hash + (cTimestamp == null ? 0 : cTimestamp.hashCode());
        _hash = 29 * _hash + (cProcessRef == null ? 0 : cProcessRef.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof WriteTracking))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof WriteTracking))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        WriteTracking that = (WriteTracking)_that;
        return super.equalsSub(_that)
        && ((cTechUserId == null && that.cTechUserId == null) || (cTechUserId != null && cTechUserId.equals(that.cTechUserId)))
        && ((cAppUserRef == null && that.cAppUserRef == null) || (cAppUserRef != null && cAppUserRef.equals(that.cAppUserRef)))
        && ((cTimestamp == null && that.cTimestamp == null) || (cTimestamp != null && cTimestamp.equals(that.cTimestamp)))
        && ((cProcessRef == null && that.cProcessRef == null) || (cProcessRef != null && cProcessRef.equals(that.cProcessRef)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        cTechUserId = _cvt.convert(cTechUserId, meta$$cTechUserId);
    }
    // default no-argument constructor
    public WriteTracking() {
        super();
    }
    
    // default all-arguments constructor
    public WriteTracking(String cTechUserId
    , Long cAppUserRef
    , LocalDateTime cTimestamp
    , Long cProcessRef
    ) {
        super();
        this.cTechUserId = cTechUserId;
        this.cAppUserRef = cAppUserRef;
        this.cTimestamp = cTimestamp;
        this.cProcessRef = cProcessRef;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == WriteTracking.class) {
            return (T) new WriteTracking(getCTechUserId(), getCAppUserRef(), getCTimestamp(), getCProcessRef());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/data/package-info.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

@XmlJavaTypeAdapters({
    @XmlJavaTypeAdapter(type=LocalDate.class,       value=LocalDateAdapter.class),
    @XmlJavaTypeAdapter(type=LocalTime.class,       value=LocalTimeAdapter.class),
    @XmlJavaTypeAdapter(type=LocalDateTime.class,   value=LocalDateTimeAdapter.class),
    @XmlJavaTypeAdapter(type=ByteArray.class,       value=ByteArrayAdapter.class)
})
package com.arvatosystems.fortytwo.base.data;

import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapters;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import org.joda.time.LocalTime;
import de.jpaw.util.ByteArray;

import de.jpaw.xml.jaxb.ByteArrayAdapter;
import de.jpaw.xml.jaxb.LocalDateAdapter;
import de.jpaw.xml.jaxb.LocalTimeAdapter;
import de.jpaw.xml.jaxb.LocalDateTimeAdapter;
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/input/ImportConfigCrudRequest.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.input;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;
import com.arvatosystems.fortytwo.base.api.types.Crud;
import com.arvatosystems.fortytwo.base.api.RequestParameters;
import com.arvatosystems.fortytwo.app.crud.CrudRequest;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class ImportConfigCrudRequest extends CrudRequest<ImportConfigDto>
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 204992376973L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // CrudRequest.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return CrudRequest.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return CrudRequest.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || CrudRequest.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || CrudRequest.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return CrudRequest.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return CrudRequest.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.input.ImportConfigCrudRequest";
    private static final String REVISION = null;
    private static final String PARENT = "app.crud.CrudRequest";
    private static final String BUNDLE = null;
    
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(0);
        FieldDefinition [] field$array = new FieldDefinition[0];
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // auto-generated getters and setters
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ImportConfigCrudRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ImportConfigCrudRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        ImportConfigCrudRequest that = (ImportConfigCrudRequest)_that;
        return super.equalsSub(_that)
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public ImportConfigCrudRequest() {
        super();
    }
    
    // default all-arguments constructor
    public ImportConfigCrudRequest(Crud crud
    , boolean onlyActive
    , Integer version
    , Long key
    , ImportConfigDto data
    ) {
        super(crud
        , onlyActive
        , version
        , key
        , data
        );
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == ImportConfigCrudRequest.class) {
            return (T) new ImportConfigCrudRequest(getCrud(), getOnlyActive(), getVersion(), getKey(), getData());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/input/ImportConfigDto.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.input;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.TenantRef;
import com.arvatosystems.fortytwo.base.data.Ref;
import com.arvatosystems.fortytwo.base.api.InputCommunicationFormatType;
import com.arvatosystems.fortytwo.base.data.UserRef;
import com.arvatosystems.fortytwo.base.api.InputCommunicationTargetChannelType;


/** DTO for storing import information */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class ImportConfigDto extends ImportRef
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -223159759880L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        map.putIfAbsent("tenantRef.ref", "");
        map.putIfAbsent("userRef.ref", "");
        // ImportRef.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return ImportRef.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return ImportRef.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || ImportRef.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || ImportRef.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return ImportRef.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return ImportRef.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.input.ImportConfigDto";
    private static final String REVISION = null;
    private static final String PARENT = "base.input.ImportRef";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$importConfigId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "importConfigId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 16, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$format$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "format$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$format = new EnumDataItem(Visibility.DEFAULT, false, "format", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "InputCommunicationFormatType", false, "InputCommunicationFormatType", null);
    protected static final AlphanumericElementaryDataItem meta$$inputChannelType$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "inputChannelType$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$inputChannelType = new EnumDataItem(Visibility.DEFAULT, false, "inputChannelType", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "InputCommunicationTargetChannelType", false, "InputCommunicationTargetChannelType", null);
    protected static final MiscElementaryDataItem meta$$camelConfig = new MiscElementaryDataItem(Visibility.DEFAULT, true, "camelConfig", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", true);
    protected static final AlphanumericElementaryDataItem meta$$uri = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "uri", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 250, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$baseClassName = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "baseClassName", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 250, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$importTypeClassName = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "importTypeClassName", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 250, 0, null);
    protected static final MiscElementaryDataItem meta$$split = new MiscElementaryDataItem(Visibility.DEFAULT, true, "split", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", true);
    protected static final ObjectReference meta$$tenantRef = new ObjectReference(Visibility.DEFAULT, false, "tenantRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "TenantRef", false, true, "TenantRef");
    protected static final ObjectReference meta$$userRef = new ObjectReference(Visibility.DEFAULT, false, "userRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "UserRef", false, true, "UserRef");
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(10);
        FieldDefinition [] field$array = new FieldDefinition[10];
        field$array[0] = meta$$importConfigId;
        field$array[1] = meta$$format;
        field$array[2] = meta$$inputChannelType;
        field$array[3] = meta$$camelConfig;
        field$array[4] = meta$$uri;
        field$array[5] = meta$$baseClassName;
        field$array[6] = meta$$importTypeClassName;
        field$array[7] = meta$$split;
        field$array[8] = meta$$tenantRef;
        field$array[9] = meta$$userRef;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // Id for this configuration !
    String importConfigId;
    // Format of the content that is to be imported required if camelConfig = true !
    InputCommunicationFormatType format;
    // Channel that is used for transfer !
    InputCommunicationTargetChannelType inputChannelType;
    // Flag to decide whether this should be a camel route definition or a general configuration !
    boolean camelConfig;
    // URI from where the content should be obtained required if camelConfig = true !
    String uri;
    // Root class for unmarshalling !
    String baseClassName;
    // Class of the concrete type that should be processed as a request !
    String importTypeClassName;
    // allows splitting of files containing multiple requests !
    boolean split;
    // Tenant on which the request should be executed !
    TenantRef tenantRef;
    // User under whom the request should be executed !
    UserRef userRef;
    // auto-generated getters and setters
    public String getImportConfigId() {
        return importConfigId;
    }
    public void setImportConfigId(String importConfigId) {
        this.importConfigId = importConfigId;
    }
    public InputCommunicationFormatType getFormat() {
        return format;
    }
    public void setFormat(InputCommunicationFormatType format) {
        this.format = format;
    }
    public InputCommunicationTargetChannelType getInputChannelType() {
        return inputChannelType;
    }
    public void setInputChannelType(InputCommunicationTargetChannelType inputChannelType) {
        this.inputChannelType = inputChannelType;
    }
    public boolean getCamelConfig() {
        return camelConfig;
    }
    public void setCamelConfig(boolean camelConfig) {
        this.camelConfig = camelConfig;
    }
    public String getUri() {
        return uri;
    }
    public void setUri(String uri) {
        this.uri = uri;
    }
    public String getBaseClassName() {
        return baseClassName;
    }
    public void setBaseClassName(String baseClassName) {
        this.baseClassName = baseClassName;
    }
    public String getImportTypeClassName() {
        return importTypeClassName;
    }
    public void setImportTypeClassName(String importTypeClassName) {
        this.importTypeClassName = importTypeClassName;
    }
    public boolean getSplit() {
        return split;
    }
    public void setSplit(boolean split) {
        this.split = split;
    }
    public TenantRef getTenantRef() {
        return tenantRef;
    }
    public void setTenantRef(TenantRef tenantRef) {
        this.tenantRef = tenantRef;
    }
    public UserRef getUserRef() {
        return userRef;
    }
    public void setUserRef(UserRef userRef) {
        this.userRef = userRef;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$importConfigId, importConfigId);
        w.addField(meta$$format$token, format == null ? null : format.getToken());
        w.addField(meta$$inputChannelType$token, inputChannelType == null ? null : inputChannelType.getToken());
        w.addField(camelConfig);
        w.addField(meta$$uri, uri);
        w.addField(meta$$baseClassName, baseClassName);
        w.addField(meta$$importTypeClassName, importTypeClassName);
        w.addField(split);
        w.addField((BonaPortable)tenantRef);
        w.addField((BonaPortable)userRef);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("importConfigId")) {
            w.addField(meta$$importConfigId, importConfigId);
            return;
        }
        if (_n.equals("format")) {
            w.addField(meta$$format$token, format == null ? null : format.getToken());
            return;
        }
        if (_n.equals("inputChannelType")) {
            w.addField(meta$$inputChannelType$token, inputChannelType == null ? null : inputChannelType.getToken());
            return;
        }
        if (_n.equals("camelConfig")) {
            w.addField(camelConfig);
            return;
        }
        if (_n.equals("uri")) {
            w.addField(meta$$uri, uri);
            return;
        }
        if (_n.equals("baseClassName")) {
            w.addField(meta$$baseClassName, baseClassName);
            return;
        }
        if (_n.equals("importTypeClassName")) {
            w.addField(meta$$importTypeClassName, importTypeClassName);
            return;
        }
        if (_n.equals("split")) {
            w.addField(split);
            return;
        }
        if (_n.equals("tenantRef")) {
            if (tenantRef == null) {
                w.writeNull(meta$$tenantRef);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)tenantRef);             // full / recursive object output
            } else {
                // write a specific subcomponent
                tenantRef.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        if (_n.equals("userRef")) {
            if (userRef == null) {
                w.writeNull(meta$$userRef);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)userRef);             // full / recursive object output
            } else {
                // write a specific subcomponent
                userRef.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        importConfigId = p.readString    ("importConfigId", false, 16, true, false, false, false);
        try {  // for possible EnumExceptions
        format = com.arvatosystems.fortytwo.base.api.InputCommunicationFormatType.factory(p.readString("format", true, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        try {  // for possible EnumExceptions
        inputChannelType = com.arvatosystems.fortytwo.base.api.InputCommunicationTargetChannelType.factory(p.readString("inputChannelType", true, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        camelConfig = p.readBoolean   ("camelConfig", false);
        uri = p.readString    ("uri", true, 250, true, false, false, false);
        baseClassName = p.readString    ("baseClassName", false, 250, true, false, false, false);
        importTypeClassName = p.readString    ("importTypeClassName", false, 250, true, false, false, false);
        split = p.readBoolean   ("split", false);
        tenantRef = (TenantRef)p.readObject("tenantRef", TenantRef.class, true, true);
        userRef = (UserRef)p.readObject("userRef", UserRef.class, true, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (importConfigId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "importConfigId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (baseClassName == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "baseClassName", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (importTypeClassName == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "importTypeClassName", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (tenantRef != null)
            tenantRef.validate();  // check object
        if (userRef != null)
            userRef.validate();  // check object
        if (importConfigId != null) {
            if (importConfigId.length() > 16)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "importConfigId.length=" + importConfigId.length() + " > 16",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (uri != null) {
            if (uri.length() > 250)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "uri.length=" + uri.length() + " > 250",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (baseClassName != null) {
            if (baseClassName.length() > 250)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "baseClassName.length=" + baseClassName.length() + " > 250",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (importTypeClassName != null) {
            if (importTypeClassName.length() > 250)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "importTypeClassName.length=" + importTypeClassName.length() + " > 250",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (importConfigId == null ? 0 : importConfigId.hashCode());
        _hash = 29 * _hash + (format == null ? 0 : format.hashCode());
        _hash = 29 * _hash + (inputChannelType == null ? 0 : inputChannelType.hashCode());
        _hash = 29 * _hash + (camelConfig ? 1231 : 1237);
        _hash = 29 * _hash + (uri == null ? 0 : uri.hashCode());
        _hash = 29 * _hash + (baseClassName == null ? 0 : baseClassName.hashCode());
        _hash = 29 * _hash + (importTypeClassName == null ? 0 : importTypeClassName.hashCode());
        _hash = 29 * _hash + (split ? 1231 : 1237);
        _hash = 29 * _hash + (tenantRef == null ? 0 : tenantRef.hashCode());
        _hash = 29 * _hash + (userRef == null ? 0 : userRef.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ImportConfigDto))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ImportConfigDto))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        ImportConfigDto that = (ImportConfigDto)_that;
        return super.equalsSub(_that)
        && ((importConfigId == null && that.importConfigId == null) || (importConfigId != null && importConfigId.equals(that.importConfigId)))
        && ((format == null && that.format == null) || (format != null && format.equals(that.format)))
        && ((inputChannelType == null && that.inputChannelType == null) || (inputChannelType != null && inputChannelType.equals(that.inputChannelType)))
        && camelConfig == that.camelConfig
        && ((uri == null && that.uri == null) || (uri != null && uri.equals(that.uri)))
        && ((baseClassName == null && that.baseClassName == null) || (baseClassName != null && baseClassName.equals(that.baseClassName)))
        && ((importTypeClassName == null && that.importTypeClassName == null) || (importTypeClassName != null && importTypeClassName.equals(that.importTypeClassName)))
        && split == that.split
        && ((tenantRef == null && that.tenantRef == null) || (tenantRef != null && tenantRef.hasSameContentsAs(that.tenantRef)))
        && ((userRef == null && that.userRef == null) || (userRef != null && userRef.hasSameContentsAs(that.userRef)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        importConfigId = _cvt.convert(importConfigId, meta$$importConfigId);
        uri = _cvt.convert(uri, meta$$uri);
        baseClassName = _cvt.convert(baseClassName, meta$$baseClassName);
        importTypeClassName = _cvt.convert(importTypeClassName, meta$$importTypeClassName);
        if (tenantRef != null)
            tenantRef.treeWalkString(_cvt);
        if (userRef != null)
            userRef.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public ImportConfigDto() {
        super();
    }
    
    // default all-arguments constructor
    public ImportConfigDto(Long objectRef
    , String importConfigId
    , InputCommunicationFormatType format
    , InputCommunicationTargetChannelType inputChannelType
    , boolean camelConfig
    , String uri
    , String baseClassName
    , String importTypeClassName
    , boolean split
    , TenantRef tenantRef
    , UserRef userRef
    ) {
        super(objectRef
        );
        this.importConfigId = importConfigId;
        this.format = format;
        this.inputChannelType = inputChannelType;
        this.camelConfig = camelConfig;
        this.uri = uri;
        this.baseClassName = baseClassName;
        this.importTypeClassName = importTypeClassName;
        this.split = split;
        this.tenantRef = tenantRef;
        this.userRef = userRef;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == ImportConfigDto.class) {
            return (T) new ImportConfigDto(getObjectRef(), getImportConfigId(), getFormat(), getInputChannelType(), getCamelConfig(), getUri(), getBaseClassName(), getImportTypeClassName(), getSplit(), getTenantRef(), getUserRef());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/input/ImportConfigSearchRequest.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.input;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.app.search.SearchFilter;
import com.arvatosystems.fortytwo.app.search.SearchRequest;
import com.arvatosystems.fortytwo.base.api.RequestParameters;
import com.arvatosystems.fortytwo.base.api.OutputSessionParameters;
import com.arvatosystems.fortytwo.app.search.SearchOption;
import com.arvatosystems.fortytwo.app.search.SearchCriteria;
import com.arvatosystems.fortytwo.app.search.SortColumn;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class ImportConfigSearchRequest extends SearchRequest<ImportConfigDto>
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -178352161393L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // SearchRequest.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return SearchRequest.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return SearchRequest.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || SearchRequest.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || SearchRequest.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return SearchRequest.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return SearchRequest.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.input.ImportConfigSearchRequest";
    private static final String REVISION = null;
    private static final String PARENT = "app.search.SearchRequest";
    private static final String BUNDLE = null;
    
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(0);
        FieldDefinition [] field$array = new FieldDefinition[0];
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // auto-generated getters and setters
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ImportConfigSearchRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ImportConfigSearchRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        ImportConfigSearchRequest that = (ImportConfigSearchRequest)_that;
        return super.equalsSub(_that)
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public ImportConfigSearchRequest() {
        super();
    }
    
    // default all-arguments constructor
    public ImportConfigSearchRequest(List<SearchFilter> searchFilters
    , SearchOption searchOption
    , List<SortColumn> sortColumns
    , OutputSessionParameters searchOutputTarget
    ) {
        super(searchFilters
        , searchOption
        , sortColumns
        , searchOutputTarget
        );
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == ImportConfigSearchRequest.class) {
            return (T) new ImportConfigSearchRequest(getSearchFilters(), getSearchOption(), getSortColumns(), getSearchOutputTarget());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/input/ImportKey.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.input;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public final class ImportKey extends ImportRef
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -213294051106L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // ImportRef.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return ImportRef.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return ImportRef.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || ImportRef.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || ImportRef.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return ImportRef.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return ImportRef.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.input.ImportKey";
    private static final String REVISION = null;
    private static final String PARENT = "base.input.ImportRef";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$importConfigId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "importConfigId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 16, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$importConfigId;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // Id for this configuration !
    String importConfigId;
    // auto-generated getters and setters
    public String getImportConfigId() {
        return importConfigId;
    }
    public void setImportConfigId(String importConfigId) {
        this.importConfigId = importConfigId;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$importConfigId, importConfigId);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("importConfigId")) {
            w.addField(meta$$importConfigId, importConfigId);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        importConfigId = p.readString    ("importConfigId", false, 16, true, false, false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (importConfigId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "importConfigId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (importConfigId != null) {
            if (importConfigId.length() > 16)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "importConfigId.length=" + importConfigId.length() + " > 16",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (importConfigId == null ? 0 : importConfigId.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ImportKey))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ImportKey))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        ImportKey that = (ImportKey)_that;
        return super.equalsSub(_that)
        && ((importConfigId == null && that.importConfigId == null) || (importConfigId != null && importConfigId.equals(that.importConfigId)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        importConfigId = _cvt.convert(importConfigId, meta$$importConfigId);
    }
    // default no-argument constructor
    public ImportKey() {
        super();
    }
    
    // default all-arguments constructor
    public ImportKey(Long objectRef
    , String importConfigId
    ) {
        super(objectRef
        );
        this.importConfigId = importConfigId;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == ImportKey.class) {
            return (T) new ImportKey(getObjectRef(), getImportConfigId());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/input/ImportPreConfig.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.input;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;
import com.arvatosystems.fortytwo.base.api.InputCommunicationFormatType;
import com.arvatosystems.fortytwo.base.api.InputCommunicationTargetChannelType;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public final class ImportPreConfig extends ImportRef
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 145280704912L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // ImportRef.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return ImportRef.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return ImportRef.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || ImportRef.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || ImportRef.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return ImportRef.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return ImportRef.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.input.ImportPreConfig";
    private static final String REVISION = null;
    private static final String PARENT = "base.input.ImportRef";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$importConfigId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "importConfigId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 16, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$uri = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "uri", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 250, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$format$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "format$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$format = new EnumDataItem(Visibility.DEFAULT, false, "format", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "InputCommunicationFormatType", false, "InputCommunicationFormatType", null);
    protected static final AlphanumericElementaryDataItem meta$$inputChannelType$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "inputChannelType$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$inputChannelType = new EnumDataItem(Visibility.DEFAULT, false, "inputChannelType", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "InputCommunicationTargetChannelType", false, "InputCommunicationTargetChannelType", null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(4);
        FieldDefinition [] field$array = new FieldDefinition[4];
        field$array[0] = meta$$importConfigId;
        field$array[1] = meta$$uri;
        field$array[2] = meta$$format;
        field$array[3] = meta$$inputChannelType;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // Id for this configuration !
    String importConfigId;
    String uri;
    // Format of the content that is to be imported !
    InputCommunicationFormatType format;
    // Channel that is used for transfer !
    InputCommunicationTargetChannelType inputChannelType;
    // auto-generated getters and setters
    public String getImportConfigId() {
        return importConfigId;
    }
    public void setImportConfigId(String importConfigId) {
        this.importConfigId = importConfigId;
    }
    public String getUri() {
        return uri;
    }
    public void setUri(String uri) {
        this.uri = uri;
    }
    public InputCommunicationFormatType getFormat() {
        return format;
    }
    public void setFormat(InputCommunicationFormatType format) {
        this.format = format;
    }
    public InputCommunicationTargetChannelType getInputChannelType() {
        return inputChannelType;
    }
    public void setInputChannelType(InputCommunicationTargetChannelType inputChannelType) {
        this.inputChannelType = inputChannelType;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$importConfigId, importConfigId);
        w.addField(meta$$uri, uri);
        w.addField(meta$$format$token, format == null ? null : format.getToken());
        w.addField(meta$$inputChannelType$token, inputChannelType == null ? null : inputChannelType.getToken());
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("importConfigId")) {
            w.addField(meta$$importConfigId, importConfigId);
            return;
        }
        if (_n.equals("uri")) {
            w.addField(meta$$uri, uri);
            return;
        }
        if (_n.equals("format")) {
            w.addField(meta$$format$token, format == null ? null : format.getToken());
            return;
        }
        if (_n.equals("inputChannelType")) {
            w.addField(meta$$inputChannelType$token, inputChannelType == null ? null : inputChannelType.getToken());
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        importConfigId = p.readString    ("importConfigId", false, 16, true, false, false, false);
        uri = p.readString    ("uri", false, 250, true, false, false, false);
        try {  // for possible EnumExceptions
        format = com.arvatosystems.fortytwo.base.api.InputCommunicationFormatType.factory(p.readString("format", true, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        try {  // for possible EnumExceptions
        inputChannelType = com.arvatosystems.fortytwo.base.api.InputCommunicationTargetChannelType.factory(p.readString("inputChannelType", true, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (importConfigId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "importConfigId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (uri == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "uri", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (importConfigId != null) {
            if (importConfigId.length() > 16)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "importConfigId.length=" + importConfigId.length() + " > 16",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (uri != null) {
            if (uri.length() > 250)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "uri.length=" + uri.length() + " > 250",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (importConfigId == null ? 0 : importConfigId.hashCode());
        _hash = 29 * _hash + (uri == null ? 0 : uri.hashCode());
        _hash = 29 * _hash + (format == null ? 0 : format.hashCode());
        _hash = 29 * _hash + (inputChannelType == null ? 0 : inputChannelType.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ImportPreConfig))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ImportPreConfig))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        ImportPreConfig that = (ImportPreConfig)_that;
        return super.equalsSub(_that)
        && ((importConfigId == null && that.importConfigId == null) || (importConfigId != null && importConfigId.equals(that.importConfigId)))
        && ((uri == null && that.uri == null) || (uri != null && uri.equals(that.uri)))
        && ((format == null && that.format == null) || (format != null && format.equals(that.format)))
        && ((inputChannelType == null && that.inputChannelType == null) || (inputChannelType != null && inputChannelType.equals(that.inputChannelType)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        importConfigId = _cvt.convert(importConfigId, meta$$importConfigId);
        uri = _cvt.convert(uri, meta$$uri);
    }
    // default no-argument constructor
    public ImportPreConfig() {
        super();
    }
    
    // default all-arguments constructor
    public ImportPreConfig(Long objectRef
    , String importConfigId
    , String uri
    , InputCommunicationFormatType format
    , InputCommunicationTargetChannelType inputChannelType
    ) {
        super(objectRef
        );
        this.importConfigId = importConfigId;
        this.uri = uri;
        this.format = format;
        this.inputChannelType = inputChannelType;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == ImportPreConfig.class) {
            return (T) new ImportPreConfig(getObjectRef(), getImportConfigId(), getUri(), getFormat(), getInputChannelType());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/input/ImportRef.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.input;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class ImportRef extends Ref
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -107627685357L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // Ref.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return Ref.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return Ref.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.input.ImportRef";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.Ref";
    private static final String BUNDLE = null;
    
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(0);
        FieldDefinition [] field$array = new FieldDefinition[0];
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // auto-generated getters and setters
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ImportRef))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ImportRef))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        ImportRef that = (ImportRef)_that;
        return super.equalsSub(_that)
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public ImportRef() {
        super();
    }
    
    // default all-arguments constructor
    public ImportRef(Long objectRef
    ) {
        super(objectRef
        );
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == ImportRef.class) {
            return (T) new ImportRef(getObjectRef());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/input/ImportRequest.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.input;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.api.RequestParameters;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class ImportRequest extends RequestParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 109396648931L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // RequestParameters.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RequestParameters.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RequestParameters.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || RequestParameters.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || RequestParameters.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return RequestParameters.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return RequestParameters.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.input.ImportRequest";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.RequestParameters";
    private static final String BUNDLE = null;
    
    protected static final ObjectReference meta$$importRef = new ObjectReference(Visibility.DEFAULT, true, "importRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "ImportRef", false, true, "ImportRef");
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$importRef;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    ImportRef importRef;
    // auto-generated getters and setters
    public ImportRef getImportRef() {
        return importRef;
    }
    public void setImportRef(ImportRef importRef) {
        this.importRef = importRef;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField((BonaPortable)importRef);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("importRef")) {
            if (importRef == null) {
                w.writeNull(meta$$importRef);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)importRef);             // full / recursive object output
            } else {
                // write a specific subcomponent
                importRef.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        importRef = (ImportRef)p.readObject("importRef", ImportRef.class, false, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (importRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "importRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        importRef.validate();      // check object (!= null checked before)
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (importRef == null ? 0 : importRef.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ImportRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ImportRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        ImportRequest that = (ImportRequest)_that;
        return super.equalsSub(_that)
        && ((importRef == null && that.importRef == null) || (importRef != null && importRef.hasSameContentsAs(that.importRef)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        if (importRef != null)
            importRef.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public ImportRequest() {
        super();
    }
    
    // default all-arguments constructor
    public ImportRequest(ImportRef importRef
    ) {
        super();
        this.importRef = importRef;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == ImportRequest.class) {
            return (T) new ImportRequest(getImportRef());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/input/package-info.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

@XmlJavaTypeAdapters({
    @XmlJavaTypeAdapter(type=LocalDate.class,       value=LocalDateAdapter.class),
    @XmlJavaTypeAdapter(type=LocalTime.class,       value=LocalTimeAdapter.class),
    @XmlJavaTypeAdapter(type=LocalDateTime.class,   value=LocalDateTimeAdapter.class),
    @XmlJavaTypeAdapter(type=ByteArray.class,       value=ByteArrayAdapter.class)
})
package com.arvatosystems.fortytwo.base.input;

import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapters;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import org.joda.time.LocalTime;
import de.jpaw.util.ByteArray;

import de.jpaw.xml.jaxb.ByteArrayAdapter;
import de.jpaw.xml.jaxb.LocalDateAdapter;
import de.jpaw.xml.jaxb.LocalTimeAdapter;
import de.jpaw.xml.jaxb.LocalDateTimeAdapter;
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/messaging/DataSink.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.messaging;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;
import com.arvatosystems.fortytwo.base.api.CommunicationFormatType;
import com.arvatosystems.fortytwo.base.api.CommunicationTargetChannelType;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
@com.arvatosystems.fortytwo.base.TenantCategory("D")    
public class DataSink extends DataSinkRef
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -214975695355L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        map.putIfAbsent("tenantCategory", "D");
        map.putIfAbsent("tenantRef.noupdate", "");
        map.putIfAbsent("dataSinkId.noupdate", "");
        map.putIfAbsent("callbackRef.ref", "");
        // DataSinkRef.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return DataSinkRef.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return DataSinkRef.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || DataSinkRef.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || DataSinkRef.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return DataSinkRef.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return DataSinkRef.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.messaging.DataSink";
    private static final String REVISION = null;
    private static final String PARENT = "base.messaging.DataSinkRef";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$tenantRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "tenantRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$dataSinkId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "dataSinkId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 16, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$commTargetChannelType$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "commTargetChannelType$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$commTargetChannelType = new EnumDataItem(Visibility.DEFAULT, true, "commTargetChannelType", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "CommunicationTargetChannelType", false, "CommunicationTargetChannelType", null);
    protected static final AlphanumericElementaryDataItem meta$$commFormatType$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "commFormatType$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$commFormatType = new EnumDataItem(Visibility.DEFAULT, true, "commFormatType", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "CommunicationFormatType", false, "CommunicationFormatType", null);
    protected static final AlphanumericElementaryDataItem meta$$fileOrQueueNamePattern = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "fileOrQueueNamePattern", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 255, 0, null);
    protected static final MiscElementaryDataItem meta$$compressed = new MiscElementaryDataItem(Visibility.DEFAULT, true, "compressed", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", true);
    protected static final AlphanumericElementaryDataItem meta$$originatorModule = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "originatorModule", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 8, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$preTransformerName = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "preTransformerName", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 20, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$commFormatName = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "commFormatName", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 20, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$camelRoute = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "camelRoute", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 100, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$category$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "category$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$category = new EnumDataItem(Visibility.DEFAULT, true, "category", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "DataSinkCategory", false, "DataSinkCategory", null);
    protected static final ObjectReference meta$$callbackRef = new ObjectReference(Visibility.DEFAULT, false, "callbackRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "RequestHandlerConfigRef", false, true, "RequestHandlerConfigRef");
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(12);
        FieldDefinition [] field$array = new FieldDefinition[12];
        field$array[0] = meta$$tenantRef;
        field$array[1] = meta$$dataSinkId;
        field$array[2] = meta$$commTargetChannelType;
        field$array[3] = meta$$commFormatType;
        field$array[4] = meta$$fileOrQueueNamePattern;
        field$array[5] = meta$$compressed;
        field$array[6] = meta$$originatorModule;
        field$array[7] = meta$$preTransformerName;
        field$array[8] = meta$$commFormatName;
        field$array[9] = meta$$camelRoute;
        field$array[10] = meta$$category;
        field$array[11] = meta$$callbackRef;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // links to ALL_TENANTS or to a specific tenant !
    @com.arvatosystems.fortytwo.base.NotUpdatable
    Long tenantRef;
    // every data output is assigned a name !
    @com.arvatosystems.fortytwo.base.NotUpdatable
    String dataSinkId;
    // defines the type of output for this output !
    CommunicationTargetChannelType commTargetChannelType;
    // defines the format for the output !
    CommunicationFormatType commFormatType;
    // substitutions: DAY/TIME, TENANT, !
    String fileOrQueueNamePattern;
    // if true and the output type is a file, then it should be compressed (gzipped) on the fly !
    boolean compressed;
    // REP, COMM, AROMA etc... !
    String originatorModule;
    // custom pre-transform to transform output data before storing it !
    String preTransformerName;
    // custom communication format name (done through CDI lookup) !
    String commFormatName;
    // camel route for output processing !
    String camelRoute;
    // the type of data sink !
    DataSinkCategory category;
    // the request handler to call for operation results (when an entry is finished or aborted with an error) !
    RequestHandlerConfigRef callbackRef;
    // auto-generated getters and setters
    public Long getTenantRef() {
        return tenantRef;
    }
    public void setTenantRef(Long tenantRef) {
        this.tenantRef = tenantRef;
    }
    public String getDataSinkId() {
        return dataSinkId;
    }
    public void setDataSinkId(String dataSinkId) {
        this.dataSinkId = dataSinkId;
    }
    public CommunicationTargetChannelType getCommTargetChannelType() {
        return commTargetChannelType;
    }
    public void setCommTargetChannelType(CommunicationTargetChannelType commTargetChannelType) {
        this.commTargetChannelType = commTargetChannelType;
    }
    public CommunicationFormatType getCommFormatType() {
        return commFormatType;
    }
    public void setCommFormatType(CommunicationFormatType commFormatType) {
        this.commFormatType = commFormatType;
    }
    public String getFileOrQueueNamePattern() {
        return fileOrQueueNamePattern;
    }
    public void setFileOrQueueNamePattern(String fileOrQueueNamePattern) {
        this.fileOrQueueNamePattern = fileOrQueueNamePattern;
    }
    public boolean getCompressed() {
        return compressed;
    }
    public void setCompressed(boolean compressed) {
        this.compressed = compressed;
    }
    public String getOriginatorModule() {
        return originatorModule;
    }
    public void setOriginatorModule(String originatorModule) {
        this.originatorModule = originatorModule;
    }
    public String getPreTransformerName() {
        return preTransformerName;
    }
    public void setPreTransformerName(String preTransformerName) {
        this.preTransformerName = preTransformerName;
    }
    public String getCommFormatName() {
        return commFormatName;
    }
    public void setCommFormatName(String commFormatName) {
        this.commFormatName = commFormatName;
    }
    public String getCamelRoute() {
        return camelRoute;
    }
    public void setCamelRoute(String camelRoute) {
        this.camelRoute = camelRoute;
    }
    public DataSinkCategory getCategory() {
        return category;
    }
    public void setCategory(DataSinkCategory category) {
        this.category = category;
    }
    public RequestHandlerConfigRef getCallbackRef() {
        return callbackRef;
    }
    public void setCallbackRef(RequestHandlerConfigRef callbackRef) {
        this.callbackRef = callbackRef;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
        w.addField(meta$$dataSinkId, dataSinkId);
        w.addField(meta$$commTargetChannelType$token, commTargetChannelType == null ? null : commTargetChannelType.getToken());
        w.addField(meta$$commFormatType$token, commFormatType == null ? null : commFormatType.getToken());
        w.addField(meta$$fileOrQueueNamePattern, fileOrQueueNamePattern);
        w.addField(compressed);
        w.addField(meta$$originatorModule, originatorModule);
        w.addField(meta$$preTransformerName, preTransformerName);
        w.addField(meta$$commFormatName, commFormatName);
        w.addField(meta$$camelRoute, camelRoute);
        w.addField(meta$$category$token, category == null ? null : category.getToken());
        w.addField((BonaPortable)callbackRef);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("tenantRef")) {
            if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
            return;
        }
        if (_n.equals("dataSinkId")) {
            w.addField(meta$$dataSinkId, dataSinkId);
            return;
        }
        if (_n.equals("commTargetChannelType")) {
            w.addField(meta$$commTargetChannelType$token, commTargetChannelType == null ? null : commTargetChannelType.getToken());
            return;
        }
        if (_n.equals("commFormatType")) {
            w.addField(meta$$commFormatType$token, commFormatType == null ? null : commFormatType.getToken());
            return;
        }
        if (_n.equals("fileOrQueueNamePattern")) {
            w.addField(meta$$fileOrQueueNamePattern, fileOrQueueNamePattern);
            return;
        }
        if (_n.equals("compressed")) {
            w.addField(compressed);
            return;
        }
        if (_n.equals("originatorModule")) {
            w.addField(meta$$originatorModule, originatorModule);
            return;
        }
        if (_n.equals("preTransformerName")) {
            w.addField(meta$$preTransformerName, preTransformerName);
            return;
        }
        if (_n.equals("commFormatName")) {
            w.addField(meta$$commFormatName, commFormatName);
            return;
        }
        if (_n.equals("camelRoute")) {
            w.addField(meta$$camelRoute, camelRoute);
            return;
        }
        if (_n.equals("category")) {
            w.addField(meta$$category$token, category == null ? null : category.getToken());
            return;
        }
        if (_n.equals("callbackRef")) {
            if (callbackRef == null) {
                w.writeNull(meta$$callbackRef);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)callbackRef);             // full / recursive object output
            } else {
                // write a specific subcomponent
                callbackRef.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        tenantRef = p.readLong      ("tenantRef", false, false);
        dataSinkId = p.readString    ("dataSinkId", false, 16, true, false, false, false);
        try {  // for possible EnumExceptions
        commTargetChannelType = com.arvatosystems.fortytwo.base.api.CommunicationTargetChannelType.factory(p.readString("commTargetChannelType", false, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        try {  // for possible EnumExceptions
        commFormatType = com.arvatosystems.fortytwo.base.api.CommunicationFormatType.factory(p.readString("commFormatType", false, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        fileOrQueueNamePattern = p.readString    ("fileOrQueueNamePattern", false, 255, true, false, false, false);
        compressed = p.readBoolean   ("compressed", false);
        originatorModule = p.readString    ("originatorModule", true, 8, true, false, false, false);
        preTransformerName = p.readString    ("preTransformerName", true, 20, true, false, false, true);
        commFormatName = p.readString    ("commFormatName", true, 20, true, false, false, true);
        camelRoute = p.readString    ("camelRoute", true, 100, true, false, false, true);
        try {  // for possible EnumExceptions
        category = com.arvatosystems.fortytwo.base.messaging.DataSinkCategory.factory(p.readString("category", false, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        callbackRef = (RequestHandlerConfigRef)p.readObject("callbackRef", RequestHandlerConfigRef.class, true, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (tenantRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "tenantRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (dataSinkId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "dataSinkId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (commTargetChannelType == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "commTargetChannelType", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (commFormatType == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "commFormatType", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (fileOrQueueNamePattern == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "fileOrQueueNamePattern", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (category == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "category", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (callbackRef != null)
            callbackRef.validate();  // check object
        if (dataSinkId != null) {
            if (dataSinkId.length() > 16)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "dataSinkId.length=" + dataSinkId.length() + " > 16",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (fileOrQueueNamePattern != null) {
            if (fileOrQueueNamePattern.length() > 255)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "fileOrQueueNamePattern.length=" + fileOrQueueNamePattern.length() + " > 255",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (originatorModule != null) {
            if (originatorModule.length() > 8)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "originatorModule.length=" + originatorModule.length() + " > 8",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (preTransformerName != null) {
            if (preTransformerName.length() > 20)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "preTransformerName.length=" + preTransformerName.length() + " > 20",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (commFormatName != null) {
            if (commFormatName.length() > 20)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "commFormatName.length=" + commFormatName.length() + " > 20",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (camelRoute != null) {
            if (camelRoute.length() > 100)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "camelRoute.length=" + camelRoute.length() + " > 100",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (tenantRef == null ? 0 : tenantRef.hashCode());
        _hash = 29 * _hash + (dataSinkId == null ? 0 : dataSinkId.hashCode());
        _hash = 29 * _hash + (commTargetChannelType == null ? 0 : commTargetChannelType.hashCode());
        _hash = 29 * _hash + (commFormatType == null ? 0 : commFormatType.hashCode());
        _hash = 29 * _hash + (fileOrQueueNamePattern == null ? 0 : fileOrQueueNamePattern.hashCode());
        _hash = 29 * _hash + (compressed ? 1231 : 1237);
        _hash = 29 * _hash + (originatorModule == null ? 0 : originatorModule.hashCode());
        _hash = 29 * _hash + (preTransformerName == null ? 0 : preTransformerName.hashCode());
        _hash = 29 * _hash + (commFormatName == null ? 0 : commFormatName.hashCode());
        _hash = 29 * _hash + (camelRoute == null ? 0 : camelRoute.hashCode());
        _hash = 29 * _hash + (category == null ? 0 : category.hashCode());
        _hash = 29 * _hash + (callbackRef == null ? 0 : callbackRef.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof DataSink))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof DataSink))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        DataSink that = (DataSink)_that;
        return super.equalsSub(_that)
        && ((tenantRef == null && that.tenantRef == null) || (tenantRef != null && tenantRef.equals(that.tenantRef)))
        && ((dataSinkId == null && that.dataSinkId == null) || (dataSinkId != null && dataSinkId.equals(that.dataSinkId)))
        && ((commTargetChannelType == null && that.commTargetChannelType == null) || (commTargetChannelType != null && commTargetChannelType.equals(that.commTargetChannelType)))
        && ((commFormatType == null && that.commFormatType == null) || (commFormatType != null && commFormatType.equals(that.commFormatType)))
        && ((fileOrQueueNamePattern == null && that.fileOrQueueNamePattern == null) || (fileOrQueueNamePattern != null && fileOrQueueNamePattern.equals(that.fileOrQueueNamePattern)))
        && compressed == that.compressed
        && ((originatorModule == null && that.originatorModule == null) || (originatorModule != null && originatorModule.equals(that.originatorModule)))
        && ((preTransformerName == null && that.preTransformerName == null) || (preTransformerName != null && preTransformerName.equals(that.preTransformerName)))
        && ((commFormatName == null && that.commFormatName == null) || (commFormatName != null && commFormatName.equals(that.commFormatName)))
        && ((camelRoute == null && that.camelRoute == null) || (camelRoute != null && camelRoute.equals(that.camelRoute)))
        && ((category == null && that.category == null) || (category != null && category.equals(that.category)))
        && ((callbackRef == null && that.callbackRef == null) || (callbackRef != null && callbackRef.hasSameContentsAs(that.callbackRef)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        dataSinkId = _cvt.convert(dataSinkId, meta$$dataSinkId);
        fileOrQueueNamePattern = _cvt.convert(fileOrQueueNamePattern, meta$$fileOrQueueNamePattern);
        originatorModule = _cvt.convert(originatorModule, meta$$originatorModule);
        preTransformerName = _cvt.convert(preTransformerName, meta$$preTransformerName);
        commFormatName = _cvt.convert(commFormatName, meta$$commFormatName);
        camelRoute = _cvt.convert(camelRoute, meta$$camelRoute);
        if (callbackRef != null)
            callbackRef.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public DataSink() {
        super();
    }
    
    // default all-arguments constructor
    public DataSink(Long objectRef
    , Long tenantRef
    , String dataSinkId
    , CommunicationTargetChannelType commTargetChannelType
    , CommunicationFormatType commFormatType
    , String fileOrQueueNamePattern
    , boolean compressed
    , String originatorModule
    , String preTransformerName
    , String commFormatName
    , String camelRoute
    , DataSinkCategory category
    , RequestHandlerConfigRef callbackRef
    ) {
        super(objectRef
        );
        this.tenantRef = tenantRef;
        this.dataSinkId = dataSinkId;
        this.commTargetChannelType = commTargetChannelType;
        this.commFormatType = commFormatType;
        this.fileOrQueueNamePattern = fileOrQueueNamePattern;
        this.compressed = compressed;
        this.originatorModule = originatorModule;
        this.preTransformerName = preTransformerName;
        this.commFormatName = commFormatName;
        this.camelRoute = camelRoute;
        this.category = category;
        this.callbackRef = callbackRef;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == DataSink.class) {
            return (T) new DataSink(getObjectRef(), getTenantRef(), getDataSinkId(), getCommTargetChannelType(), getCommFormatType(), getFileOrQueueNamePattern(), getCompressed(), getOriginatorModule(), getPreTransformerName(), getCommFormatName(), getCamelRoute(), getCategory(), getCallbackRef());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/messaging/DataSinkCategory.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.messaging;

import de.jpaw.util.EnumException;
import de.jpaw.enums.TokenizableEnum;

/** Defines the principal type of a data sink. */

public enum DataSinkCategory implements TokenizableEnum {
    DATA_EXPORT("E"), REPORT("R"), CUSTOMER_COMMUNICATION("C"), MASTER_DATA("M"), USER_DATA("U");

    // constructor by token
    private String _token;
    private DataSinkCategory(String _token) {
        this._token = _token;
    }

    // token retrieval
    @Override
    public String getToken() {
        return _token;
    }

    // static factory method.
    public static DataSinkCategory factory(String _token) throws EnumException {
        if (_token != null) {
            if (_token.equals("E")) return DATA_EXPORT;
            if (_token.equals("R")) return REPORT;
            if (_token.equals("C")) return CUSTOMER_COMMUNICATION;
            if (_token.equals("M")) return MASTER_DATA;
            if (_token.equals("U")) return USER_DATA;
            throw new EnumException(EnumException.INVALID_NUM, _token);
        }
        return null;
    }

    public static DataSinkCategory valueOf(Integer ordinal) throws EnumException {
        if (ordinal != null) {
            switch (ordinal.intValue()) {
            case 0: return DATA_EXPORT;
            case 1: return REPORT;
            case 2: return CUSTOMER_COMMUNICATION;
            case 3: return MASTER_DATA;
            case 4: return USER_DATA;
            default: throw new EnumException(EnumException.INVALID_NUM, ordinal.toString());
            }
        }
        return null;
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/messaging/DataSinkFilterProps.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.messaging;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;
import com.arvatosystems.fortytwo.base.api.CommunicationFormatType;
import com.arvatosystems.fortytwo.base.api.CommunicationTargetChannelType;


/** Class with useful properties, returned in the sink DTO, to allow filtering and display. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public final class DataSinkFilterProps extends DataSinkRef
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -8333991851L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // DataSinkRef.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return DataSinkRef.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return DataSinkRef.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || DataSinkRef.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || DataSinkRef.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return DataSinkRef.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return DataSinkRef.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.messaging.DataSinkFilterProps";
    private static final String REVISION = null;
    private static final String PARENT = "base.messaging.DataSinkRef";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$tenantRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "tenantRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$dataSinkId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "dataSinkId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 16, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$commTargetChannelType$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "commTargetChannelType$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$commTargetChannelType = new EnumDataItem(Visibility.DEFAULT, true, "commTargetChannelType", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "CommunicationTargetChannelType", false, "CommunicationTargetChannelType", null);
    protected static final AlphanumericElementaryDataItem meta$$commFormatType$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "commFormatType$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$commFormatType = new EnumDataItem(Visibility.DEFAULT, true, "commFormatType", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "CommunicationFormatType", false, "CommunicationFormatType", null);
    protected static final AlphanumericElementaryDataItem meta$$category$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "category$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$category = new EnumDataItem(Visibility.DEFAULT, true, "category", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "DataSinkCategory", false, "DataSinkCategory", null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(5);
        FieldDefinition [] field$array = new FieldDefinition[5];
        field$array[0] = meta$$tenantRef;
        field$array[1] = meta$$dataSinkId;
        field$array[2] = meta$$commTargetChannelType;
        field$array[3] = meta$$commFormatType;
        field$array[4] = meta$$category;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // links to ALL_TENANTS or to a specific tenant !
    Long tenantRef;
    // every data output is assigned a name !
    String dataSinkId;
    // defines the type of output for this output !
    CommunicationTargetChannelType commTargetChannelType;
    // defines the format for the output !
    CommunicationFormatType commFormatType;
    // the type of data sink !
    DataSinkCategory category;
    // auto-generated getters and setters
    public Long getTenantRef() {
        return tenantRef;
    }
    public void setTenantRef(Long tenantRef) {
        this.tenantRef = tenantRef;
    }
    public String getDataSinkId() {
        return dataSinkId;
    }
    public void setDataSinkId(String dataSinkId) {
        this.dataSinkId = dataSinkId;
    }
    public CommunicationTargetChannelType getCommTargetChannelType() {
        return commTargetChannelType;
    }
    public void setCommTargetChannelType(CommunicationTargetChannelType commTargetChannelType) {
        this.commTargetChannelType = commTargetChannelType;
    }
    public CommunicationFormatType getCommFormatType() {
        return commFormatType;
    }
    public void setCommFormatType(CommunicationFormatType commFormatType) {
        this.commFormatType = commFormatType;
    }
    public DataSinkCategory getCategory() {
        return category;
    }
    public void setCategory(DataSinkCategory category) {
        this.category = category;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
        w.addField(meta$$dataSinkId, dataSinkId);
        w.addField(meta$$commTargetChannelType$token, commTargetChannelType == null ? null : commTargetChannelType.getToken());
        w.addField(meta$$commFormatType$token, commFormatType == null ? null : commFormatType.getToken());
        w.addField(meta$$category$token, category == null ? null : category.getToken());
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("tenantRef")) {
            if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
            return;
        }
        if (_n.equals("dataSinkId")) {
            w.addField(meta$$dataSinkId, dataSinkId);
            return;
        }
        if (_n.equals("commTargetChannelType")) {
            w.addField(meta$$commTargetChannelType$token, commTargetChannelType == null ? null : commTargetChannelType.getToken());
            return;
        }
        if (_n.equals("commFormatType")) {
            w.addField(meta$$commFormatType$token, commFormatType == null ? null : commFormatType.getToken());
            return;
        }
        if (_n.equals("category")) {
            w.addField(meta$$category$token, category == null ? null : category.getToken());
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        tenantRef = p.readLong      ("tenantRef", false, false);
        dataSinkId = p.readString    ("dataSinkId", false, 16, true, false, false, false);
        try {  // for possible EnumExceptions
        commTargetChannelType = com.arvatosystems.fortytwo.base.api.CommunicationTargetChannelType.factory(p.readString("commTargetChannelType", false, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        try {  // for possible EnumExceptions
        commFormatType = com.arvatosystems.fortytwo.base.api.CommunicationFormatType.factory(p.readString("commFormatType", false, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        try {  // for possible EnumExceptions
        category = com.arvatosystems.fortytwo.base.messaging.DataSinkCategory.factory(p.readString("category", false, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (tenantRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "tenantRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (dataSinkId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "dataSinkId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (commTargetChannelType == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "commTargetChannelType", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (commFormatType == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "commFormatType", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (category == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "category", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (dataSinkId != null) {
            if (dataSinkId.length() > 16)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "dataSinkId.length=" + dataSinkId.length() + " > 16",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (tenantRef == null ? 0 : tenantRef.hashCode());
        _hash = 29 * _hash + (dataSinkId == null ? 0 : dataSinkId.hashCode());
        _hash = 29 * _hash + (commTargetChannelType == null ? 0 : commTargetChannelType.hashCode());
        _hash = 29 * _hash + (commFormatType == null ? 0 : commFormatType.hashCode());
        _hash = 29 * _hash + (category == null ? 0 : category.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof DataSinkFilterProps))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof DataSinkFilterProps))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        DataSinkFilterProps that = (DataSinkFilterProps)_that;
        return super.equalsSub(_that)
        && ((tenantRef == null && that.tenantRef == null) || (tenantRef != null && tenantRef.equals(that.tenantRef)))
        && ((dataSinkId == null && that.dataSinkId == null) || (dataSinkId != null && dataSinkId.equals(that.dataSinkId)))
        && ((commTargetChannelType == null && that.commTargetChannelType == null) || (commTargetChannelType != null && commTargetChannelType.equals(that.commTargetChannelType)))
        && ((commFormatType == null && that.commFormatType == null) || (commFormatType != null && commFormatType.equals(that.commFormatType)))
        && ((category == null && that.category == null) || (category != null && category.equals(that.category)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        dataSinkId = _cvt.convert(dataSinkId, meta$$dataSinkId);
    }
    // default no-argument constructor
    public DataSinkFilterProps() {
        super();
    }
    
    // default all-arguments constructor
    public DataSinkFilterProps(Long objectRef
    , Long tenantRef
    , String dataSinkId
    , CommunicationTargetChannelType commTargetChannelType
    , CommunicationFormatType commFormatType
    , DataSinkCategory category
    ) {
        super(objectRef
        );
        this.tenantRef = tenantRef;
        this.dataSinkId = dataSinkId;
        this.commTargetChannelType = commTargetChannelType;
        this.commFormatType = commFormatType;
        this.category = category;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == DataSinkFilterProps.class) {
            return (T) new DataSinkFilterProps(getObjectRef(), getTenantRef(), getDataSinkId(), getCommTargetChannelType(), getCommFormatType(), getCategory());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/messaging/DataSinkKey.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.messaging;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public final class DataSinkKey extends DataSinkRef
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -11623151510L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // DataSinkRef.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return DataSinkRef.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return DataSinkRef.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || DataSinkRef.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || DataSinkRef.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return DataSinkRef.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return DataSinkRef.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.messaging.DataSinkKey";
    private static final String REVISION = null;
    private static final String PARENT = "base.messaging.DataSinkRef";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$tenantRef = new NumericElementaryDataItem(Visibility.PUBLIC, true, "tenantRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$dataSinkId = new AlphanumericElementaryDataItem(Visibility.PUBLIC, true, "dataSinkId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 16, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$tenantRef;
        field$array[1] = meta$$dataSinkId;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // links to ALL_TENANTS or to a specific tenant !
    public Long tenantRef;
    // every data output is assigned a name !
    public String dataSinkId;
    // auto-generated getters and setters
    public Long getTenantRef() {
        return tenantRef;
    }
    public void setTenantRef(Long tenantRef) {
        this.tenantRef = tenantRef;
    }
    public String getDataSinkId() {
        return dataSinkId;
    }
    public void setDataSinkId(String dataSinkId) {
        this.dataSinkId = dataSinkId;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
        w.addField(meta$$dataSinkId, dataSinkId);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("tenantRef")) {
            if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
            return;
        }
        if (_n.equals("dataSinkId")) {
            w.addField(meta$$dataSinkId, dataSinkId);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        tenantRef = p.readLong      ("tenantRef", false, false);
        dataSinkId = p.readString    ("dataSinkId", false, 16, true, false, false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (tenantRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "tenantRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (dataSinkId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "dataSinkId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (dataSinkId != null) {
            if (dataSinkId.length() > 16)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "dataSinkId.length=" + dataSinkId.length() + " > 16",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (tenantRef == null ? 0 : tenantRef.hashCode());
        _hash = 29 * _hash + (dataSinkId == null ? 0 : dataSinkId.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof DataSinkKey))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof DataSinkKey))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        DataSinkKey that = (DataSinkKey)_that;
        return super.equalsSub(_that)
        && ((tenantRef == null && that.tenantRef == null) || (tenantRef != null && tenantRef.equals(that.tenantRef)))
        && ((dataSinkId == null && that.dataSinkId == null) || (dataSinkId != null && dataSinkId.equals(that.dataSinkId)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        dataSinkId = _cvt.convert(dataSinkId, meta$$dataSinkId);
    }
    // default no-argument constructor
    public DataSinkKey() {
        super();
    }
    
    // default all-arguments constructor
    public DataSinkKey(Long objectRef
    , Long tenantRef
    , String dataSinkId
    ) {
        super(objectRef
        );
        this.tenantRef = tenantRef;
        this.dataSinkId = dataSinkId;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == DataSinkKey.class) {
            return (T) new DataSinkKey(getObjectRef(), getTenantRef(), getDataSinkId());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/messaging/DataSinkRef.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.messaging;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;


/** Configuration table for data targets. This is used to determine the actual values used for outputs (as stored in Sinks).
     * The fileOrQueueNamePattern will be expanded, variables may be embedded using the ${name} pattern. Values can be provided as part
     * of a map provided to the open() parameters, and in addition some default expansions are always available. These include
     * tenantId, userId, fileExt, asOf, planDate, today.
     * 
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class DataSinkRef extends Ref
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -6792235559L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // Ref.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return Ref.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return Ref.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.messaging.DataSinkRef";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.Ref";
    private static final String BUNDLE = null;
    
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(0);
        FieldDefinition [] field$array = new FieldDefinition[0];
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 19;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // auto-generated getters and setters
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof DataSinkRef))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof DataSinkRef))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        DataSinkRef that = (DataSinkRef)_that;
        return super.equalsSub(_that)
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public DataSinkRef() {
        super();
    }
    
    // default all-arguments constructor
    public DataSinkRef(Long objectRef
    ) {
        super(objectRef
        );
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == DataSinkRef.class) {
            return (T) new DataSinkRef(getObjectRef());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/messaging/DemoRecord.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.messaging;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/** Test data record which is used for output tests. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class DemoRecord
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -942191525L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.messaging.DemoRecord";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$recordNo = new NumericElementaryDataItem(Visibility.DEFAULT, true, "recordNo", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", true, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$minusPi = new NumericElementaryDataItem(Visibility.DEFAULT, true, "minusPi", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "BigDecimal", false, false, 5, 2, false, false);
    protected static final AlphanumericElementaryDataItem meta$$hello = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "hello", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 20, 0, null);
    protected static final TemporalElementaryDataItem meta$$today = new TemporalElementaryDataItem(Visibility.DEFAULT, true, "today", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDate", false, 0, false);
    protected static final TemporalElementaryDataItem meta$$now = new TemporalElementaryDataItem(Visibility.DEFAULT, true, "now", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    protected static final AlphanumericElementaryDataItem meta$$none = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "none", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 10, 0, null);
    protected static final MiscElementaryDataItem meta$$yes = new MiscElementaryDataItem(Visibility.DEFAULT, true, "yes", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", true);
    protected static final MiscElementaryDataItem meta$$no = new MiscElementaryDataItem(Visibility.DEFAULT, true, "no", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", true);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(8);
        FieldDefinition [] field$array = new FieldDefinition[8];
        field$array[0] = meta$$recordNo;
        field$array[1] = meta$$minusPi;
        field$array[2] = meta$$hello;
        field$array[3] = meta$$today;
        field$array[4] = meta$$now;
        field$array[5] = meta$$none;
        field$array[6] = meta$$yes;
        field$array[7] = meta$$no;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    int recordNo;
    BigDecimal minusPi;
    String hello;
    LocalDate today;
    LocalDateTime now;
    String none;
    boolean yes;
    boolean no;
    // auto-generated getters and setters
    public int getRecordNo() {
        return recordNo;
    }
    public void setRecordNo(int recordNo) {
        this.recordNo = recordNo;
    }
    public BigDecimal getMinusPi() {
        return minusPi;
    }
    public void setMinusPi(BigDecimal minusPi) {
        this.minusPi = minusPi;
    }
    public String getHello() {
        return hello;
    }
    public void setHello(String hello) {
        this.hello = hello;
    }
    public LocalDate getToday() {
        return today;
    }
    public void setToday(LocalDate today) {
        this.today = today;
    }
    public LocalDateTime getNow() {
        return now;
    }
    public void setNow(LocalDateTime now) {
        this.now = now;
    }
    public String getNone() {
        return none;
    }
    public void setNone(String none) {
        this.none = none;
    }
    public boolean getYes() {
        return yes;
    }
    public void setYes(boolean yes) {
        this.yes = yes;
    }
    public boolean getNo() {
        return no;
    }
    public void setNo(boolean no) {
        this.no = no;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(recordNo);
        w.addField(meta$$minusPi, minusPi);
        w.addField(meta$$hello, hello);
        w.addField(meta$$today, today);
        w.addField(meta$$now, now);
        w.addField(meta$$none, none);
        w.addField(yes);
        w.addField(no);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("recordNo")) {
            w.addField(recordNo);
            return;
        }
        if (_n.equals("minusPi")) {
            w.addField(meta$$minusPi, minusPi);
            return;
        }
        if (_n.equals("hello")) {
            w.addField(meta$$hello, hello);
            return;
        }
        if (_n.equals("today")) {
            w.addField(meta$$today, today);
            return;
        }
        if (_n.equals("now")) {
            w.addField(meta$$now, now);
            return;
        }
        if (_n.equals("none")) {
            w.addField(meta$$none, none);
            return;
        }
        if (_n.equals("yes")) {
            w.addField(yes);
            return;
        }
        if (_n.equals("no")) {
            w.addField(no);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        recordNo = p.readInteger   ("recordNo", false, false);
        minusPi = p.readBigDecimal("minusPi", false, 5, 2, false, false, false);
        hello = p.readString    ("hello", false, 20, true, false, false, true);
        today = p.readDay("today", false);
        now = p.readDayTime("now", false, false, 0);
        none = p.readString    ("none", true, 10, true, false, false, false);
        yes = p.readBoolean   ("yes", false);
        no = p.readBoolean   ("no", false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (minusPi == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "minusPi", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (hello == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "hello", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (today == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "today", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (now == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "now", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (hello != null) {
            if (hello.length() > 20)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "hello.length=" + hello.length() + " > 20",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (none != null) {
            if (none.length() > 10)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "none.length=" + none.length() + " > 10",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + recordNo;
        _hash = 29 * _hash + BigDecimalTools.hashCode(minusPi, 2);
        _hash = 29 * _hash + (hello == null ? 0 : hello.hashCode());
        _hash = 29 * _hash + (today == null ? 0 : today.hashCode());
        _hash = 29 * _hash + (now == null ? 0 : now.hashCode());
        _hash = 29 * _hash + (none == null ? 0 : none.hashCode());
        _hash = 29 * _hash + (yes ? 1231 : 1237);
        _hash = 29 * _hash + (no ? 1231 : 1237);
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof DemoRecord))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof DemoRecord))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        DemoRecord that = (DemoRecord)_that;
        return true
        && recordNo == that.recordNo
        && ((minusPi == null && that.minusPi == null) || (minusPi != null && BigDecimalTools.equals(minusPi, 2, that.minusPi, 2)))
        && ((hello == null && that.hello == null) || (hello != null && hello.equals(that.hello)))
        && ((today == null && that.today == null) || (today != null && today.equals(that.today)))
        && ((now == null && that.now == null) || (now != null && now.equals(that.now)))
        && ((none == null && that.none == null) || (none != null && none.equals(that.none)))
        && yes == that.yes
        && no == that.no
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        hello = _cvt.convert(hello, meta$$hello);
        none = _cvt.convert(none, meta$$none);
    }
    // default no-argument constructor
    public DemoRecord() {
    }
    
    // default all-arguments constructor
    public DemoRecord(int recordNo
    , BigDecimal minusPi
    , String hello
    , LocalDate today
    , LocalDateTime now
    , String none
    , boolean yes
    , boolean no
    ) {
        this.recordNo = recordNo;
        this.minusPi = minusPi;
        this.hello = hello;
        this.today = today;
        this.now = now;
        this.none = none;
        this.yes = yes;
        this.no = no;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == DemoRecord.class) {
            return (T) new DemoRecord(getRecordNo(), getMinusPi(), getHello(), getToday(), getNow(), getNone(), getYes(), getNo());
        }
        throw new IllegalArgumentException("DemoRecord does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/messaging/DocumentCreatedCallbackRequest.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.messaging;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.api.CommunicationFormatType;
import com.arvatosystems.fortytwo.base.api.RequestParameters;


/** RequestHandlerConfigDTO entries of type DOCUMENT_CREATED_CALLBACK must refer to jobParameters
     * extending this class.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class DocumentCreatedCallbackRequest extends RequestParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -219732530604L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // RequestParameters.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RequestParameters.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RequestParameters.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || RequestParameters.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || RequestParameters.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return RequestParameters.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return RequestParameters.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.messaging.DocumentCreatedCallbackRequest";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.RequestParameters";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$communicationFormatType$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "communicationFormatType$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$communicationFormatType = new EnumDataItem(Visibility.DEFAULT, false, "communicationFormatType", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "CommunicationFormatType", false, "CommunicationFormatType", null);
    protected static final NumericElementaryDataItem meta$$sinkRef = new NumericElementaryDataItem(Visibility.DEFAULT, false, "sinkRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$originatorRef = new NumericElementaryDataItem(Visibility.DEFAULT, false, "originatorRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$configurationRef = new NumericElementaryDataItem(Visibility.DEFAULT, false, "configurationRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$returnCode = new NumericElementaryDataItem(Visibility.DEFAULT, false, "returnCode", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$returnDetails = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "returnDetails", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 80, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(6);
        FieldDefinition [] field$array = new FieldDefinition[6];
        field$array[0] = meta$$communicationFormatType;
        field$array[1] = meta$$sinkRef;
        field$array[2] = meta$$originatorRef;
        field$array[3] = meta$$configurationRef;
        field$array[4] = meta$$returnCode;
        field$array[5] = meta$$returnDetails;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // can be used to specify output, unless defined in configuration !
    CommunicationFormatType communicationFormatType;
    // for successful responses, reference to the Sink record !
    Long sinkRef;
    // optional link to object which is representing this file (params ref) (predox ref) (as in Sinks table) !
    Long originatorRef;
    // a reference to the configuration/source of the originator (aroma ref) (as in Sinks table) !
    Long configurationRef;
    // null if no returncode provided, 0 if no error, else implementation specific code !
    Integer returnCode;
    // some more textual information !
    String returnDetails;
    // auto-generated getters and setters
    public CommunicationFormatType getCommunicationFormatType() {
        return communicationFormatType;
    }
    public void setCommunicationFormatType(CommunicationFormatType communicationFormatType) {
        this.communicationFormatType = communicationFormatType;
    }
    public Long getSinkRef() {
        return sinkRef;
    }
    public void setSinkRef(Long sinkRef) {
        this.sinkRef = sinkRef;
    }
    public Long getOriginatorRef() {
        return originatorRef;
    }
    public void setOriginatorRef(Long originatorRef) {
        this.originatorRef = originatorRef;
    }
    public Long getConfigurationRef() {
        return configurationRef;
    }
    public void setConfigurationRef(Long configurationRef) {
        this.configurationRef = configurationRef;
    }
    public Integer getReturnCode() {
        return returnCode;
    }
    public void setReturnCode(Integer returnCode) {
        this.returnCode = returnCode;
    }
    public String getReturnDetails() {
        return returnDetails;
    }
    public void setReturnDetails(String returnDetails) {
        this.returnDetails = returnDetails;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$communicationFormatType$token, communicationFormatType == null ? null : communicationFormatType.getToken());
        if (sinkRef == null) w.writeNull(meta$$sinkRef); else w.addField(sinkRef);
        if (originatorRef == null) w.writeNull(meta$$originatorRef); else w.addField(originatorRef);
        if (configurationRef == null) w.writeNull(meta$$configurationRef); else w.addField(configurationRef);
        if (returnCode == null) w.writeNull(meta$$returnCode); else w.addField(returnCode);
        w.addField(meta$$returnDetails, returnDetails);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("communicationFormatType")) {
            w.addField(meta$$communicationFormatType$token, communicationFormatType == null ? null : communicationFormatType.getToken());
            return;
        }
        if (_n.equals("sinkRef")) {
            if (sinkRef == null) w.writeNull(meta$$sinkRef); else w.addField(sinkRef);
            return;
        }
        if (_n.equals("originatorRef")) {
            if (originatorRef == null) w.writeNull(meta$$originatorRef); else w.addField(originatorRef);
            return;
        }
        if (_n.equals("configurationRef")) {
            if (configurationRef == null) w.writeNull(meta$$configurationRef); else w.addField(configurationRef);
            return;
        }
        if (_n.equals("returnCode")) {
            if (returnCode == null) w.writeNull(meta$$returnCode); else w.addField(returnCode);
            return;
        }
        if (_n.equals("returnDetails")) {
            w.addField(meta$$returnDetails, returnDetails);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        try {  // for possible EnumExceptions
        communicationFormatType = com.arvatosystems.fortytwo.base.api.CommunicationFormatType.factory(p.readString("communicationFormatType", true, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        sinkRef = p.readLong      ("sinkRef", true, false);
        originatorRef = p.readLong      ("originatorRef", true, false);
        configurationRef = p.readLong      ("configurationRef", true, false);
        returnCode = p.readInteger   ("returnCode", true, false);
        returnDetails = p.readString    ("returnDetails", true, 80, true, false, false, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (returnDetails != null) {
            if (returnDetails.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "returnDetails.length=" + returnDetails.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (communicationFormatType == null ? 0 : communicationFormatType.hashCode());
        _hash = 29 * _hash + (sinkRef == null ? 0 : sinkRef.hashCode());
        _hash = 29 * _hash + (originatorRef == null ? 0 : originatorRef.hashCode());
        _hash = 29 * _hash + (configurationRef == null ? 0 : configurationRef.hashCode());
        _hash = 29 * _hash + (returnCode == null ? 0 : returnCode.hashCode());
        _hash = 29 * _hash + (returnDetails == null ? 0 : returnDetails.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof DocumentCreatedCallbackRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof DocumentCreatedCallbackRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        DocumentCreatedCallbackRequest that = (DocumentCreatedCallbackRequest)_that;
        return super.equalsSub(_that)
        && ((communicationFormatType == null && that.communicationFormatType == null) || (communicationFormatType != null && communicationFormatType.equals(that.communicationFormatType)))
        && ((sinkRef == null && that.sinkRef == null) || (sinkRef != null && sinkRef.equals(that.sinkRef)))
        && ((originatorRef == null && that.originatorRef == null) || (originatorRef != null && originatorRef.equals(that.originatorRef)))
        && ((configurationRef == null && that.configurationRef == null) || (configurationRef != null && configurationRef.equals(that.configurationRef)))
        && ((returnCode == null && that.returnCode == null) || (returnCode != null && returnCode.equals(that.returnCode)))
        && ((returnDetails == null && that.returnDetails == null) || (returnDetails != null && returnDetails.equals(that.returnDetails)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        returnDetails = _cvt.convert(returnDetails, meta$$returnDetails);
    }
    // default no-argument constructor
    public DocumentCreatedCallbackRequest() {
        super();
    }
    
    // default all-arguments constructor
    public DocumentCreatedCallbackRequest(CommunicationFormatType communicationFormatType
    , Long sinkRef
    , Long originatorRef
    , Long configurationRef
    , Integer returnCode
    , String returnDetails
    ) {
        super();
        this.communicationFormatType = communicationFormatType;
        this.sinkRef = sinkRef;
        this.originatorRef = originatorRef;
        this.configurationRef = configurationRef;
        this.returnCode = returnCode;
        this.returnDetails = returnDetails;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == DocumentCreatedCallbackRequest.class) {
            return (T) new DocumentCreatedCallbackRequest(getCommunicationFormatType(), getSinkRef(), getOriginatorRef(), getConfigurationRef(), getReturnCode(), getReturnDetails());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/messaging/FileDownloadRequest.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.messaging;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.api.RequestParameters;


/** Request which can be used to download a file or just retrieve parameters (in case limit=0).
     * The file parameter retrieval can be done by the three requests
     * <ul>
     * <li>This one with offset = 0, limit = 0</li>
     * <li>The Sink CRUD request with CRUD.READ</li>
     * <li>The Sink Search request with objectRef = (sink)</li>
     * </ul>
     * 
     * In case of offset / limit other than 0, actual file data will be returned (or an error message, if the sink
     *     does not represent a file but went to a queue or JMS topic instead).
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class FileDownloadRequest extends RequestParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 117620819892L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // RequestParameters.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RequestParameters.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RequestParameters.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || RequestParameters.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || RequestParameters.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return com.arvatosystems.fortytwo.base.messaging.FileDownloadResponse.class;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return RequestParameters.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.messaging.FileDownloadRequest";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.RequestParameters";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$sinkRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "sinkRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$offset = new NumericElementaryDataItem(Visibility.DEFAULT, true, "offset", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", true, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$limit = new NumericElementaryDataItem(Visibility.DEFAULT, true, "limit", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", true, false, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(3);
        FieldDefinition [] field$array = new FieldDefinition[3];
        field$array[0] = meta$$sinkRef;
        field$array[1] = meta$$offset;
        field$array[2] = meta$$limit;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // references some existing Sink !
    Long sinkRef;
    // offset from start !
    long offset;
    // max number of bytes to transfer !
    int limit;
    // auto-generated getters and setters
    public Long getSinkRef() {
        return sinkRef;
    }
    public void setSinkRef(Long sinkRef) {
        this.sinkRef = sinkRef;
    }
    public long getOffset() {
        return offset;
    }
    public void setOffset(long offset) {
        this.offset = offset;
    }
    public int getLimit() {
        return limit;
    }
    public void setLimit(int limit) {
        this.limit = limit;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (sinkRef == null) w.writeNull(meta$$sinkRef); else w.addField(sinkRef);
        w.addField(offset);
        w.addField(limit);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("sinkRef")) {
            if (sinkRef == null) w.writeNull(meta$$sinkRef); else w.addField(sinkRef);
            return;
        }
        if (_n.equals("offset")) {
            w.addField(offset);
            return;
        }
        if (_n.equals("limit")) {
            w.addField(limit);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        sinkRef = p.readLong      ("sinkRef", false, false);
        offset = p.readLong      ("offset", false, false);
        limit = p.readInteger   ("limit", false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (sinkRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "sinkRef", PARTIALLY_QUALIFIED_CLASS_NAME);
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (sinkRef == null ? 0 : sinkRef.hashCode());
        _hash = 29 * _hash + (int)(offset^(offset>>>32));
        _hash = 29 * _hash + limit;
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof FileDownloadRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof FileDownloadRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        FileDownloadRequest that = (FileDownloadRequest)_that;
        return super.equalsSub(_that)
        && ((sinkRef == null && that.sinkRef == null) || (sinkRef != null && sinkRef.equals(that.sinkRef)))
        && offset == that.offset
        && limit == that.limit
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public FileDownloadRequest() {
        super();
    }
    
    // default all-arguments constructor
    public FileDownloadRequest(Long sinkRef
    , long offset
    , int limit
    ) {
        super();
        this.sinkRef = sinkRef;
        this.offset = offset;
        this.limit = limit;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == FileDownloadRequest.class) {
            return (T) new FileDownloadRequest(getSinkRef(), getOffset(), getLimit());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/messaging/FileDownloadResponse.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.messaging;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.api.ServiceResponse;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class FileDownloadResponse extends ServiceResponse
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -225019657303L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // ServiceResponse.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return ServiceResponse.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return ServiceResponse.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || ServiceResponse.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || ServiceResponse.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return ServiceResponse.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return ServiceResponse.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.messaging.FileDownloadResponse";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.ServiceResponse";
    private static final String BUNDLE = null;
    
    protected static final ObjectReference meta$$sink = new ObjectReference(Visibility.DEFAULT, true, "sink", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "Sink", false, true, "Sink");
    protected static final MiscElementaryDataItem meta$$hasMore = new MiscElementaryDataItem(Visibility.DEFAULT, true, "hasMore", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", true);
    protected static final BinaryElementaryDataItem meta$$data = new BinaryElementaryDataItem(Visibility.DEFAULT, true, "data", Multiplicity.SCALAR, 0, 0, 0, DataCategory.BINARY,
        "ByteArray", false, 11500000);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(3);
        FieldDefinition [] field$array = new FieldDefinition[3];
        field$array[0] = meta$$sink;
        field$array[1] = meta$$hasMore;
        field$array[2] = meta$$data;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // file information !
    Sink sink;
    // if this data does not reach EOF !
    boolean hasMore;
    // must be less than maxMessage size in length, when base64 encoded, !
    ByteArray data;
    // auto-generated getters and setters
    public Sink getSink() {
        return sink;
    }
    public void setSink(Sink sink) {
        this.sink = sink;
    }
    public boolean getHasMore() {
        return hasMore;
    }
    public void setHasMore(boolean hasMore) {
        this.hasMore = hasMore;
    }
    public ByteArray getData() {
        return data;
    }
    public void setData(ByteArray data) {
        this.data = data;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField((BonaPortable)sink);
        w.addField(hasMore);
        w.addField(meta$$data, data);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("sink")) {
            if (sink == null) {
                w.writeNull(meta$$sink);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)sink);             // full / recursive object output
            } else {
                // write a specific subcomponent
                sink.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        if (_n.equals("hasMore")) {
            w.addField(hasMore);
            return;
        }
        if (_n.equals("data")) {
            w.addField(meta$$data, data);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        sink = (Sink)p.readObject("sink", Sink.class, false, true);
        hasMore = p.readBoolean   ("hasMore", false);
        data = p.readByteArray ("data", false, 11500000);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (sink == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "sink", PARTIALLY_QUALIFIED_CLASS_NAME);
        sink.validate();      // check object (!= null checked before)
        if (data == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "data", PARTIALLY_QUALIFIED_CLASS_NAME);
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (sink == null ? 0 : sink.hashCode());
        _hash = 29 * _hash + (hasMore ? 1231 : 1237);
        _hash = 29 * _hash + (data == null ? 0 : data.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof FileDownloadResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof FileDownloadResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        FileDownloadResponse that = (FileDownloadResponse)_that;
        return super.equalsSub(_that)
        && ((sink == null && that.sink == null) || (sink != null && sink.hasSameContentsAs(that.sink)))
        && hasMore == that.hasMore
        && ((data == null && that.data == null) || (data != null && data.contentEquals(that.data)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        if (sink != null)
            sink.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public FileDownloadResponse() {
        super();
    }
    
    // default all-arguments constructor
    public FileDownloadResponse(ByteArray requestId
    , String tenantId
    , Long processRef
    , int returnCode
    , String errorDetails
    , String errorMessage
    , Sink sink
    , boolean hasMore
    , ByteArray data
    ) {
        super(requestId
        , tenantId
        , processRef
        , returnCode
        , errorDetails
        , errorMessage
        );
        this.sink = sink;
        this.hasMore = hasMore;
        this.data = data;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == FileDownloadResponse.class) {
            return (T) new FileDownloadResponse(getRequestId(), getTenantId(), getProcessRef(), getReturnCode(), getErrorDetails(), getErrorMessage(), getSink(), getHasMore(), getData());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/messaging/FileUploadRequest.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.messaging;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.api.RequestParameters;
import com.arvatosystems.fortytwo.base.api.OutputSessionParameters;


/** The file upload request allows to create a sink entry for given upload data.
     * It returns a sink reference in case of success.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class FileUploadRequest extends RequestParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -32854016471L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // RequestParameters.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RequestParameters.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RequestParameters.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || RequestParameters.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || RequestParameters.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return com.arvatosystems.fortytwo.base.messaging.SinkCreatedResponse.class;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return RequestParameters.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.messaging.FileUploadRequest";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.RequestParameters";
    private static final String BUNDLE = null;
    
    protected static final ObjectReference meta$$parameters = new ObjectReference(Visibility.DEFAULT, true, "parameters", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "OutputSessionParameters", false, true, "OutputSessionParameters");
    protected static final BinaryElementaryDataItem meta$$data = new BinaryElementaryDataItem(Visibility.DEFAULT, true, "data", Multiplicity.SCALAR, 0, 0, 0, DataCategory.BINARY,
        "ByteArray", false, 11500000);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$parameters;
        field$array[1] = meta$$data;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // any input, most important is DATA_SINK_ID !
    OutputSessionParameters parameters;
    // must be less than maxMessage size in length, when base64 encoded, !
    ByteArray data;
    // auto-generated getters and setters
    public OutputSessionParameters getParameters() {
        return parameters;
    }
    public void setParameters(OutputSessionParameters parameters) {
        this.parameters = parameters;
    }
    public ByteArray getData() {
        return data;
    }
    public void setData(ByteArray data) {
        this.data = data;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField((BonaPortable)parameters);
        w.addField(meta$$data, data);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("parameters")) {
            if (parameters == null) {
                w.writeNull(meta$$parameters);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)parameters);             // full / recursive object output
            } else {
                // write a specific subcomponent
                parameters.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        if (_n.equals("data")) {
            w.addField(meta$$data, data);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        parameters = (OutputSessionParameters)p.readObject("parameters", OutputSessionParameters.class, false, true);
        data = p.readByteArray ("data", false, 11500000);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (parameters == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "parameters", PARTIALLY_QUALIFIED_CLASS_NAME);
        parameters.validate();      // check object (!= null checked before)
        if (data == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "data", PARTIALLY_QUALIFIED_CLASS_NAME);
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (parameters == null ? 0 : parameters.hashCode());
        _hash = 29 * _hash + (data == null ? 0 : data.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof FileUploadRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof FileUploadRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        FileUploadRequest that = (FileUploadRequest)_that;
        return super.equalsSub(_that)
        && ((parameters == null && that.parameters == null) || (parameters != null && parameters.hasSameContentsAs(that.parameters)))
        && ((data == null && that.data == null) || (data != null && data.contentEquals(that.data)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        if (parameters != null)
            parameters.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public FileUploadRequest() {
        super();
    }
    
    // default all-arguments constructor
    public FileUploadRequest(OutputSessionParameters parameters
    , ByteArray data
    ) {
        super();
        this.parameters = parameters;
        this.data = data;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == FileUploadRequest.class) {
            return (T) new FileUploadRequest(getParameters(), getData());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/messaging/RequestHandlerCategory.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.messaging;

import de.jpaw.util.EnumException;
import de.jpaw.enums.TokenizableEnum;

/** Defines the principal type of a callback / request handler.
     * This defines the location of use as well as the base class of the request handler's parameters.
     */

public enum RequestHandlerCategory implements TokenizableEnum {
    PLAIN_SCHEDULER_JOB("S"), DOCUMENT_CREATED_CALLBACK("D");

    // constructor by token
    private String _token;
    private RequestHandlerCategory(String _token) {
        this._token = _token;
    }

    // token retrieval
    @Override
    public String getToken() {
        return _token;
    }

    // static factory method.
    public static RequestHandlerCategory factory(String _token) throws EnumException {
        if (_token != null) {
            if (_token.equals("S")) return PLAIN_SCHEDULER_JOB;
            if (_token.equals("D")) return DOCUMENT_CREATED_CALLBACK;
            throw new EnumException(EnumException.INVALID_NUM, _token);
        }
        return null;
    }

    public static RequestHandlerCategory valueOf(Integer ordinal) throws EnumException {
        if (ordinal != null) {
            switch (ordinal.intValue()) {
            case 0: return PLAIN_SCHEDULER_JOB;
            case 1: return DOCUMENT_CREATED_CALLBACK;
            default: throw new EnumException(EnumException.INVALID_NUM, ordinal.toString());
            }
        }
        return null;
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/messaging/RequestHandlerConfigDTO.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.messaging;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;
import com.arvatosystems.fortytwo.base.api.RequestParameters;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
@com.arvatosystems.fortytwo.base.TenantCategory("D")    
public class RequestHandlerConfigDTO extends RequestHandlerConfigRef
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -197763730198L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        map.putIfAbsent("tenantCategory", "D");
        map.putIfAbsent("tenantRef.noupdate", "");
        map.putIfAbsent("jobRequestObjectName.noupdate", "");
        map.putIfAbsent("jobParameters.serialized", "");
        // RequestHandlerConfigRef.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RequestHandlerConfigRef.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RequestHandlerConfigRef.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || RequestHandlerConfigRef.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || RequestHandlerConfigRef.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return RequestHandlerConfigRef.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return RequestHandlerConfigRef.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.messaging.RequestHandlerConfigDTO";
    private static final String REVISION = null;
    private static final String PARENT = "base.messaging.RequestHandlerConfigRef";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$tenantRef = new NumericElementaryDataItem(Visibility.PUBLIC, true, "tenantRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$jobRequestObjectName = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "jobRequestObjectName", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 100, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$category$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "category$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$category = new EnumDataItem(Visibility.DEFAULT, true, "category", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "RequestHandlerCategory", false, "RequestHandlerCategory", null);
    protected static final AlphanumericElementaryDataItem meta$$moduleId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "moduleId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 16, 1, null);
    protected static final AlphanumericElementaryDataItem meta$$name = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "name", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 80, 0, null);
    protected static final ObjectReference meta$$jobParameters = new ObjectReference(Visibility.DEFAULT, false, "jobParameters", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "RequestParameters", false, true, "RequestParameters");
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(6);
        FieldDefinition [] field$array = new FieldDefinition[6];
        field$array[0] = meta$$tenantRef;
        field$array[1] = meta$$jobRequestObjectName;
        field$array[2] = meta$$category;
        field$array[3] = meta$$moduleId;
        field$array[4] = meta$$name;
        field$array[5] = meta$$jobParameters;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // links to ALL_TENANTS or to a specific tenant !
    @com.arvatosystems.fortytwo.base.NotUpdatable
    public Long tenantRef;
    // the PQON of the object extending RequestParameters !
    @com.arvatosystems.fortytwo.base.NotUpdatable
    String jobRequestObjectName;
    // purpose of the handler !
    RequestHandlerCategory category;
    // must match the DataSink originatorModule or scheduler moduleId !
    String moduleId;
    // explanation / purpose in primary language !
    String name;
    // filled by backend (for CRUD C and U operations) !
    RequestParameters jobParameters;
    // auto-generated getters and setters
    public Long getTenantRef() {
        return tenantRef;
    }
    public void setTenantRef(Long tenantRef) {
        this.tenantRef = tenantRef;
    }
    public String getJobRequestObjectName() {
        return jobRequestObjectName;
    }
    public void setJobRequestObjectName(String jobRequestObjectName) {
        this.jobRequestObjectName = jobRequestObjectName;
    }
    public RequestHandlerCategory getCategory() {
        return category;
    }
    public void setCategory(RequestHandlerCategory category) {
        this.category = category;
    }
    public String getModuleId() {
        return moduleId;
    }
    public void setModuleId(String moduleId) {
        this.moduleId = moduleId;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public RequestParameters getJobParameters() {
        return jobParameters;
    }
    public void setJobParameters(RequestParameters jobParameters) {
        this.jobParameters = jobParameters;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
        w.addField(meta$$jobRequestObjectName, jobRequestObjectName);
        w.addField(meta$$category$token, category == null ? null : category.getToken());
        w.addField(meta$$moduleId, moduleId);
        w.addField(meta$$name, name);
        w.addField((BonaPortable)jobParameters);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("tenantRef")) {
            if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
            return;
        }
        if (_n.equals("jobRequestObjectName")) {
            w.addField(meta$$jobRequestObjectName, jobRequestObjectName);
            return;
        }
        if (_n.equals("category")) {
            w.addField(meta$$category$token, category == null ? null : category.getToken());
            return;
        }
        if (_n.equals("moduleId")) {
            w.addField(meta$$moduleId, moduleId);
            return;
        }
        if (_n.equals("name")) {
            w.addField(meta$$name, name);
            return;
        }
        if (_n.equals("jobParameters")) {
            if (jobParameters == null) {
                w.writeNull(meta$$jobParameters);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)jobParameters);             // full / recursive object output
            } else {
                // write a specific subcomponent
                jobParameters.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        tenantRef = p.readLong      ("tenantRef", false, false);
        jobRequestObjectName = p.readString    ("jobRequestObjectName", false, 100, true, false, false, false);
        try {  // for possible EnumExceptions
        category = com.arvatosystems.fortytwo.base.messaging.RequestHandlerCategory.factory(p.readString("category", false, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        moduleId = p.readString    ("moduleId", false, 16, true, false, false, false);
        name = p.readString    ("name", false, 80, true, false, false, true);
        jobParameters = (RequestParameters)p.readObject("jobParameters", RequestParameters.class, true, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (tenantRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "tenantRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (jobRequestObjectName == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "jobRequestObjectName", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (category == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "category", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (moduleId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "moduleId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (name == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "name", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (jobParameters != null)
            jobParameters.validate();  // check object
        if (jobRequestObjectName != null) {
            if (jobRequestObjectName.length() > 100)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "jobRequestObjectName.length=" + jobRequestObjectName.length() + " > 100",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (moduleId != null) {
            if (moduleId.length() > 16)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "moduleId.length=" + moduleId.length() + " > 16",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
            if (moduleId.length() < 1)
                throw new ObjectValidationException(ObjectValidationException.TOO_SHORT,
                                                    "moduleId.length=" + moduleId.length() + " < 1",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (name != null) {
            if (name.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "name.length=" + name.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (tenantRef == null ? 0 : tenantRef.hashCode());
        _hash = 29 * _hash + (jobRequestObjectName == null ? 0 : jobRequestObjectName.hashCode());
        _hash = 29 * _hash + (category == null ? 0 : category.hashCode());
        _hash = 29 * _hash + (moduleId == null ? 0 : moduleId.hashCode());
        _hash = 29 * _hash + (name == null ? 0 : name.hashCode());
        _hash = 29 * _hash + (jobParameters == null ? 0 : jobParameters.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof RequestHandlerConfigDTO))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof RequestHandlerConfigDTO))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        RequestHandlerConfigDTO that = (RequestHandlerConfigDTO)_that;
        return super.equalsSub(_that)
        && ((tenantRef == null && that.tenantRef == null) || (tenantRef != null && tenantRef.equals(that.tenantRef)))
        && ((jobRequestObjectName == null && that.jobRequestObjectName == null) || (jobRequestObjectName != null && jobRequestObjectName.equals(that.jobRequestObjectName)))
        && ((category == null && that.category == null) || (category != null && category.equals(that.category)))
        && ((moduleId == null && that.moduleId == null) || (moduleId != null && moduleId.equals(that.moduleId)))
        && ((name == null && that.name == null) || (name != null && name.equals(that.name)))
        && ((jobParameters == null && that.jobParameters == null) || (jobParameters != null && jobParameters.hasSameContentsAs(that.jobParameters)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        jobRequestObjectName = _cvt.convert(jobRequestObjectName, meta$$jobRequestObjectName);
        moduleId = _cvt.convert(moduleId, meta$$moduleId);
        name = _cvt.convert(name, meta$$name);
        if (jobParameters != null)
            jobParameters.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public RequestHandlerConfigDTO() {
        super();
    }
    
    // default all-arguments constructor
    public RequestHandlerConfigDTO(Long objectRef
    , Long tenantRef
    , String jobRequestObjectName
    , RequestHandlerCategory category
    , String moduleId
    , String name
    , RequestParameters jobParameters
    ) {
        super(objectRef
        );
        this.tenantRef = tenantRef;
        this.jobRequestObjectName = jobRequestObjectName;
        this.category = category;
        this.moduleId = moduleId;
        this.name = name;
        this.jobParameters = jobParameters;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == RequestHandlerConfigDTO.class) {
            return (T) new RequestHandlerConfigDTO(getObjectRef(), getTenantRef(), getJobRequestObjectName(), getCategory(), getModuleId(), getName(), getJobParameters());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/messaging/RequestHandlerConfigKey.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.messaging;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public final class RequestHandlerConfigKey extends RequestHandlerConfigRef
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -197762774422L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // RequestHandlerConfigRef.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RequestHandlerConfigRef.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RequestHandlerConfigRef.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || RequestHandlerConfigRef.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || RequestHandlerConfigRef.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return RequestHandlerConfigRef.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return RequestHandlerConfigRef.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.messaging.RequestHandlerConfigKey";
    private static final String REVISION = null;
    private static final String PARENT = "base.messaging.RequestHandlerConfigRef";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$tenantRef = new NumericElementaryDataItem(Visibility.PUBLIC, true, "tenantRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$jobRequestObjectName = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "jobRequestObjectName", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 100, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$tenantRef;
        field$array[1] = meta$$jobRequestObjectName;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // links to ALL_TENANTS or to a specific tenant !
    public Long tenantRef;
    // the PQON of the object extending RequestParameters !
    String jobRequestObjectName;
    // auto-generated getters and setters
    public Long getTenantRef() {
        return tenantRef;
    }
    public void setTenantRef(Long tenantRef) {
        this.tenantRef = tenantRef;
    }
    public String getJobRequestObjectName() {
        return jobRequestObjectName;
    }
    public void setJobRequestObjectName(String jobRequestObjectName) {
        this.jobRequestObjectName = jobRequestObjectName;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
        w.addField(meta$$jobRequestObjectName, jobRequestObjectName);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("tenantRef")) {
            if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
            return;
        }
        if (_n.equals("jobRequestObjectName")) {
            w.addField(meta$$jobRequestObjectName, jobRequestObjectName);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        tenantRef = p.readLong      ("tenantRef", false, false);
        jobRequestObjectName = p.readString    ("jobRequestObjectName", false, 100, true, false, false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (tenantRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "tenantRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (jobRequestObjectName == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "jobRequestObjectName", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (jobRequestObjectName != null) {
            if (jobRequestObjectName.length() > 100)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "jobRequestObjectName.length=" + jobRequestObjectName.length() + " > 100",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (tenantRef == null ? 0 : tenantRef.hashCode());
        _hash = 29 * _hash + (jobRequestObjectName == null ? 0 : jobRequestObjectName.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof RequestHandlerConfigKey))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof RequestHandlerConfigKey))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        RequestHandlerConfigKey that = (RequestHandlerConfigKey)_that;
        return super.equalsSub(_that)
        && ((tenantRef == null && that.tenantRef == null) || (tenantRef != null && tenantRef.equals(that.tenantRef)))
        && ((jobRequestObjectName == null && that.jobRequestObjectName == null) || (jobRequestObjectName != null && jobRequestObjectName.equals(that.jobRequestObjectName)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        jobRequestObjectName = _cvt.convert(jobRequestObjectName, meta$$jobRequestObjectName);
    }
    // default no-argument constructor
    public RequestHandlerConfigKey() {
        super();
    }
    
    // default all-arguments constructor
    public RequestHandlerConfigKey(Long objectRef
    , Long tenantRef
    , String jobRequestObjectName
    ) {
        super(objectRef
        );
        this.tenantRef = tenantRef;
        this.jobRequestObjectName = jobRequestObjectName;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == RequestHandlerConfigKey.class) {
            return (T) new RequestHandlerConfigKey(getObjectRef(), getTenantRef(), getJobRequestObjectName());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/messaging/RequestHandlerConfigRef.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.messaging;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;


/** RequestHandlerConfig lists all available handlers for a given category. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class RequestHandlerConfigRef extends Ref
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -99862047015L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // Ref.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return Ref.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return Ref.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.messaging.RequestHandlerConfigRef";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.Ref";
    private static final String BUNDLE = null;
    
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(0);
        FieldDefinition [] field$array = new FieldDefinition[0];
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 13;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // auto-generated getters and setters
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof RequestHandlerConfigRef))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof RequestHandlerConfigRef))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        RequestHandlerConfigRef that = (RequestHandlerConfigRef)_that;
        return super.equalsSub(_that)
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public RequestHandlerConfigRef() {
        super();
    }
    
    // default all-arguments constructor
    public RequestHandlerConfigRef(Long objectRef
    ) {
        super(objectRef
        );
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == RequestHandlerConfigRef.class) {
            return (T) new RequestHandlerConfigRef(getObjectRef());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/messaging/Sink.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.messaging;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;
import com.arvatosystems.fortytwo.base.api.CommunicationFormatType;
import com.arvatosystems.fortytwo.base.api.CommunicationTargetChannelType;


/** Records all asynchronous outgoing communication. For every file created, there is one entry of this type.
     * The time used to create this output can be measured by taking the difference between mTimestamp and cTimestamp
     * in the underlying database table (or TrackingData).
     * 
     * A sink contains either structured data (on a record basis), formatted in Bonaparte, XML or JSON format, but can
     * also contain output from the reporting or communications module, in which case the data can be in additional
     * formats such as PDF, XLS, CSV or plain text. Primarily for the latter case, the file type can also be defined
     * by the actual program run and passed as part of the parameters to the open() method, and then will not be taken
     * from the configuration table.
     * 
     * Structured output will be logged into OutboundMessages.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
@com.arvatosystems.fortytwo.base.TenantCategory("I")    
public class Sink extends SinkRef
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 58353846981L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        map.putIfAbsent("tenantCategory", "I");
        map.putIfAbsent("dataSinkRef.ref", "DataSinkKey");
        map.putIfAbsent("dataSinkRef.noupdate", "");
        map.putIfAbsent("dataSinkRef.searchprefix", "dataSink");
        // SinkRef.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return SinkRef.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return SinkRef.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || SinkRef.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || SinkRef.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return SinkRef.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return SinkRef.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.messaging.Sink";
    private static final String REVISION = null;
    private static final String PARENT = "base.messaging.SinkRef";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$commTargetChannelType$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "commTargetChannelType$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$commTargetChannelType = new EnumDataItem(Visibility.DEFAULT, true, "commTargetChannelType", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "CommunicationTargetChannelType", false, "CommunicationTargetChannelType", null);
    protected static final AlphanumericElementaryDataItem meta$$commFormatType$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "commFormatType$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$commFormatType = new EnumDataItem(Visibility.DEFAULT, true, "commFormatType", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "CommunicationFormatType", false, "CommunicationFormatType", null);
    protected static final AlphanumericElementaryDataItem meta$$fileOrQueueName = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "fileOrQueueName", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 255, 0, null);
    protected static final NumericElementaryDataItem meta$$numberOfSourceRecords = new NumericElementaryDataItem(Visibility.DEFAULT, false, "numberOfSourceRecords", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$numberOfMappedRecords = new NumericElementaryDataItem(Visibility.DEFAULT, false, "numberOfMappedRecords", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    protected static final TemporalElementaryDataItem meta$$plannedRunDate = new TemporalElementaryDataItem(Visibility.DEFAULT, false, "plannedRunDate", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    protected static final NumericElementaryDataItem meta$$originatorRef = new NumericElementaryDataItem(Visibility.DEFAULT, false, "originatorRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$configurationRef = new NumericElementaryDataItem(Visibility.DEFAULT, false, "configurationRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final ObjectReference meta$$dataSinkRef = new ObjectReference(Visibility.DEFAULT, true, "dataSinkRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "DataSinkRef", false, true, "DataSinkRef");
    protected static final NumericElementaryDataItem meta$$fileSize = new NumericElementaryDataItem(Visibility.DEFAULT, false, "fileSize", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(10);
        FieldDefinition [] field$array = new FieldDefinition[10];
        field$array[0] = meta$$commTargetChannelType;
        field$array[1] = meta$$commFormatType;
        field$array[2] = meta$$fileOrQueueName;
        field$array[3] = meta$$numberOfSourceRecords;
        field$array[4] = meta$$numberOfMappedRecords;
        field$array[5] = meta$$plannedRunDate;
        field$array[6] = meta$$originatorRef;
        field$array[7] = meta$$configurationRef;
        field$array[8] = meta$$dataSinkRef;
        field$array[9] = meta$$fileSize;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // filled from configuration lookup !
    CommunicationTargetChannelType commTargetChannelType;
    // filled from configuration lookup !
    CommunicationFormatType commFormatType;
    // file name (including optional date/time pattern) or queue name !
    String fileOrQueueName;
    // in case of structured output, the number of records written (pre Hook) !
    Integer numberOfSourceRecords;
    // in case of structured output, the number of records written (post Hook) !
    Integer numberOfMappedRecords;
    // optional scheduled run date of the call (only for messages from the scheduler) !
    LocalDateTime plannedRunDate;
    // optional link to object which is representing this file (params ref) (predox ref) !
    Long originatorRef;
    // a reference to the configuration of the originator (aroma ref) !
    Long configurationRef;
    // replaces configurationUsed !
    @com.arvatosystems.fortytwo.base.NotUpdatable
    DataSinkRef dataSinkRef;
    // size of the created file (if available) !
    Long fileSize;
    // auto-generated getters and setters
    public CommunicationTargetChannelType getCommTargetChannelType() {
        return commTargetChannelType;
    }
    public void setCommTargetChannelType(CommunicationTargetChannelType commTargetChannelType) {
        this.commTargetChannelType = commTargetChannelType;
    }
    public CommunicationFormatType getCommFormatType() {
        return commFormatType;
    }
    public void setCommFormatType(CommunicationFormatType commFormatType) {
        this.commFormatType = commFormatType;
    }
    public String getFileOrQueueName() {
        return fileOrQueueName;
    }
    public void setFileOrQueueName(String fileOrQueueName) {
        this.fileOrQueueName = fileOrQueueName;
    }
    public Integer getNumberOfSourceRecords() {
        return numberOfSourceRecords;
    }
    public void setNumberOfSourceRecords(Integer numberOfSourceRecords) {
        this.numberOfSourceRecords = numberOfSourceRecords;
    }
    public Integer getNumberOfMappedRecords() {
        return numberOfMappedRecords;
    }
    public void setNumberOfMappedRecords(Integer numberOfMappedRecords) {
        this.numberOfMappedRecords = numberOfMappedRecords;
    }
    public LocalDateTime getPlannedRunDate() {
        return plannedRunDate;
    }
    public void setPlannedRunDate(LocalDateTime plannedRunDate) {
        this.plannedRunDate = plannedRunDate;
    }
    public Long getOriginatorRef() {
        return originatorRef;
    }
    public void setOriginatorRef(Long originatorRef) {
        this.originatorRef = originatorRef;
    }
    public Long getConfigurationRef() {
        return configurationRef;
    }
    public void setConfigurationRef(Long configurationRef) {
        this.configurationRef = configurationRef;
    }
    public DataSinkRef getDataSinkRef() {
        return dataSinkRef;
    }
    public void setDataSinkRef(DataSinkRef dataSinkRef) {
        this.dataSinkRef = dataSinkRef;
    }
    public Long getFileSize() {
        return fileSize;
    }
    public void setFileSize(Long fileSize) {
        this.fileSize = fileSize;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$commTargetChannelType$token, commTargetChannelType == null ? null : commTargetChannelType.getToken());
        w.addField(meta$$commFormatType$token, commFormatType == null ? null : commFormatType.getToken());
        w.addField(meta$$fileOrQueueName, fileOrQueueName);
        if (numberOfSourceRecords == null) w.writeNull(meta$$numberOfSourceRecords); else w.addField(numberOfSourceRecords);
        if (numberOfMappedRecords == null) w.writeNull(meta$$numberOfMappedRecords); else w.addField(numberOfMappedRecords);
        w.addField(meta$$plannedRunDate, plannedRunDate);
        if (originatorRef == null) w.writeNull(meta$$originatorRef); else w.addField(originatorRef);
        if (configurationRef == null) w.writeNull(meta$$configurationRef); else w.addField(configurationRef);
        w.addField((BonaPortable)dataSinkRef);
        if (fileSize == null) w.writeNull(meta$$fileSize); else w.addField(fileSize);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("commTargetChannelType")) {
            w.addField(meta$$commTargetChannelType$token, commTargetChannelType == null ? null : commTargetChannelType.getToken());
            return;
        }
        if (_n.equals("commFormatType")) {
            w.addField(meta$$commFormatType$token, commFormatType == null ? null : commFormatType.getToken());
            return;
        }
        if (_n.equals("fileOrQueueName")) {
            w.addField(meta$$fileOrQueueName, fileOrQueueName);
            return;
        }
        if (_n.equals("numberOfSourceRecords")) {
            if (numberOfSourceRecords == null) w.writeNull(meta$$numberOfSourceRecords); else w.addField(numberOfSourceRecords);
            return;
        }
        if (_n.equals("numberOfMappedRecords")) {
            if (numberOfMappedRecords == null) w.writeNull(meta$$numberOfMappedRecords); else w.addField(numberOfMappedRecords);
            return;
        }
        if (_n.equals("plannedRunDate")) {
            w.addField(meta$$plannedRunDate, plannedRunDate);
            return;
        }
        if (_n.equals("originatorRef")) {
            if (originatorRef == null) w.writeNull(meta$$originatorRef); else w.addField(originatorRef);
            return;
        }
        if (_n.equals("configurationRef")) {
            if (configurationRef == null) w.writeNull(meta$$configurationRef); else w.addField(configurationRef);
            return;
        }
        if (_n.equals("dataSinkRef")) {
            if (dataSinkRef == null) {
                w.writeNull(meta$$dataSinkRef);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)dataSinkRef);             // full / recursive object output
            } else {
                // write a specific subcomponent
                dataSinkRef.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        if (_n.equals("fileSize")) {
            if (fileSize == null) w.writeNull(meta$$fileSize); else w.addField(fileSize);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        try {  // for possible EnumExceptions
        commTargetChannelType = com.arvatosystems.fortytwo.base.api.CommunicationTargetChannelType.factory(p.readString("commTargetChannelType", false, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        try {  // for possible EnumExceptions
        commFormatType = com.arvatosystems.fortytwo.base.api.CommunicationFormatType.factory(p.readString("commFormatType", false, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        fileOrQueueName = p.readString    ("fileOrQueueName", false, 255, true, false, false, false);
        numberOfSourceRecords = p.readInteger   ("numberOfSourceRecords", true, false);
        numberOfMappedRecords = p.readInteger   ("numberOfMappedRecords", true, false);
        plannedRunDate = p.readDayTime("plannedRunDate", true, false, 0);
        originatorRef = p.readLong      ("originatorRef", true, false);
        configurationRef = p.readLong      ("configurationRef", true, false);
        dataSinkRef = (DataSinkRef)p.readObject("dataSinkRef", DataSinkRef.class, false, true);
        fileSize = p.readLong      ("fileSize", true, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (commTargetChannelType == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "commTargetChannelType", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (commFormatType == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "commFormatType", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (fileOrQueueName == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "fileOrQueueName", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (dataSinkRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "dataSinkRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        dataSinkRef.validate();      // check object (!= null checked before)
        if (fileOrQueueName != null) {
            if (fileOrQueueName.length() > 255)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "fileOrQueueName.length=" + fileOrQueueName.length() + " > 255",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (commTargetChannelType == null ? 0 : commTargetChannelType.hashCode());
        _hash = 29 * _hash + (commFormatType == null ? 0 : commFormatType.hashCode());
        _hash = 29 * _hash + (fileOrQueueName == null ? 0 : fileOrQueueName.hashCode());
        _hash = 29 * _hash + (numberOfSourceRecords == null ? 0 : numberOfSourceRecords.hashCode());
        _hash = 29 * _hash + (numberOfMappedRecords == null ? 0 : numberOfMappedRecords.hashCode());
        _hash = 29 * _hash + (plannedRunDate == null ? 0 : plannedRunDate.hashCode());
        _hash = 29 * _hash + (originatorRef == null ? 0 : originatorRef.hashCode());
        _hash = 29 * _hash + (configurationRef == null ? 0 : configurationRef.hashCode());
        _hash = 29 * _hash + (dataSinkRef == null ? 0 : dataSinkRef.hashCode());
        _hash = 29 * _hash + (fileSize == null ? 0 : fileSize.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Sink))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Sink))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        Sink that = (Sink)_that;
        return super.equalsSub(_that)
        && ((commTargetChannelType == null && that.commTargetChannelType == null) || (commTargetChannelType != null && commTargetChannelType.equals(that.commTargetChannelType)))
        && ((commFormatType == null && that.commFormatType == null) || (commFormatType != null && commFormatType.equals(that.commFormatType)))
        && ((fileOrQueueName == null && that.fileOrQueueName == null) || (fileOrQueueName != null && fileOrQueueName.equals(that.fileOrQueueName)))
        && ((numberOfSourceRecords == null && that.numberOfSourceRecords == null) || (numberOfSourceRecords != null && numberOfSourceRecords.equals(that.numberOfSourceRecords)))
        && ((numberOfMappedRecords == null && that.numberOfMappedRecords == null) || (numberOfMappedRecords != null && numberOfMappedRecords.equals(that.numberOfMappedRecords)))
        && ((plannedRunDate == null && that.plannedRunDate == null) || (plannedRunDate != null && plannedRunDate.equals(that.plannedRunDate)))
        && ((originatorRef == null && that.originatorRef == null) || (originatorRef != null && originatorRef.equals(that.originatorRef)))
        && ((configurationRef == null && that.configurationRef == null) || (configurationRef != null && configurationRef.equals(that.configurationRef)))
        && ((dataSinkRef == null && that.dataSinkRef == null) || (dataSinkRef != null && dataSinkRef.hasSameContentsAs(that.dataSinkRef)))
        && ((fileSize == null && that.fileSize == null) || (fileSize != null && fileSize.equals(that.fileSize)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        fileOrQueueName = _cvt.convert(fileOrQueueName, meta$$fileOrQueueName);
        if (dataSinkRef != null)
            dataSinkRef.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public Sink() {
        super();
    }
    
    // default all-arguments constructor
    public Sink(Long objectRef
    , CommunicationTargetChannelType commTargetChannelType
    , CommunicationFormatType commFormatType
    , String fileOrQueueName
    , Integer numberOfSourceRecords
    , Integer numberOfMappedRecords
    , LocalDateTime plannedRunDate
    , Long originatorRef
    , Long configurationRef
    , DataSinkRef dataSinkRef
    , Long fileSize
    ) {
        super(objectRef
        );
        this.commTargetChannelType = commTargetChannelType;
        this.commFormatType = commFormatType;
        this.fileOrQueueName = fileOrQueueName;
        this.numberOfSourceRecords = numberOfSourceRecords;
        this.numberOfMappedRecords = numberOfMappedRecords;
        this.plannedRunDate = plannedRunDate;
        this.originatorRef = originatorRef;
        this.configurationRef = configurationRef;
        this.dataSinkRef = dataSinkRef;
        this.fileSize = fileSize;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Sink.class) {
            return (T) new Sink(getObjectRef(), getCommTargetChannelType(), getCommFormatType(), getFileOrQueueName(), getNumberOfSourceRecords(), getNumberOfMappedRecords(), getPlannedRunDate(), getOriginatorRef(), getConfigurationRef(), getDataSinkRef(), getFileSize());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/messaging/SinkCreatedResponse.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.messaging;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.api.ServiceResponse;


/** Response which is returned by export jobs or report runs.
     * It transmits the key to the created file (or other export event).
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class SinkCreatedResponse extends ServiceResponse
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 153193775730L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // ServiceResponse.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return ServiceResponse.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return ServiceResponse.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || ServiceResponse.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || ServiceResponse.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return ServiceResponse.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return ServiceResponse.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.messaging.SinkCreatedResponse";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.ServiceResponse";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$sinkRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "sinkRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$sinkRef;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // the key to the sink table !
    Long sinkRef;
    // auto-generated getters and setters
    public Long getSinkRef() {
        return sinkRef;
    }
    public void setSinkRef(Long sinkRef) {
        this.sinkRef = sinkRef;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (sinkRef == null) w.writeNull(meta$$sinkRef); else w.addField(sinkRef);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("sinkRef")) {
            if (sinkRef == null) w.writeNull(meta$$sinkRef); else w.addField(sinkRef);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        sinkRef = p.readLong      ("sinkRef", false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (sinkRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "sinkRef", PARTIALLY_QUALIFIED_CLASS_NAME);
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (sinkRef == null ? 0 : sinkRef.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof SinkCreatedResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof SinkCreatedResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        SinkCreatedResponse that = (SinkCreatedResponse)_that;
        return super.equalsSub(_that)
        && ((sinkRef == null && that.sinkRef == null) || (sinkRef != null && sinkRef.equals(that.sinkRef)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public SinkCreatedResponse() {
        super();
    }
    
    // default all-arguments constructor
    public SinkCreatedResponse(ByteArray requestId
    , String tenantId
    , Long processRef
    , int returnCode
    , String errorDetails
    , String errorMessage
    , Long sinkRef
    ) {
        super(requestId
        , tenantId
        , processRef
        , returnCode
        , errorDetails
        , errorMessage
        );
        this.sinkRef = sinkRef;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == SinkCreatedResponse.class) {
            return (T) new SinkCreatedResponse(getRequestId(), getTenantId(), getProcessRef(), getReturnCode(), getErrorDetails(), getErrorMessage(), getSinkRef());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/messaging/SinkRef.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.messaging;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class SinkRef extends Ref
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -195584370313L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // Ref.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return Ref.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return Ref.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.messaging.SinkRef";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.Ref";
    private static final String BUNDLE = null;
    
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(0);
        FieldDefinition [] field$array = new FieldDefinition[0];
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 17;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // auto-generated getters and setters
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof SinkRef))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof SinkRef))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        SinkRef that = (SinkRef)_that;
        return super.equalsSub(_that)
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public SinkRef() {
        super();
    }
    
    // default all-arguments constructor
    public SinkRef(Long objectRef
    ) {
        super(objectRef
        );
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == SinkRef.class) {
            return (T) new SinkRef(getObjectRef());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/messaging/Source.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.messaging;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;


/** Records incoming communication. For every remote connection or file processed, there is one entry of this type. */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
@com.arvatosystems.fortytwo.base.TenantCategory("G")    
public class Source extends SourceRef
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -28047397947L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        map.putIfAbsent("tenantCategory", "G");
        // SourceRef.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return SourceRef.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return SourceRef.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || SourceRef.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || SourceRef.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return SourceRef.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return SourceRef.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.messaging.Source";
    private static final String REVISION = null;
    private static final String PARENT = "base.messaging.SourceRef";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$executable = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "executable", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 100, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$hostname = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "hostname", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 100, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$dataUrl = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "dataUrl", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 255, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$singleTenantId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "singleTenantId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 10, 1, null);
    protected static final AlphanumericElementaryDataItem meta$$osUserId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "osUserId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 32, 0, null);
    protected static final NumericElementaryDataItem meta$$numberOfRecords = new NumericElementaryDataItem(Visibility.DEFAULT, false, "numberOfRecords", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$numberSuccessful = new NumericElementaryDataItem(Visibility.DEFAULT, false, "numberSuccessful", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$numberDuplicate = new NumericElementaryDataItem(Visibility.DEFAULT, false, "numberDuplicate", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, false, 0, 0, false, false);
    protected static final TemporalElementaryDataItem meta$$executableStartedAt = new TemporalElementaryDataItem(Visibility.DEFAULT, true, "executableStartedAt", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    protected static final TemporalElementaryDataItem meta$$firstRecordProcessedAt = new TemporalElementaryDataItem(Visibility.DEFAULT, false, "firstRecordProcessedAt", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    protected static final TemporalElementaryDataItem meta$$lastRecordProcessedAt = new TemporalElementaryDataItem(Visibility.DEFAULT, false, "lastRecordProcessedAt", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    protected static final TemporalElementaryDataItem meta$$executableStoppedAt = new TemporalElementaryDataItem(Visibility.DEFAULT, false, "executableStoppedAt", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(12);
        FieldDefinition [] field$array = new FieldDefinition[12];
        field$array[0] = meta$$executable;
        field$array[1] = meta$$hostname;
        field$array[2] = meta$$dataUrl;
        field$array[3] = meta$$singleTenantId;
        field$array[4] = meta$$osUserId;
        field$array[5] = meta$$numberOfRecords;
        field$array[6] = meta$$numberSuccessful;
        field$array[7] = meta$$numberDuplicate;
        field$array[8] = meta$$executableStartedAt;
        field$array[9] = meta$$firstRecordProcessedAt;
        field$array[10] = meta$$lastRecordProcessedAt;
        field$array[11] = meta$$executableStoppedAt;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // program loading the data / accepting the transmission !
    String executable;
    // where the program was run !
    String hostname;
    // filename or just protocol : port number !
    String dataUrl;
    // if non null, every request will belong to the same tenant (allows better caching) !
    String singleTenantId;
    // user ID who started the program !
    String osUserId;
    Integer numberOfRecords;
    Integer numberSuccessful;
    // requests which have been identified as duplicate by either sourceNo/recordNo or messageId !
    Integer numberDuplicate;
    LocalDateTime executableStartedAt;
    LocalDateTime firstRecordProcessedAt;
    LocalDateTime lastRecordProcessedAt;
    LocalDateTime executableStoppedAt;
    // auto-generated getters and setters
    public String getExecutable() {
        return executable;
    }
    public void setExecutable(String executable) {
        this.executable = executable;
    }
    public String getHostname() {
        return hostname;
    }
    public void setHostname(String hostname) {
        this.hostname = hostname;
    }
    public String getDataUrl() {
        return dataUrl;
    }
    public void setDataUrl(String dataUrl) {
        this.dataUrl = dataUrl;
    }
    public String getSingleTenantId() {
        return singleTenantId;
    }
    public void setSingleTenantId(String singleTenantId) {
        this.singleTenantId = singleTenantId;
    }
    public String getOsUserId() {
        return osUserId;
    }
    public void setOsUserId(String osUserId) {
        this.osUserId = osUserId;
    }
    public Integer getNumberOfRecords() {
        return numberOfRecords;
    }
    public void setNumberOfRecords(Integer numberOfRecords) {
        this.numberOfRecords = numberOfRecords;
    }
    public Integer getNumberSuccessful() {
        return numberSuccessful;
    }
    public void setNumberSuccessful(Integer numberSuccessful) {
        this.numberSuccessful = numberSuccessful;
    }
    public Integer getNumberDuplicate() {
        return numberDuplicate;
    }
    public void setNumberDuplicate(Integer numberDuplicate) {
        this.numberDuplicate = numberDuplicate;
    }
    public LocalDateTime getExecutableStartedAt() {
        return executableStartedAt;
    }
    public void setExecutableStartedAt(LocalDateTime executableStartedAt) {
        this.executableStartedAt = executableStartedAt;
    }
    public LocalDateTime getFirstRecordProcessedAt() {
        return firstRecordProcessedAt;
    }
    public void setFirstRecordProcessedAt(LocalDateTime firstRecordProcessedAt) {
        this.firstRecordProcessedAt = firstRecordProcessedAt;
    }
    public LocalDateTime getLastRecordProcessedAt() {
        return lastRecordProcessedAt;
    }
    public void setLastRecordProcessedAt(LocalDateTime lastRecordProcessedAt) {
        this.lastRecordProcessedAt = lastRecordProcessedAt;
    }
    public LocalDateTime getExecutableStoppedAt() {
        return executableStoppedAt;
    }
    public void setExecutableStoppedAt(LocalDateTime executableStoppedAt) {
        this.executableStoppedAt = executableStoppedAt;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$executable, executable);
        w.addField(meta$$hostname, hostname);
        w.addField(meta$$dataUrl, dataUrl);
        w.addField(meta$$singleTenantId, singleTenantId);
        w.addField(meta$$osUserId, osUserId);
        if (numberOfRecords == null) w.writeNull(meta$$numberOfRecords); else w.addField(numberOfRecords);
        if (numberSuccessful == null) w.writeNull(meta$$numberSuccessful); else w.addField(numberSuccessful);
        if (numberDuplicate == null) w.writeNull(meta$$numberDuplicate); else w.addField(numberDuplicate);
        w.addField(meta$$executableStartedAt, executableStartedAt);
        w.addField(meta$$firstRecordProcessedAt, firstRecordProcessedAt);
        w.addField(meta$$lastRecordProcessedAt, lastRecordProcessedAt);
        w.addField(meta$$executableStoppedAt, executableStoppedAt);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("executable")) {
            w.addField(meta$$executable, executable);
            return;
        }
        if (_n.equals("hostname")) {
            w.addField(meta$$hostname, hostname);
            return;
        }
        if (_n.equals("dataUrl")) {
            w.addField(meta$$dataUrl, dataUrl);
            return;
        }
        if (_n.equals("singleTenantId")) {
            w.addField(meta$$singleTenantId, singleTenantId);
            return;
        }
        if (_n.equals("osUserId")) {
            w.addField(meta$$osUserId, osUserId);
            return;
        }
        if (_n.equals("numberOfRecords")) {
            if (numberOfRecords == null) w.writeNull(meta$$numberOfRecords); else w.addField(numberOfRecords);
            return;
        }
        if (_n.equals("numberSuccessful")) {
            if (numberSuccessful == null) w.writeNull(meta$$numberSuccessful); else w.addField(numberSuccessful);
            return;
        }
        if (_n.equals("numberDuplicate")) {
            if (numberDuplicate == null) w.writeNull(meta$$numberDuplicate); else w.addField(numberDuplicate);
            return;
        }
        if (_n.equals("executableStartedAt")) {
            w.addField(meta$$executableStartedAt, executableStartedAt);
            return;
        }
        if (_n.equals("firstRecordProcessedAt")) {
            w.addField(meta$$firstRecordProcessedAt, firstRecordProcessedAt);
            return;
        }
        if (_n.equals("lastRecordProcessedAt")) {
            w.addField(meta$$lastRecordProcessedAt, lastRecordProcessedAt);
            return;
        }
        if (_n.equals("executableStoppedAt")) {
            w.addField(meta$$executableStoppedAt, executableStoppedAt);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        executable = p.readString    ("executable", true, 100, true, false, false, false);
        hostname = p.readString    ("hostname", true, 100, true, false, false, false);
        dataUrl = p.readString    ("dataUrl", true, 255, true, false, false, true);
        singleTenantId = p.readString    ("singleTenantId", true, 10, true, false, false, false);
        osUserId = p.readString    ("osUserId", false, 32, true, false, false, true);
        numberOfRecords = p.readInteger   ("numberOfRecords", true, false);
        numberSuccessful = p.readInteger   ("numberSuccessful", true, false);
        numberDuplicate = p.readInteger   ("numberDuplicate", true, false);
        executableStartedAt = p.readDayTime("executableStartedAt", false, false, 0);
        firstRecordProcessedAt = p.readDayTime("firstRecordProcessedAt", true, false, 0);
        lastRecordProcessedAt = p.readDayTime("lastRecordProcessedAt", true, false, 0);
        executableStoppedAt = p.readDayTime("executableStoppedAt", true, false, 0);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (osUserId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "osUserId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (executableStartedAt == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "executableStartedAt", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (executable != null) {
            if (executable.length() > 100)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "executable.length=" + executable.length() + " > 100",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (hostname != null) {
            if (hostname.length() > 100)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "hostname.length=" + hostname.length() + " > 100",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (dataUrl != null) {
            if (dataUrl.length() > 255)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "dataUrl.length=" + dataUrl.length() + " > 255",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (singleTenantId != null) {
            if (singleTenantId.length() > 10)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "singleTenantId.length=" + singleTenantId.length() + " > 10",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
            if (singleTenantId.length() < 1)
                throw new ObjectValidationException(ObjectValidationException.TOO_SHORT,
                                                    "singleTenantId.length=" + singleTenantId.length() + " < 1",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (osUserId != null) {
            if (osUserId.length() > 32)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "osUserId.length=" + osUserId.length() + " > 32",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (executable == null ? 0 : executable.hashCode());
        _hash = 29 * _hash + (hostname == null ? 0 : hostname.hashCode());
        _hash = 29 * _hash + (dataUrl == null ? 0 : dataUrl.hashCode());
        _hash = 29 * _hash + (singleTenantId == null ? 0 : singleTenantId.hashCode());
        _hash = 29 * _hash + (osUserId == null ? 0 : osUserId.hashCode());
        _hash = 29 * _hash + (numberOfRecords == null ? 0 : numberOfRecords.hashCode());
        _hash = 29 * _hash + (numberSuccessful == null ? 0 : numberSuccessful.hashCode());
        _hash = 29 * _hash + (numberDuplicate == null ? 0 : numberDuplicate.hashCode());
        _hash = 29 * _hash + (executableStartedAt == null ? 0 : executableStartedAt.hashCode());
        _hash = 29 * _hash + (firstRecordProcessedAt == null ? 0 : firstRecordProcessedAt.hashCode());
        _hash = 29 * _hash + (lastRecordProcessedAt == null ? 0 : lastRecordProcessedAt.hashCode());
        _hash = 29 * _hash + (executableStoppedAt == null ? 0 : executableStoppedAt.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Source))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Source))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        Source that = (Source)_that;
        return super.equalsSub(_that)
        && ((executable == null && that.executable == null) || (executable != null && executable.equals(that.executable)))
        && ((hostname == null && that.hostname == null) || (hostname != null && hostname.equals(that.hostname)))
        && ((dataUrl == null && that.dataUrl == null) || (dataUrl != null && dataUrl.equals(that.dataUrl)))
        && ((singleTenantId == null && that.singleTenantId == null) || (singleTenantId != null && singleTenantId.equals(that.singleTenantId)))
        && ((osUserId == null && that.osUserId == null) || (osUserId != null && osUserId.equals(that.osUserId)))
        && ((numberOfRecords == null && that.numberOfRecords == null) || (numberOfRecords != null && numberOfRecords.equals(that.numberOfRecords)))
        && ((numberSuccessful == null && that.numberSuccessful == null) || (numberSuccessful != null && numberSuccessful.equals(that.numberSuccessful)))
        && ((numberDuplicate == null && that.numberDuplicate == null) || (numberDuplicate != null && numberDuplicate.equals(that.numberDuplicate)))
        && ((executableStartedAt == null && that.executableStartedAt == null) || (executableStartedAt != null && executableStartedAt.equals(that.executableStartedAt)))
        && ((firstRecordProcessedAt == null && that.firstRecordProcessedAt == null) || (firstRecordProcessedAt != null && firstRecordProcessedAt.equals(that.firstRecordProcessedAt)))
        && ((lastRecordProcessedAt == null && that.lastRecordProcessedAt == null) || (lastRecordProcessedAt != null && lastRecordProcessedAt.equals(that.lastRecordProcessedAt)))
        && ((executableStoppedAt == null && that.executableStoppedAt == null) || (executableStoppedAt != null && executableStoppedAt.equals(that.executableStoppedAt)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        executable = _cvt.convert(executable, meta$$executable);
        hostname = _cvt.convert(hostname, meta$$hostname);
        dataUrl = _cvt.convert(dataUrl, meta$$dataUrl);
        singleTenantId = _cvt.convert(singleTenantId, meta$$singleTenantId);
        osUserId = _cvt.convert(osUserId, meta$$osUserId);
    }
    // default no-argument constructor
    public Source() {
        super();
    }
    
    // default all-arguments constructor
    public Source(Long objectRef
    , String executable
    , String hostname
    , String dataUrl
    , String singleTenantId
    , String osUserId
    , Integer numberOfRecords
    , Integer numberSuccessful
    , Integer numberDuplicate
    , LocalDateTime executableStartedAt
    , LocalDateTime firstRecordProcessedAt
    , LocalDateTime lastRecordProcessedAt
    , LocalDateTime executableStoppedAt
    ) {
        super(objectRef
        );
        this.executable = executable;
        this.hostname = hostname;
        this.dataUrl = dataUrl;
        this.singleTenantId = singleTenantId;
        this.osUserId = osUserId;
        this.numberOfRecords = numberOfRecords;
        this.numberSuccessful = numberSuccessful;
        this.numberDuplicate = numberDuplicate;
        this.executableStartedAt = executableStartedAt;
        this.firstRecordProcessedAt = firstRecordProcessedAt;
        this.lastRecordProcessedAt = lastRecordProcessedAt;
        this.executableStoppedAt = executableStoppedAt;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Source.class) {
            return (T) new Source(getObjectRef(), getExecutable(), getHostname(), getDataUrl(), getSingleTenantId(), getOsUserId(), getNumberOfRecords(), getNumberSuccessful(), getNumberDuplicate(), getExecutableStartedAt(), getFirstRecordProcessedAt(), getLastRecordProcessedAt(), getExecutableStoppedAt());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/messaging/SourceRef.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.messaging;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class SourceRef extends Ref
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 122641926943L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // Ref.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return Ref.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return Ref.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.messaging.SourceRef";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.Ref";
    private static final String BUNDLE = null;
    
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(0);
        FieldDefinition [] field$array = new FieldDefinition[0];
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // auto-generated getters and setters
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof SourceRef))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof SourceRef))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        SourceRef that = (SourceRef)_that;
        return super.equalsSub(_that)
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public SourceRef() {
        super();
    }
    
    // default all-arguments constructor
    public SourceRef(Long objectRef
    ) {
        super(objectRef
        );
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == SourceRef.class) {
            return (T) new SourceRef(getObjectRef());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/messaging/package-info.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

@XmlJavaTypeAdapters({
    @XmlJavaTypeAdapter(type=LocalDate.class,       value=LocalDateAdapter.class),
    @XmlJavaTypeAdapter(type=LocalTime.class,       value=LocalTimeAdapter.class),
    @XmlJavaTypeAdapter(type=LocalDateTime.class,   value=LocalDateTimeAdapter.class),
    @XmlJavaTypeAdapter(type=ByteArray.class,       value=ByteArrayAdapter.class)
})
package com.arvatosystems.fortytwo.base.messaging;

import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapters;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import org.joda.time.LocalTime;
import de.jpaw.util.ByteArray;

import de.jpaw.xml.jaxb.ByteArrayAdapter;
import de.jpaw.xml.jaxb.LocalDateAdapter;
import de.jpaw.xml.jaxb.LocalTimeAdapter;
import de.jpaw.xml.jaxb.LocalDateTimeAdapter;
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/security/AuthenticationDetails.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.security;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/**
     * The class providing additional user specific information as part of the authentication response. 
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class AuthenticationDetails
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -1491326183L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.security.AuthenticationDetails";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final TemporalElementaryDataItem meta$$whenLastLoggedIn = new TemporalElementaryDataItem(Visibility.DEFAULT, false, "whenLastLoggedIn", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    protected static final TemporalElementaryDataItem meta$$passwordExpires = new TemporalElementaryDataItem(Visibility.DEFAULT, false, "passwordExpires", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    protected static final NumericElementaryDataItem meta$$numberInvalidAttempts = new NumericElementaryDataItem(Visibility.DEFAULT, true, "numberInvalidAttempts", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Short", true, false, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(3);
        FieldDefinition [] field$array = new FieldDefinition[3];
        field$array[0] = meta$$whenLastLoggedIn;
        field$array[1] = meta$$passwordExpires;
        field$array[2] = meta$$numberInvalidAttempts;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    LocalDateTime whenLastLoggedIn;
    LocalDateTime passwordExpires;
    short numberInvalidAttempts;
    // auto-generated getters and setters
    public LocalDateTime getWhenLastLoggedIn() {
        return whenLastLoggedIn;
    }
    public void setWhenLastLoggedIn(LocalDateTime whenLastLoggedIn) {
        this.whenLastLoggedIn = whenLastLoggedIn;
    }
    public LocalDateTime getPasswordExpires() {
        return passwordExpires;
    }
    public void setPasswordExpires(LocalDateTime passwordExpires) {
        this.passwordExpires = passwordExpires;
    }
    public short getNumberInvalidAttempts() {
        return numberInvalidAttempts;
    }
    public void setNumberInvalidAttempts(short numberInvalidAttempts) {
        this.numberInvalidAttempts = numberInvalidAttempts;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(meta$$whenLastLoggedIn, whenLastLoggedIn);
        w.addField(meta$$passwordExpires, passwordExpires);
        w.addField(numberInvalidAttempts);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("whenLastLoggedIn")) {
            w.addField(meta$$whenLastLoggedIn, whenLastLoggedIn);
            return;
        }
        if (_n.equals("passwordExpires")) {
            w.addField(meta$$passwordExpires, passwordExpires);
            return;
        }
        if (_n.equals("numberInvalidAttempts")) {
            w.addField(numberInvalidAttempts);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        whenLastLoggedIn = p.readDayTime("whenLastLoggedIn", true, false, 0);
        passwordExpires = p.readDayTime("passwordExpires", true, false, 0);
        numberInvalidAttempts = p.readShort     ("numberInvalidAttempts", false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (whenLastLoggedIn == null ? 0 : whenLastLoggedIn.hashCode());
        _hash = 29 * _hash + (passwordExpires == null ? 0 : passwordExpires.hashCode());
        _hash = 29 * _hash + (int)numberInvalidAttempts;
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AuthenticationDetails))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AuthenticationDetails))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        AuthenticationDetails that = (AuthenticationDetails)_that;
        return true
        && ((whenLastLoggedIn == null && that.whenLastLoggedIn == null) || (whenLastLoggedIn != null && whenLastLoggedIn.equals(that.whenLastLoggedIn)))
        && ((passwordExpires == null && that.passwordExpires == null) || (passwordExpires != null && passwordExpires.equals(that.passwordExpires)))
        && numberInvalidAttempts == that.numberInvalidAttempts
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
    }
    // default no-argument constructor
    public AuthenticationDetails() {
    }
    
    // default all-arguments constructor
    public AuthenticationDetails(LocalDateTime whenLastLoggedIn
    , LocalDateTime passwordExpires
    , short numberInvalidAttempts
    ) {
        this.whenLastLoggedIn = whenLastLoggedIn;
        this.passwordExpires = passwordExpires;
        this.numberInvalidAttempts = numberInvalidAttempts;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == AuthenticationDetails.class) {
            return (T) new AuthenticationDetails(getWhenLastLoggedIn(), getPasswordExpires(), getNumberInvalidAttempts());
        }
        throw new IllegalArgumentException("AuthenticationDetails does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/security/AuthenticationRequest.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.security;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.AuthenticationType;
import com.arvatosystems.fortytwo.base.api.RequestParameters;


/**
     * The request to be used in the scope of the authentication dialog.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class AuthenticationRequest extends RequestParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -257816980294L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // RequestParameters.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RequestParameters.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RequestParameters.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || RequestParameters.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || RequestParameters.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return com.arvatosystems.fortytwo.base.security.AuthenticationResponse.class;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return RequestParameters.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.security.AuthenticationRequest";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.RequestParameters";
    private static final String BUNDLE = null;
    
    protected static final BinaryElementaryDataItem meta$$passwordHash = new BinaryElementaryDataItem(Visibility.DEFAULT, false, "passwordHash", Multiplicity.SCALAR, 0, 0, 0, DataCategory.BINARY,
        "ByteArray", false, 64);
    protected static final AlphanumericElementaryDataItem meta$$authenticationType$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "authenticationType$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$authenticationType = new EnumDataItem(Visibility.DEFAULT, true, "authenticationType", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "AuthenticationType", false, "AuthenticationType", null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$passwordHash;
        field$array[1] = meta$$authenticationType;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // sha-512 hashed password, salted by username !
    ByteArray passwordHash;
    // specifies the authentication type !
    AuthenticationType authenticationType;
    // auto-generated getters and setters
    public ByteArray getPasswordHash() {
        return passwordHash;
    }
    public void setPasswordHash(ByteArray passwordHash) {
        this.passwordHash = passwordHash;
    }
    public AuthenticationType getAuthenticationType() {
        return authenticationType;
    }
    public void setAuthenticationType(AuthenticationType authenticationType) {
        this.authenticationType = authenticationType;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$passwordHash, passwordHash);
        w.addField(meta$$authenticationType$token, authenticationType == null ? null : authenticationType.getToken());
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("passwordHash")) {
            w.addField(meta$$passwordHash, passwordHash);
            return;
        }
        if (_n.equals("authenticationType")) {
            w.addField(meta$$authenticationType$token, authenticationType == null ? null : authenticationType.getToken());
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        passwordHash = p.readByteArray ("passwordHash", true, 64);
        try {  // for possible EnumExceptions
        authenticationType = com.arvatosystems.fortytwo.base.data.AuthenticationType.factory(p.readString("authenticationType", false, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (authenticationType == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "authenticationType", PARTIALLY_QUALIFIED_CLASS_NAME);
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (passwordHash == null ? 0 : passwordHash.hashCode());
        _hash = 29 * _hash + (authenticationType == null ? 0 : authenticationType.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AuthenticationRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AuthenticationRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        AuthenticationRequest that = (AuthenticationRequest)_that;
        return super.equalsSub(_that)
        && ((passwordHash == null && that.passwordHash == null) || (passwordHash != null && passwordHash.contentEquals(that.passwordHash)))
        && ((authenticationType == null && that.authenticationType == null) || (authenticationType != null && authenticationType.equals(that.authenticationType)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public AuthenticationRequest() {
        super();
    }
    
    // default all-arguments constructor
    public AuthenticationRequest(ByteArray passwordHash
    , AuthenticationType authenticationType
    ) {
        super();
        this.passwordHash = passwordHash;
        this.authenticationType = authenticationType;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == AuthenticationRequest.class) {
            return (T) new AuthenticationRequest(getPasswordHash(), getAuthenticationType());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/security/AuthenticationResponse.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.security;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.User;
import com.arvatosystems.fortytwo.base.api.ServiceResponse;
import com.arvatosystems.fortytwo.base.data.Tenant;


/**
     * The response to be used in the scope of the authentication dialog.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class AuthenticationResponse extends ServiceResponse
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -48136431773L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // ServiceResponse.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return ServiceResponse.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return ServiceResponse.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || ServiceResponse.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || ServiceResponse.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return ServiceResponse.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return ServiceResponse.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.security.AuthenticationResponse";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.ServiceResponse";
    private static final String BUNDLE = null;
    
    protected static final ObjectReference meta$$userInformation = new ObjectReference(Visibility.DEFAULT, false, "userInformation", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "User", false, false, "User");
    protected static final ObjectReference meta$$userHistory = new ObjectReference(Visibility.DEFAULT, false, "userHistory", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "AuthenticationDetails", false, false, "AuthenticationDetails");
    protected static final ObjectReference meta$$allowedTenants = new ObjectReference(Visibility.DEFAULT, false, "allowedTenants", Multiplicity.LIST, 0, 0, 0, DataCategory.OBJECT,
        "Tenant", false, false, "Tenant");
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(3);
        FieldDefinition [] field$array = new FieldDefinition[3];
        field$array[0] = meta$$userInformation;
        field$array[1] = meta$$userHistory;
        field$array[2] = meta$$allowedTenants;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    User userInformation;
    AuthenticationDetails userHistory;
    List<Tenant> allowedTenants;
    // auto-generated getters and setters
    public User getUserInformation() {
        return userInformation;
    }
    public void setUserInformation(User userInformation) {
        this.userInformation = userInformation;
    }
    public AuthenticationDetails getUserHistory() {
        return userHistory;
    }
    public void setUserHistory(AuthenticationDetails userHistory) {
        this.userHistory = userHistory;
    }
    public List<Tenant> getAllowedTenants() {
        return allowedTenants;
    }
    public void setAllowedTenants(List<Tenant> allowedTenants) {
        this.allowedTenants = allowedTenants;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField((BonaPortable)userInformation);
        w.addField((BonaPortable)userHistory);
        if (allowedTenants == null) {
            w.writeNullCollection(meta$$allowedTenants);
        } else {
            w.startArray(allowedTenants.size(), 0, 0);
            for (Tenant _i : allowedTenants)
                w.addField((BonaPortable)_i);
            w.terminateArray();
        }
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("userInformation")) {
            if (userInformation == null) {
                w.writeNull(meta$$userInformation);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)userInformation);             // full / recursive object output
            } else {
                // write a specific subcomponent
                userInformation.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        if (_n.equals("userHistory")) {
            if (userHistory == null) {
                w.writeNull(meta$$userHistory);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)userHistory);             // full / recursive object output
            } else {
                // write a specific subcomponent
                userHistory.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        if (_n.equals("allowedTenants")) {
            if (allowedTenants == null) {
                w.writeNullCollection(meta$$allowedTenants);
            } else {
                if (pfc.index < 0) {
                    w.startArray(allowedTenants.size(), 0, 0);
                    for (Tenant _i : allowedTenants) {
                        if (_i == null) {
                            w.writeNull(meta$$allowedTenants);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)_i);             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            _i.foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                    w.terminateArray();
                } else {
                    if (pfc.index < allowedTenants.size()) {
                        // output single element
                        if (allowedTenants.get(pfc.index) == null) {
                            w.writeNull(meta$$allowedTenants);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)allowedTenants.get(pfc.index));             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            allowedTenants.get(pfc.index).foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                }
            }
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        userInformation = (User)p.readObject("userInformation", User.class, true, false);
        userHistory = (AuthenticationDetails)p.readObject("userHistory", AuthenticationDetails.class, true, false);
        _length = p.parseArrayStart("allowedTenants", true, 0, 0);
        if (_length < 0) {
            allowedTenants = null;
        } else {
            allowedTenants = new ArrayList<Tenant>(_length);
            for (int _i = 0; _i < _length; ++_i)
                allowedTenants.add((Tenant)p.readObject("allowedTenants", Tenant.class, true, false));
            p.parseArrayEnd();
        }
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (userInformation != null)
            userInformation.validate();  // check object
        if (userHistory != null)
            userHistory.validate();  // check object
        if (allowedTenants != null)
            for (Tenant _i : allowedTenants)
        if (_i != null)
            _i.validate();  // check object
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (userInformation == null ? 0 : userInformation.hashCode());
        _hash = 29 * _hash + (userHistory == null ? 0 : userHistory.hashCode());
        _hash = 29 * _hash + (allowedTenants == null ? 0 : allowedTenants.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AuthenticationResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AuthenticationResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        AuthenticationResponse that = (AuthenticationResponse)_that;
        return super.equalsSub(_that)
        && ((userInformation == null && that.userInformation == null) || (userInformation != null && userInformation.hasSameContentsAs(that.userInformation)))
        && ((userHistory == null && that.userHistory == null) || (userHistory != null && userHistory.hasSameContentsAs(that.userHistory)))
        && ((allowedTenants == null && that.allowedTenants == null) || (allowedTenants != null && that.allowedTenants != null && xCompareSub$allowedTenants(that)))
        ;
    }
    private boolean xCompareSub$allowedTenants(AuthenticationResponse that) {
        // both allowedTenants and that allowedTenants are known to be not null
        if (allowedTenants.size() != that.allowedTenants.size())
            return false;
        // indexed access is not optional, but sequential access will be left for later optimization
        for (int _i = 0; _i < allowedTenants.size(); ++_i)
            if (!(((allowedTenants.get(_i) == null && that.allowedTenants.get(_i) == null) || (allowedTenants.get(_i) != null && allowedTenants.get(_i).hasSameContentsAs(that.allowedTenants.get(_i))))))
                return false;
        return true;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        if (userInformation != null)
            userInformation.treeWalkString(_cvt);
        if (userHistory != null)
            userHistory.treeWalkString(_cvt);
        if (allowedTenants != null)
            for (Tenant _i : allowedTenants)
        if (_i != null)
            _i.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public AuthenticationResponse() {
        super();
    }
    
    // default all-arguments constructor
    public AuthenticationResponse(ByteArray requestId
    , String tenantId
    , Long processRef
    , int returnCode
    , String errorDetails
    , String errorMessage
    , User userInformation
    , AuthenticationDetails userHistory
    , List<Tenant> allowedTenants
    ) {
        super(requestId
        , tenantId
        , processRef
        , returnCode
        , errorDetails
        , errorMessage
        );
        this.userInformation = userInformation;
        this.userHistory = userHistory;
        this.allowedTenants = allowedTenants;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == AuthenticationResponse.class) {
            return (T) new AuthenticationResponse(getRequestId(), getTenantId(), getProcessRef(), getReturnCode(), getErrorDetails(), getErrorMessage(), getUserInformation(), getUserHistory(), getAllowedTenants());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/security/AuthorizationRequest.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.security;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.api.RequestParameters;


/**
     * The request to be used in the scope of the authorization dialog.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class AuthorizationRequest extends RequestParameters
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -102480906851L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // RequestParameters.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RequestParameters.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RequestParameters.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || RequestParameters.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || RequestParameters.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return com.arvatosystems.fortytwo.base.security.AuthorizationResponse.class;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return RequestParameters.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.security.AuthorizationRequest";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.RequestParameters";
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$userId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "userId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 16, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$tenantId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "tenantId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 10, 1, null);
    protected static final AlphanumericElementaryDataItem meta$$likePermissionName = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "likePermissionName", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 30, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$onlyPermissionType$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "onlyPermissionType$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$onlyPermissionType = new EnumDataItem(Visibility.DEFAULT, false, "onlyPermissionType", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "PermissionType", false, "PermissionType", null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(4);
        FieldDefinition [] field$array = new FieldDefinition[4];
        field$array[0] = meta$$userId;
        field$array[1] = meta$$tenantId;
        field$array[2] = meta$$likePermissionName;
        field$array[3] = meta$$onlyPermissionType;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // user ID for this request !
    String userId;
    // tenantId for which this request is intended !
    String tenantId;
    // If set, to be used as filter criteria when compiling the result list !
    String likePermissionName;
    // If set, to be used as filter criteria when compiling the result list !
    PermissionType onlyPermissionType;
    // auto-generated getters and setters
    public String getUserId() {
        return userId;
    }
    public void setUserId(String userId) {
        this.userId = userId;
    }
    public String getTenantId() {
        return tenantId;
    }
    public void setTenantId(String tenantId) {
        this.tenantId = tenantId;
    }
    public String getLikePermissionName() {
        return likePermissionName;
    }
    public void setLikePermissionName(String likePermissionName) {
        this.likePermissionName = likePermissionName;
    }
    public PermissionType getOnlyPermissionType() {
        return onlyPermissionType;
    }
    public void setOnlyPermissionType(PermissionType onlyPermissionType) {
        this.onlyPermissionType = onlyPermissionType;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.addField(meta$$userId, userId);
        w.addField(meta$$tenantId, tenantId);
        w.addField(meta$$likePermissionName, likePermissionName);
        w.addField(meta$$onlyPermissionType$token, onlyPermissionType == null ? null : onlyPermissionType.getToken());
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("userId")) {
            w.addField(meta$$userId, userId);
            return;
        }
        if (_n.equals("tenantId")) {
            w.addField(meta$$tenantId, tenantId);
            return;
        }
        if (_n.equals("likePermissionName")) {
            w.addField(meta$$likePermissionName, likePermissionName);
            return;
        }
        if (_n.equals("onlyPermissionType")) {
            w.addField(meta$$onlyPermissionType$token, onlyPermissionType == null ? null : onlyPermissionType.getToken());
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        userId = p.readString    ("userId", false, 16, true, false, false, false);
        tenantId = p.readString    ("tenantId", false, 10, true, false, false, false);
        likePermissionName = p.readString    ("likePermissionName", true, 30, true, false, false, true);
        try {  // for possible EnumExceptions
        onlyPermissionType = com.arvatosystems.fortytwo.base.security.PermissionType.factory(p.readString("onlyPermissionType", true, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (userId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "userId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (tenantId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "tenantId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (userId != null) {
            if (userId.length() > 16)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "userId.length=" + userId.length() + " > 16",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (tenantId != null) {
            if (tenantId.length() > 10)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "tenantId.length=" + tenantId.length() + " > 10",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
            if (tenantId.length() < 1)
                throw new ObjectValidationException(ObjectValidationException.TOO_SHORT,
                                                    "tenantId.length=" + tenantId.length() + " < 1",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (likePermissionName != null) {
            if (likePermissionName.length() > 30)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "likePermissionName.length=" + likePermissionName.length() + " > 30",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (userId == null ? 0 : userId.hashCode());
        _hash = 29 * _hash + (tenantId == null ? 0 : tenantId.hashCode());
        _hash = 29 * _hash + (likePermissionName == null ? 0 : likePermissionName.hashCode());
        _hash = 29 * _hash + (onlyPermissionType == null ? 0 : onlyPermissionType.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AuthorizationRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AuthorizationRequest))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        AuthorizationRequest that = (AuthorizationRequest)_that;
        return super.equalsSub(_that)
        && ((userId == null && that.userId == null) || (userId != null && userId.equals(that.userId)))
        && ((tenantId == null && that.tenantId == null) || (tenantId != null && tenantId.equals(that.tenantId)))
        && ((likePermissionName == null && that.likePermissionName == null) || (likePermissionName != null && likePermissionName.equals(that.likePermissionName)))
        && ((onlyPermissionType == null && that.onlyPermissionType == null) || (onlyPermissionType != null && onlyPermissionType.equals(that.onlyPermissionType)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        userId = _cvt.convert(userId, meta$$userId);
        tenantId = _cvt.convert(tenantId, meta$$tenantId);
        likePermissionName = _cvt.convert(likePermissionName, meta$$likePermissionName);
    }
    // default no-argument constructor
    public AuthorizationRequest() {
        super();
    }
    
    // default all-arguments constructor
    public AuthorizationRequest(String userId
    , String tenantId
    , String likePermissionName
    , PermissionType onlyPermissionType
    ) {
        super();
        this.userId = userId;
        this.tenantId = tenantId;
        this.likePermissionName = likePermissionName;
        this.onlyPermissionType = onlyPermissionType;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == AuthorizationRequest.class) {
            return (T) new AuthorizationRequest(getUserId(), getTenantId(), getLikePermissionName(), getOnlyPermissionType());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/security/AuthorizationResponse.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.security;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.api.ServiceResponse;


/**
     * The response to be used in the scope of the authorization dialog.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class AuthorizationResponse extends ServiceResponse
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 266156118752L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // ServiceResponse.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return ServiceResponse.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return ServiceResponse.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || ServiceResponse.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || ServiceResponse.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return ServiceResponse.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return ServiceResponse.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.security.AuthorizationResponse";
    private static final String REVISION = null;
    private static final String PARENT = "base.api.ServiceResponse";
    private static final String BUNDLE = null;
    
    protected static final ObjectReference meta$$resultingPermissions = new ObjectReference(Visibility.DEFAULT, false, "resultingPermissions", Multiplicity.SET, 0, 0, 0, DataCategory.OBJECT,
        "Permission", false, false, "Permission");
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$resultingPermissions;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // explicit permissions (list contains no duplicates) !
    Set<Permission> resultingPermissions;
    // auto-generated getters and setters
    public Set<Permission> getResultingPermissions() {
        return resultingPermissions;
    }
    public void setResultingPermissions(Set<Permission> resultingPermissions) {
        this.resultingPermissions = resultingPermissions;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (resultingPermissions == null) {
            w.writeNullCollection(meta$$resultingPermissions);
        } else {
            w.startArray(resultingPermissions.size(), 0, 0);
            for (Permission _i : resultingPermissions)
                w.addField((BonaPortable)_i);
            w.terminateArray();
        }
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("resultingPermissions")) {
            if (resultingPermissions == null) {
                w.writeNullCollection(meta$$resultingPermissions);
            } else {
                w.startArray(resultingPermissions.size(), 0, 0);
                for (Permission _i : resultingPermissions) {
                    if (_i == null) {
                        w.writeNull(meta$$resultingPermissions);
                    } else if (pfc.getComponent() == null) {
                        w.addField((BonaPortable)_i);             // full / recursive object output
                    } else {
                        // write a specific subcomponent
                        _i.foldedOutput(w, pfc.getComponent());   // recurse specific field
                    }
                }
                w.terminateArray();
            }
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        _length = p.parseArrayStart("resultingPermissions", true, 0, 0);
        if (_length < 0) {
            resultingPermissions = null;
        } else {
            resultingPermissions = new HashSet<Permission>(_length);
            for (int _i = 0; _i < _length; ++_i)
                resultingPermissions.add((Permission)p.readObject("resultingPermissions", Permission.class, true, false));
            p.parseArrayEnd();
        }
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (resultingPermissions != null)
            for (Permission _i : resultingPermissions)
        if (_i != null)
            _i.validate();  // check object
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (resultingPermissions == null ? 0 : resultingPermissions.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AuthorizationResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AuthorizationResponse))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        AuthorizationResponse that = (AuthorizationResponse)_that;
        return super.equalsSub(_that)
        && ((resultingPermissions == null && that.resultingPermissions == null) || (resultingPermissions != null && that.resultingPermissions != null && xCompareSub$resultingPermissions(that)))
        ;
    }
    private boolean xCompareSub$resultingPermissions(AuthorizationResponse that) {
        // both resultingPermissions and that resultingPermissions are known to be not null
        if (resultingPermissions.size() != that.resultingPermissions.size())
            return false;
        return resultingPermissions.equals(that.resultingPermissions);
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        if (resultingPermissions != null)
            for (Permission _i : resultingPermissions)
        if (_i != null)
            _i.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public AuthorizationResponse() {
        super();
    }
    
    // default all-arguments constructor
    public AuthorizationResponse(ByteArray requestId
    , String tenantId
    , Long processRef
    , int returnCode
    , String errorDetails
    , String errorMessage
    , Set<Permission> resultingPermissions
    ) {
        super(requestId
        , tenantId
        , processRef
        , returnCode
        , errorDetails
        , errorMessage
        );
        this.resultingPermissions = resultingPermissions;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == AuthorizationResponse.class) {
            return (T) new AuthorizationResponse(getRequestId(), getTenantId(), getProcessRef(), getReturnCode(), getErrorDetails(), getErrorMessage(), getResultingPermissions());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/security/Permission.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.security;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class Permission extends PermissionRef
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 443011976581L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        map.putIfAbsent("tenantRef.noupdate", "");
        map.putIfAbsent("permissionId.noupdate", "");
        // PermissionRef.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return PermissionRef.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return PermissionRef.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || PermissionRef.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || PermissionRef.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return PermissionRef.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return PermissionRef.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.security.Permission";
    private static final String REVISION = null;
    private static final String PARENT = "base.security.PermissionRef";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$tenantRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "tenantRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$permissionId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "permissionId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 64, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$permissionType$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "permissionType$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$permissionType = new EnumDataItem(Visibility.DEFAULT, true, "permissionType", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "PermissionType", false, "PermissionType", null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(3);
        FieldDefinition [] field$array = new FieldDefinition[3];
        field$array[0] = meta$$tenantRef;
        field$array[1] = meta$$permissionId;
        field$array[2] = meta$$permissionType;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 87;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // references a specific tenant or the "GLOBAL" tenant for predefined (standard) permissions !
    @com.arvatosystems.fortytwo.base.NotUpdatable
    Long tenantRef;
    // a displayable name of the permission !
    @com.arvatosystems.fortytwo.base.NotUpdatable
    String permissionId;
    // to which part of the system the permission relates to, essential to keep lists manageable !
    PermissionType permissionType;
    // auto-generated getters and setters
    public Long getTenantRef() {
        return tenantRef;
    }
    public void setTenantRef(Long tenantRef) {
        this.tenantRef = tenantRef;
    }
    public String getPermissionId() {
        return permissionId;
    }
    public void setPermissionId(String permissionId) {
        this.permissionId = permissionId;
    }
    public PermissionType getPermissionType() {
        return permissionType;
    }
    public void setPermissionType(PermissionType permissionType) {
        this.permissionType = permissionType;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
        w.addField(meta$$permissionId, permissionId);
        w.addField(meta$$permissionType$token, permissionType == null ? null : permissionType.getToken());
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("tenantRef")) {
            if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
            return;
        }
        if (_n.equals("permissionId")) {
            w.addField(meta$$permissionId, permissionId);
            return;
        }
        if (_n.equals("permissionType")) {
            w.addField(meta$$permissionType$token, permissionType == null ? null : permissionType.getToken());
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        tenantRef = p.readLong      ("tenantRef", false, false);
        permissionId = p.readString    ("permissionId", false, 64, true, false, false, false);
        try {  // for possible EnumExceptions
        permissionType = com.arvatosystems.fortytwo.base.security.PermissionType.factory(p.readString("permissionType", false, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (tenantRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "tenantRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (permissionId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "permissionId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (permissionType == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "permissionType", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (permissionId != null) {
            if (permissionId.length() > 64)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "permissionId.length=" + permissionId.length() + " > 64",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (tenantRef == null ? 0 : tenantRef.hashCode());
        _hash = 29 * _hash + (permissionId == null ? 0 : permissionId.hashCode());
        _hash = 29 * _hash + (permissionType == null ? 0 : permissionType.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Permission))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Permission))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        Permission that = (Permission)_that;
        return super.equalsSub(_that)
        && ((tenantRef == null && that.tenantRef == null) || (tenantRef != null && tenantRef.equals(that.tenantRef)))
        && ((permissionId == null && that.permissionId == null) || (permissionId != null && permissionId.equals(that.permissionId)))
        && ((permissionType == null && that.permissionType == null) || (permissionType != null && permissionType.equals(that.permissionType)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        permissionId = _cvt.convert(permissionId, meta$$permissionId);
    }
    // default no-argument constructor
    public Permission() {
        super();
    }
    
    // default all-arguments constructor
    public Permission(Long objectRef
    , Long tenantRef
    , String permissionId
    , PermissionType permissionType
    ) {
        super(objectRef
        );
        this.tenantRef = tenantRef;
        this.permissionId = permissionId;
        this.permissionType = permissionType;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Permission.class) {
            return (T) new Permission(getObjectRef(), getTenantRef(), getPermissionId(), getPermissionType());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/security/PermissionKey.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.security;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public final class PermissionKey extends PermissionRef
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 552093341506L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // PermissionRef.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return PermissionRef.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return PermissionRef.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || PermissionRef.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || PermissionRef.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return PermissionRef.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return PermissionRef.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.security.PermissionKey";
    private static final String REVISION = null;
    private static final String PARENT = "base.security.PermissionRef";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$tenantRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "tenantRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$permissionId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "permissionId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 64, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$tenantRef;
        field$array[1] = meta$$permissionId;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // references a specific tenant or the "GLOBAL" tenant for predefined (standard) permissions !
    Long tenantRef;
    // a displayable name of the permission !
    String permissionId;
    // auto-generated getters and setters
    public Long getTenantRef() {
        return tenantRef;
    }
    public void setTenantRef(Long tenantRef) {
        this.tenantRef = tenantRef;
    }
    public String getPermissionId() {
        return permissionId;
    }
    public void setPermissionId(String permissionId) {
        this.permissionId = permissionId;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
        w.addField(meta$$permissionId, permissionId);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("tenantRef")) {
            if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
            return;
        }
        if (_n.equals("permissionId")) {
            w.addField(meta$$permissionId, permissionId);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        tenantRef = p.readLong      ("tenantRef", false, false);
        permissionId = p.readString    ("permissionId", false, 64, true, false, false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (tenantRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "tenantRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (permissionId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "permissionId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (permissionId != null) {
            if (permissionId.length() > 64)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "permissionId.length=" + permissionId.length() + " > 64",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (tenantRef == null ? 0 : tenantRef.hashCode());
        _hash = 29 * _hash + (permissionId == null ? 0 : permissionId.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof PermissionKey))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof PermissionKey))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        PermissionKey that = (PermissionKey)_that;
        return super.equalsSub(_that)
        && ((tenantRef == null && that.tenantRef == null) || (tenantRef != null && tenantRef.equals(that.tenantRef)))
        && ((permissionId == null && that.permissionId == null) || (permissionId != null && permissionId.equals(that.permissionId)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        permissionId = _cvt.convert(permissionId, meta$$permissionId);
    }
    // default no-argument constructor
    public PermissionKey() {
        super();
    }
    
    // default all-arguments constructor
    public PermissionKey(Long objectRef
    , Long tenantRef
    , String permissionId
    ) {
        super(objectRef
        );
        this.tenantRef = tenantRef;
        this.permissionId = permissionId;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == PermissionKey.class) {
            return (T) new PermissionKey(getObjectRef(), getTenantRef(), getPermissionId());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/security/PermissionRef.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.security;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;


/**
     * The class representing a permission as it might be referenced by roles.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class PermissionRef extends Ref
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 275066010949L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // Ref.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return Ref.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return Ref.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.security.PermissionRef";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.Ref";
    private static final String BUNDLE = null;
    
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(0);
        FieldDefinition [] field$array = new FieldDefinition[0];
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // auto-generated getters and setters
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof PermissionRef))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof PermissionRef))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        PermissionRef that = (PermissionRef)_that;
        return super.equalsSub(_that)
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public PermissionRef() {
        super();
    }
    
    // default all-arguments constructor
    public PermissionRef(Long objectRef
    ) {
        super(objectRef
        );
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == PermissionRef.class) {
            return (T) new PermissionRef(getObjectRef());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/security/PermissionType.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.security;

import de.jpaw.util.EnumException;
import de.jpaw.enums.TokenizableEnum;


public enum PermissionType implements TokenizableEnum {
    FRONTEND("U"), BACKEND("B"), REPORTING("R");

    // constructor by token
    private String _token;
    private PermissionType(String _token) {
        this._token = _token;
    }

    // token retrieval
    @Override
    public String getToken() {
        return _token;
    }

    // static factory method.
    public static PermissionType factory(String _token) throws EnumException {
        if (_token != null) {
            if (_token.equals("U")) return FRONTEND;
            if (_token.equals("B")) return BACKEND;
            if (_token.equals("R")) return REPORTING;
            throw new EnumException(EnumException.INVALID_NUM, _token);
        }
        return null;
    }

    public static PermissionType valueOf(Integer ordinal) throws EnumException {
        if (ordinal != null) {
            switch (ordinal.intValue()) {
            case 0: return FRONTEND;
            case 1: return BACKEND;
            case 2: return REPORTING;
            default: throw new EnumException(EnumException.INVALID_NUM, ordinal.toString());
            }
        }
        return null;
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/security/Role.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.security;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class Role extends RoleRef
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -109773359771L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        map.putIfAbsent("tenantRef.noupdate", "");
        map.putIfAbsent("roleId.noupdate", "");
        // RoleRef.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RoleRef.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RoleRef.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || RoleRef.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || RoleRef.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return RoleRef.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return RoleRef.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.security.Role";
    private static final String REVISION = null;
    private static final String PARENT = "base.security.RoleRef";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$tenantRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "tenantRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$roleId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "roleId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 32, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$name = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "name", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 80, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(3);
        FieldDefinition [] field$array = new FieldDefinition[3];
        field$array[0] = meta$$tenantRef;
        field$array[1] = meta$$roleId;
        field$array[2] = meta$$name;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 86;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // references a specific tenant or the "GLOBAL" tenant !
    @com.arvatosystems.fortytwo.base.NotUpdatable
    Long tenantRef;
    // tenant Id in this special case not implicit !
    @com.arvatosystems.fortytwo.base.NotUpdatable
    String roleId;
    // role name !
    String name;
    // auto-generated getters and setters
    public Long getTenantRef() {
        return tenantRef;
    }
    public void setTenantRef(Long tenantRef) {
        this.tenantRef = tenantRef;
    }
    public String getRoleId() {
        return roleId;
    }
    public void setRoleId(String roleId) {
        this.roleId = roleId;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
        w.addField(meta$$roleId, roleId);
        w.addField(meta$$name, name);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("tenantRef")) {
            if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
            return;
        }
        if (_n.equals("roleId")) {
            w.addField(meta$$roleId, roleId);
            return;
        }
        if (_n.equals("name")) {
            w.addField(meta$$name, name);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        tenantRef = p.readLong      ("tenantRef", false, false);
        roleId = p.readString    ("roleId", false, 32, true, false, false, false);
        name = p.readString    ("name", false, 80, true, false, false, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (tenantRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "tenantRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (roleId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "roleId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (name == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "name", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (roleId != null) {
            if (roleId.length() > 32)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "roleId.length=" + roleId.length() + " > 32",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (name != null) {
            if (name.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "name.length=" + name.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (tenantRef == null ? 0 : tenantRef.hashCode());
        _hash = 29 * _hash + (roleId == null ? 0 : roleId.hashCode());
        _hash = 29 * _hash + (name == null ? 0 : name.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Role))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Role))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        Role that = (Role)_that;
        return super.equalsSub(_that)
        && ((tenantRef == null && that.tenantRef == null) || (tenantRef != null && tenantRef.equals(that.tenantRef)))
        && ((roleId == null && that.roleId == null) || (roleId != null && roleId.equals(that.roleId)))
        && ((name == null && that.name == null) || (name != null && name.equals(that.name)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        roleId = _cvt.convert(roleId, meta$$roleId);
        name = _cvt.convert(name, meta$$name);
    }
    // default no-argument constructor
    public Role() {
        super();
    }
    
    // default all-arguments constructor
    public Role(Long objectRef
    , Long tenantRef
    , String roleId
    , String name
    ) {
        super(objectRef
        );
        this.tenantRef = tenantRef;
        this.roleId = roleId;
        this.name = name;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Role.class) {
            return (T) new Role(getObjectRef(), getTenantRef(), getRoleId(), getName());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/security/RoleKey.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.security;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;



@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public final class RoleKey extends RoleRef
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -223848191080L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // RoleRef.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RoleRef.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return RoleRef.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || RoleRef.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || RoleRef.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return RoleRef.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return RoleRef.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.security.RoleKey";
    private static final String REVISION = null;
    private static final String PARENT = "base.security.RoleRef";
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$tenantRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "tenantRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$roleId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "roleId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 32, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$tenantRef;
        field$array[1] = meta$$roleId;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // references a specific tenant or the "GLOBAL" tenant !
    Long tenantRef;
    // tenant Id in this special case not implicit !
    String roleId;
    // auto-generated getters and setters
    public Long getTenantRef() {
        return tenantRef;
    }
    public void setTenantRef(Long tenantRef) {
        this.tenantRef = tenantRef;
    }
    public String getRoleId() {
        return roleId;
    }
    public void setRoleId(String roleId) {
        this.roleId = roleId;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
        w.addField(meta$$roleId, roleId);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("tenantRef")) {
            if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
            return;
        }
        if (_n.equals("roleId")) {
            w.addField(meta$$roleId, roleId);
            return;
        }
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        tenantRef = p.readLong      ("tenantRef", false, false);
        roleId = p.readString    ("roleId", false, 32, true, false, false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
        if (tenantRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "tenantRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (roleId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "roleId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (roleId != null) {
            if (roleId.length() > 32)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "roleId.length=" + roleId.length() + " > 32",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        _hash = 29 * _hash + (tenantRef == null ? 0 : tenantRef.hashCode());
        _hash = 29 * _hash + (roleId == null ? 0 : roleId.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof RoleKey))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof RoleKey))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        RoleKey that = (RoleKey)_that;
        return super.equalsSub(_that)
        && ((tenantRef == null && that.tenantRef == null) || (tenantRef != null && tenantRef.equals(that.tenantRef)))
        && ((roleId == null && that.roleId == null) || (roleId != null && roleId.equals(that.roleId)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
        roleId = _cvt.convert(roleId, meta$$roleId);
    }
    // default no-argument constructor
    public RoleKey() {
        super();
    }
    
    // default all-arguments constructor
    public RoleKey(Long objectRef
    , Long tenantRef
    , String roleId
    ) {
        super(objectRef
        );
        this.tenantRef = tenantRef;
        this.roleId = roleId;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == RoleKey.class) {
            return (T) new RoleKey(getObjectRef(), getTenantRef(), getRoleId());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/security/RoleRef.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.security;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;
import com.arvatosystems.fortytwo.base.data.Ref;


/**
     * The class representing a role a user has when interacting with the system.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class RoleRef extends Ref
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -112904755344L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        // Ref.class$fillProperties(map); // done anyway by static initializer of parent
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        if (property$Map.containsKey(id))
            return property$Map.get(id);
        else
            return Ref.class$Property(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id) || Ref.class$hasProperty(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return Ref.class$returns();
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return Ref.class$pk();
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.security.RoleRef";
    private static final String REVISION = null;
    private static final String PARENT = "base.data.Ref";
    private static final String BUNDLE = null;
    
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(0);
        FieldDefinition [] field$array = new FieldDefinition[0];
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(true);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // auto-generated getters and setters
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        // recursive call of superclass first
        super.serializeSub(w);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        // not found
        super.foldedOutput(w, pfc);
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        super.deserialize(p);
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        super.validate();
    }
    @Override
    public int hashCode() {
        int _hash = super.hashCode();
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof RoleRef))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof RoleRef))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    @Override
    protected boolean equalsSub(BonaPortable _that) {
        RoleRef that = (RoleRef)_that;
        return super.equalsSub(_that)
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        super.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public RoleRef() {
        super();
    }
    
    // default all-arguments constructor
    public RoleRef(Long objectRef
    ) {
        super(objectRef
        );
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == RoleRef.class) {
            return (T) new RoleRef(getObjectRef());
        }
        return super.copyAs(desiredSuperType);
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/security/RoleToPermission.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.security;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/**
     * The relationship between roles and permissions.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class RoleToPermission
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 1101079153L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.security.RoleToPermission";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$tenantRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "tenantRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$roleRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "roleRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$permissionId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "permissionId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 64, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(3);
        FieldDefinition [] field$array = new FieldDefinition[3];
        field$array[0] = meta$$tenantRef;
        field$array[1] = meta$$roleRef;
        field$array[2] = meta$$permissionId;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    // specific tenant for tenant !
    Long tenantRef;
    Long roleRef;
    String permissionId;
    // auto-generated getters and setters
    public Long getTenantRef() {
        return tenantRef;
    }
    public void setTenantRef(Long tenantRef) {
        this.tenantRef = tenantRef;
    }
    public Long getRoleRef() {
        return roleRef;
    }
    public void setRoleRef(Long roleRef) {
        this.roleRef = roleRef;
    }
    public String getPermissionId() {
        return permissionId;
    }
    public void setPermissionId(String permissionId) {
        this.permissionId = permissionId;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
        if (roleRef == null) w.writeNull(meta$$roleRef); else w.addField(roleRef);
        w.addField(meta$$permissionId, permissionId);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("tenantRef")) {
            if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
            return;
        }
        if (_n.equals("roleRef")) {
            if (roleRef == null) w.writeNull(meta$$roleRef); else w.addField(roleRef);
            return;
        }
        if (_n.equals("permissionId")) {
            w.addField(meta$$permissionId, permissionId);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        tenantRef = p.readLong      ("tenantRef", false, false);
        roleRef = p.readLong      ("roleRef", false, false);
        permissionId = p.readString    ("permissionId", false, 64, true, false, false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (tenantRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "tenantRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (roleRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "roleRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (permissionId == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "permissionId", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (permissionId != null) {
            if (permissionId.length() > 64)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "permissionId.length=" + permissionId.length() + " > 64",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (tenantRef == null ? 0 : tenantRef.hashCode());
        _hash = 29 * _hash + (roleRef == null ? 0 : roleRef.hashCode());
        _hash = 29 * _hash + (permissionId == null ? 0 : permissionId.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof RoleToPermission))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof RoleToPermission))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        RoleToPermission that = (RoleToPermission)_that;
        return true
        && ((tenantRef == null && that.tenantRef == null) || (tenantRef != null && tenantRef.equals(that.tenantRef)))
        && ((roleRef == null && that.roleRef == null) || (roleRef != null && roleRef.equals(that.roleRef)))
        && ((permissionId == null && that.permissionId == null) || (permissionId != null && permissionId.equals(that.permissionId)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        permissionId = _cvt.convert(permissionId, meta$$permissionId);
    }
    // default no-argument constructor
    public RoleToPermission() {
    }
    
    // default all-arguments constructor
    public RoleToPermission(Long tenantRef
    , Long roleRef
    , String permissionId
    ) {
        this.tenantRef = tenantRef;
        this.roleRef = roleRef;
        this.permissionId = permissionId;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == RoleToPermission.class) {
            return (T) new RoleToPermission(getTenantRef(), getRoleRef(), getPermissionId());
        }
        throw new IllegalArgumentException("RoleToPermission does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/security/UserTenantRole.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package com.arvatosystems.fortytwo.base.security;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlAnyElement;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;


/**
     * The relationship between users, roles and tenants.
     */

@XmlRootElement
@XmlAccessorType(XmlAccessType.PROPERTY)
public class UserTenantRole
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 1722471132L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "base.security.UserTenantRole";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$userRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "userRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$tenantRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "tenantRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$roleRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "roleRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(3);
        FieldDefinition [] field$array = new FieldDefinition[3];
        field$array[0] = meta$$userRef;
        field$array[1] = meta$$tenantRef;
        field$array[2] = meta$$roleRef;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    Long userRef;
    Long tenantRef;
    Long roleRef;
    // auto-generated getters and setters
    public Long getUserRef() {
        return userRef;
    }
    public void setUserRef(Long userRef) {
        this.userRef = userRef;
    }
    public Long getTenantRef() {
        return tenantRef;
    }
    public void setTenantRef(Long tenantRef) {
        this.tenantRef = tenantRef;
    }
    public Long getRoleRef() {
        return roleRef;
    }
    public void setRoleRef(Long roleRef) {
        this.roleRef = roleRef;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        if (userRef == null) w.writeNull(meta$$userRef); else w.addField(userRef);
        if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
        if (roleRef == null) w.writeNull(meta$$roleRef); else w.addField(roleRef);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("userRef")) {
            if (userRef == null) w.writeNull(meta$$userRef); else w.addField(userRef);
            return;
        }
        if (_n.equals("tenantRef")) {
            if (tenantRef == null) w.writeNull(meta$$tenantRef); else w.addField(tenantRef);
            return;
        }
        if (_n.equals("roleRef")) {
            if (roleRef == null) w.writeNull(meta$$roleRef); else w.addField(roleRef);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        userRef = p.readLong      ("userRef", false, false);
        tenantRef = p.readLong      ("tenantRef", false, false);
        roleRef = p.readLong      ("roleRef", false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (userRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "userRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (tenantRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "tenantRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (roleRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "roleRef", PARTIALLY_QUALIFIED_CLASS_NAME);
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (userRef == null ? 0 : userRef.hashCode());
        _hash = 29 * _hash + (tenantRef == null ? 0 : tenantRef.hashCode());
        _hash = 29 * _hash + (roleRef == null ? 0 : roleRef.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof UserTenantRole))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof UserTenantRole))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        UserTenantRole that = (UserTenantRole)_that;
        return true
        && ((userRef == null && that.userRef == null) || (userRef != null && userRef.equals(that.userRef)))
        && ((tenantRef == null && that.tenantRef == null) || (tenantRef != null && tenantRef.equals(that.tenantRef)))
        && ((roleRef == null && that.roleRef == null) || (roleRef != null && roleRef.equals(that.roleRef)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
    }
    // default no-argument constructor
    public UserTenantRole() {
    }
    
    // default all-arguments constructor
    public UserTenantRole(Long userRef
    , Long tenantRef
    , Long roleRef
    ) {
        this.userRef = userRef;
        this.tenantRef = tenantRef;
        this.roleRef = roleRef;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == UserTenantRole.class) {
            return (T) new UserTenantRole(getUserRef(), getTenantRef(), getRoleRef());
        }
        throw new IllegalArgumentException("UserTenantRole does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/com/arvatosystems/fortytwo/base/security/package-info.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

@XmlJavaTypeAdapters({
    @XmlJavaTypeAdapter(type=LocalDate.class,       value=LocalDateAdapter.class),
    @XmlJavaTypeAdapter(type=LocalTime.class,       value=LocalTimeAdapter.class),
    @XmlJavaTypeAdapter(type=LocalDateTime.class,   value=LocalDateTimeAdapter.class),
    @XmlJavaTypeAdapter(type=ByteArray.class,       value=ByteArrayAdapter.class)
})
package com.arvatosystems.fortytwo.base.security;

import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapters;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import org.joda.time.LocalTime;
import de.jpaw.util.ByteArray;

import de.jpaw.xml.jaxb.ByteArrayAdapter;
import de.jpaw.xml.jaxb.LocalDateAdapter;
import de.jpaw.xml.jaxb.LocalTimeAdapter;
import de.jpaw.xml.jaxb.LocalDateTimeAdapter;
, DEFAULT_OUTPUTresources/com/arvatosystems/fortytwo/app/crud/jaxb.index=CrudRequest
CrudResponse
CrudNaturalKeyRequest
CrudNaturalKeyResponse
ReadAllRequest
DataWithTracking
ReadAllResponse
RefResolverRequest
RefResolverResponse
, DEFAULT_OUTPUTresources/com/arvatosystems/fortytwo/app/search/jaxb.index=SearchOption
SortColumn
NullFilter
BooleanFilter
UnicodeFilter
AsciiFilter
IntFilter
LongFilter
NumericFilter
DayFilter
TimestampFilter
EnumFilter
SearchRequest
, DEFAULT_OUTPUTresources/com/arvatosystems/fortytwo/base/api/jaxb.index=ServiceRequestHeader
JmsServiceRequestHeader
AuthX500DistinguishedName
AuthSAML
AuthFortytwo
ServiceRequest
ServiceResponse
SessionParameters
KeyValuePair
OutputSessionParameters
PingRequest
PingResponse
BatchRequest
ErrorRequest
, DEFAULT_OUTPUTresources/com/arvatosystems/fortytwo/base/api/ping/jaxb.index=BpmPingRequest
, DEFAULT_OUTPUTresources/com/arvatosystems/fortytwo/base/conf/jaxb.index=ConfigRef
ConfigKey
ConfigDTO
ReadConfigWithDefaultsRequest
ReadConfigWithDefaultsResponse
ReadConfigMultipleEntriesRequest
ReadConfigMultipleEntriesResponse
, DEFAULT_OUTPUTresources/com/arvatosystems/fortytwo/base/core/jaxb.index=Integer_
Long_
Boolean_
Day_
Timestamp_
Double_
Ascii_
Unicode_
Uppercase_
Decimal_
Enum_
, DEFAULT_OUTPUTresources/com/arvatosystems/fortytwo/base/data/jaxb.index=NoTracking
WriteTracking
FullTracking
FullTrackingWithActiveColumn
FullTrackingWithActiveColumnAndVersion
FullTrackingWithVersion
AdditionalHistoryTableColumns
Ref
UserRef
UserKey
User
UserStatus
Password
TenantRef
TenantKey
Tenant
Customization
EntityCustomizationEntry
RequestHandlerCustomizationEntry
TranslationKey
TranslationDTO
, DEFAULT_OUTPUTresources/com/arvatosystems/fortytwo/base/input/jaxb.index=ImportRef
ImportKey
ImportConfigDto
ImportPreConfig
ImportConfigCrudRequest
ImportConfigSearchRequest
ImportRequest
, DEFAULT_OUTPUTresources/com/arvatosystems/fortytwo/base/messaging/jaxb.index=DocumentCreatedCallbackRequest
RequestHandlerConfigRef
RequestHandlerConfigKey
RequestHandlerConfigDTO
SinkRef
Sink
SinkCreatedResponse
FileDownloadRequest
FileDownloadResponse
FileUploadRequest
SourceRef
Source
DataSinkRef
DataSinkKey
DataSinkFilterProps
DataSink
DemoRecord
, DEFAULT_OUTPUTresources/com/arvatosystems/fortytwo/base/security/jaxb.index=AuthenticationRequest
AuthenticationDetails
AuthenticationResponse
AuthorizationRequest
AuthorizationResponse
RoleRef
RoleKey
Role
RoleToPermission
UserTenantRole
PermissionRef
PermissionKey
Permission
}