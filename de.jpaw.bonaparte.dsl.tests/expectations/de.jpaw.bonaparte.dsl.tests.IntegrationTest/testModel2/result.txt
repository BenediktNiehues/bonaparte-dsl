{DEFAULT_OUTPUTdebug/money.info==== PACKAGE money (ROOT) ===
CLASS PriceWithTax:  abstract=false final=false
    //
    FIELD amount: local required = optional, defaults: req=null)
    FIELD componentAmounts: local required = required, defaults: req=null)

, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/money/PriceWithTax.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.money;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



public class PriceWithTax
  implements BonaPortable, Externalizable, de.jpaw.money.MoneyGetter, de.jpaw.money.MoneySetter {
    private static final long serialVersionUID = -1758936566L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "money.PriceWithTax";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$amount = new NumericElementaryDataItem(Visibility.DEFAULT, false, "amount", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "BigDecimal", false, true, 18, 6, false, false);
    protected static final NumericElementaryDataItem meta$$componentAmounts = new NumericElementaryDataItem(Visibility.DEFAULT, true, "componentAmounts", Multiplicity.LIST, 0, 0, 0, DataCategory.NUMERIC,
        "BigDecimal", false, true, 18, 6, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$amount;
        field$array[1] = meta$$componentAmounts;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    BigDecimal amount;
    List<BigDecimal> componentAmounts;
    // auto-generated getters and setters
    public BigDecimal getAmount() {
        return amount;
    }
    public void setAmount(BigDecimal amount) {
        this.amount = amount;
    }
    public List<BigDecimal> getComponentAmounts() {
        return componentAmounts;
    }
    public void setComponentAmounts(List<BigDecimal> componentAmounts) {
        this.componentAmounts = componentAmounts;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(meta$$amount, amount);
        if (componentAmounts == null) {
            w.writeNullCollection(meta$$componentAmounts);
        } else {
            w.startArray(componentAmounts.size(), 0, 0);
            for (BigDecimal _i : componentAmounts)
                w.addField(meta$$componentAmounts, _i);
            w.terminateArray();
        }
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("amount")) {
            w.addField(meta$$amount, amount);
            return;
        }
        if (_n.equals("componentAmounts")) {
            if (componentAmounts == null) {
                w.writeNullCollection(meta$$componentAmounts);
            } else {
                if (pfc.index < 0) {
                    w.startArray(componentAmounts.size(), 0, 0);
                    for (BigDecimal _i : componentAmounts) {
                        w.addField(meta$$componentAmounts, _i);
                    }
                    w.terminateArray();
                } else {
                    if (pfc.index < componentAmounts.size()) {
                        // output single element
                        w.addField(meta$$componentAmounts, componentAmounts.get(pfc.index));
                    }
                }
            }
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        amount = p.readBigDecimal("amount", true, 18, 6, true, false, false);
        _length = p.parseArrayStart("componentAmounts", false, 0, 0);
        if (_length < 0) {
            componentAmounts = null;
        } else {
            componentAmounts = new ArrayList<BigDecimal>(_length);
            for (int _i = 0; _i < _length; ++_i)
                componentAmounts.add(p.readBigDecimal("componentAmounts", false, 18, 6, true, false, false));
            p.parseArrayEnd();
        }
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (componentAmounts == null)   // initial check for aggregate type itself, it may not be NULL
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "componentAmounts", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (componentAmounts != null)
            for (BigDecimal _i : componentAmounts)
        if (_i == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "_i", PARTIALLY_QUALIFIED_CLASS_NAME);
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + BigDecimalTools.hashCode(amount, 6);
        _hash = 29 * _hash + (componentAmounts == null ? 0 : componentAmounts.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof PriceWithTax))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof PriceWithTax))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        PriceWithTax that = (PriceWithTax)_that;
        return true
        && ((amount == null && that.amount == null) || (amount != null && BigDecimalTools.equals(amount, 6, that.amount, 6)))
        && ((componentAmounts == null && that.componentAmounts == null) || (componentAmounts != null && that.componentAmounts != null && xCompareSub$componentAmounts(that)))
        ;
    }
    private boolean xCompareSub$componentAmounts(PriceWithTax that) {
        // both componentAmounts and that componentAmounts are known to be not null
        if (componentAmounts.size() != that.componentAmounts.size())
            return false;
        // indexed access is not optional, but sequential access will be left for later optimization
        for (int _i = 0; _i < componentAmounts.size(); ++_i)
            if (!(((componentAmounts.get(_i) == null && that.componentAmounts.get(_i) == null) || (componentAmounts.get(_i) != null && BigDecimalTools.equals(componentAmounts.get(_i), 6, that.componentAmounts.get(_i), 6)))))
                return false;
        return true;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
    }
    // default no-argument constructor
    public PriceWithTax() {
    }
    
    // default all-arguments constructor
    public PriceWithTax(BigDecimal amount
    , List<BigDecimal> componentAmounts
    ) {
        this.amount = amount;
        this.componentAmounts = componentAmounts;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == PriceWithTax.class) {
            return (T) new PriceWithTax(getAmount(), getComponentAmounts());
        }
        throw new IllegalArgumentException("PriceWithTax does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/money/package-info.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

package de.jpaw.bonaparte.pojos.money;
}