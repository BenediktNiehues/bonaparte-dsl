{DEFAULT_OUTPUTdebug/eec.test.info==== PACKAGE eec.test (ROOT) ===
CLASS Parent:  abstract=false final=false
    //
    FIELD key: local required = required, defaults: req=null)
    FIELD text: defaults: req=null)

CLASS Item:  abstract=false final=false
    //
    FIELD dummyRef: local required = required, defaults: req=null)
    FIELD itemNo: defaults: req=null)
    FIELD itemText: defaults: req=null)

CLASS EmbedEC:  abstract=false final=true
    //
    FIELD value: defaults: req=null)
    FIELD text: defaults: req=null)

CLASS TestObject:  abstract=false final=false
    //
    FIELD myKey: defaults: req=null)
    FIELD parentRef: local required = required, defaults: req=null)
    FIELD name: defaults: req=null)
    FIELD prices: defaults: req=null)
    FIELD items: defaults: req=null)
    FIELD embeddedList: defaults: req=null)
    FIELD embeddedMap: defaults: req=null)

, DEFAULT_OUTPUTdebug/embeddables.info==== PACKAGE embeddables (ROOT) ===
CLASS Address:  abstract=false final=true
    //
    FIELD street: local required = required, defaults: req=null)
    FIELD zipCode: local required = optional, defaults: req=null)
    FIELD city: defaults: req=null)

CLASS Add2:  abstract=false final=true
    //
    FIELD data1: local required = required, defaults: req=null)
    FIELD props: defaults: req=null)

CLASS Person:  abstract=false final=false
    //
    FIELD personKey: defaults: req=null)
    FIELD name: defaults: req=null)
    FIELD homeAddress: defaults: req=null)
    FIELD addressWork: defaults: req=null)
    FIELD extra: defaults: req=null)
    FIELD addressLines: defaults: req=null)
    FIELD evenMore: defaults: req=null)
    FIELD myAdd2: defaults: req=null)

CLASS Tracking:  abstract=false final=false
    //
    FIELD userId: defaults: req=null)

, DEFAULT_OUTPUTdebug/examples.pkey.info==== PACKAGE examples.pkey (ROOT) ===
CLASS EKey:  abstract=false final=true
    //
    FIELD key1: local required = required, defaults: req=null)
    FIELD key2: local required = required, defaults: req=null)

CLASS EDto:  abstract=false final=false
    //
    FIELD myCompositeKey: defaults: req=null)
    FIELD data: defaults: req=null)

CLASS EDto2:  abstract=false final=false
    //
    FIELD key1: local required = required, defaults: req=null)
    FIELD key2: local required = required, defaults: req=null)
    FIELD data: defaults: req=null)

, DEFAULT_OUTPUTdebug/relations.test.info==== PACKAGE relations.test (ROOT) ===
CLASS Parent:  abstract=false final=false
    //
    FIELD key: local required = required, defaults: req=null)
    FIELD text: defaults: req=null)

CLASS Item:  abstract=false final=false
    //
    FIELD dummyRef: local required = required, defaults: req=null)
    FIELD itemNo: defaults: req=null)
    FIELD itemText: defaults: req=null)

CLASS TestObject:  abstract=false final=false
    //
    FIELD myKey: defaults: req=null)
    FIELD parentRef: local required = required, defaults: req=null)
    FIELD name: defaults: req=null)
    FIELD prices: defaults: req=null)
    FIELD items: defaults: req=null)

, DEFAULT_OUTPUTdebug/tests1.info==== PACKAGE tests1 (ROOT) ===
CLASS BoxedTypes:  abstract=false final=false
    //
    FIELD byte1: defaults: req=null)
    FIELD short1: defaults: req=null)
    FIELD int1: defaults: req=null)
    FIELD int2: defaults: req=null)
    FIELD long1: defaults: req=null)
    FIELD boolean1: defaults: req=null)
    FIELD float1: defaults: req=null)
    FIELD double1: defaults: req=null)
    FIELD char1: defaults: req=null)
    FIELD char2: defaults: req=null)

CLASS OtherTypes:  abstract=false final=false
    //
    FIELD raw1: defaults: req=null)
    FIELD binary1: defaults: req=null)
    FIELD day1: defaults: req=null)
    FIELD timestamp1: defaults: req=null)
    FIELD timestamp2: defaults: req=null)
    FIELD timestamp3: defaults: req=null)
    FIELD timestamp4: defaults: req=null)
    FIELD ascii1: defaults: req=null)
    FIELD unicode1: defaults: req=null)
    FIELD number1: defaults: req=null)
    FIELD decimal1: defaults: req=null)
    FIELD color1: defaults: req=null)
    FIELD color2: defaults: req=null)
    FIELD varEnum1: defaults: req=null)
    FIELD varEnum2: defaults: req=null)
    FIELD myUuid: defaults: req=null)
    FIELD countryCode: defaults: req=null)
    FIELD languageCode: defaults: req=null)
    FIELD timestamp1a: defaults: req=null)
    FIELD timestamp2a: defaults: req=null)
    FIELD timestamp3a: defaults: req=null)
    FIELD timestamp4a: defaults: req=null)

, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/eec/test/EmbedEC.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.eec.test;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



public final class EmbedEC
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 2034227206L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        map.putIfAbsent("text.unroll", "");
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "eec.test.EmbedEC";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$value = new NumericElementaryDataItem(Visibility.DEFAULT, false, "value", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, true, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$text = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "text", Multiplicity.LIST, 0, 0, 3, DataCategory.STRING,
        "String", false, false, false, true, false, 20, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$value;
        field$array[1] = meta$$text;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    Long value;
    List<String> text;
    // auto-generated getters and setters
    public Long getValue() {
        return value;
    }
    public void setValue(Long value) {
        this.value = value;
    }
    public List<String> getText() {
        return text;
    }
    public void setText(List<String> text) {
        this.text = text;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        if (value == null) w.writeNull(meta$$value); else w.addField(value);
        if (text == null) {
            w.writeNullCollection(meta$$text);
        } else {
            w.startArray(text.size(), 3, 0);
            for (String _i : text)
                w.addField(meta$$text, _i);
            w.terminateArray();
        }
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("value")) {
            if (value == null) w.writeNull(meta$$value); else w.addField(value);
            return;
        }
        if (_n.equals("text")) {
            if (text == null) {
                w.writeNullCollection(meta$$text);
            } else {
                if (pfc.index < 0) {
                    w.startArray(text.size(), 3, 0);
                    for (String _i : text) {
                        w.addField(meta$$text, _i);
                    }
                    w.terminateArray();
                } else {
                    if (pfc.index < text.size()) {
                        // output single element
                        w.addField(meta$$text, text.get(pfc.index));
                    }
                }
            }
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        value = p.readLong      ("value", true, true);
        _length = p.parseArrayStart("text", true, 3, 0);
        if (_length < 0) {
            text = null;
        } else {
            text = new ArrayList<String>(_length);
            for (int _i = 0; _i < _length; ++_i)
                text.add(p.readString    ("text", true, 20, false, false, true, true));
            p.parseArrayEnd();
        }
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (text != null) {
        }
        if (text != null)
            for (String _i : text)
        if (_i != null) {
            if (_i.length() > 20)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "_i.length=" + _i.length() + " > 20",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (value == null ? 0 : value.hashCode());
        _hash = 29 * _hash + (text == null ? 0 : text.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof EmbedEC))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof EmbedEC))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        EmbedEC that = (EmbedEC)_that;
        return true
        && ((value == null && that.value == null) || (value != null && value.equals(that.value)))
        && ((text == null && that.text == null) || (text != null && that.text != null && xCompareSub$text(that)))
        ;
    }
    private boolean xCompareSub$text(EmbedEC that) {
        // both text and that text are known to be not null
        if (text.size() != that.text.size())
            return false;
        // indexed access is not optional, but sequential access will be left for later optimization
        for (int _i = 0; _i < text.size(); ++_i)
            if (!(((text.get(_i) == null && that.text.get(_i) == null) || (text.get(_i) != null && text.get(_i).equals(that.text.get(_i))))))
                return false;
        return true;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        text = _cvt.convertList(text, meta$$text);
    }
    // default no-argument constructor
    public EmbedEC() {
    }
    
    // default all-arguments constructor
    public EmbedEC(Long value
    , List<String> text
    ) {
        this.value = value;
        this.text = text;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == EmbedEC.class) {
            return (T) new EmbedEC(getValue(), getText());
        }
        throw new IllegalArgumentException("EmbedEC does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/eec/test/EmbedECEntity.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.eec.test;

import javax.persistence.EntityManager;
import javax.persistence.Embeddable;
import javax.persistence.Embedded;
import javax.persistence.Column;
import javax.persistence.EmbeddedId;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.ManyToOne;
import javax.persistence.JoinColumn;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Serializable;

import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.ByteArrayComposer;
import de.jpaw.bonaparte.core.ByteArrayParser;
import de.jpaw.bonaparte.core.MessageParserException;

@Embeddable
public class EmbedECEntity implements Serializable, Cloneable {
    // table columns of java class EmbedEC
    @Column(name="value")
    Long value;
    public Long getValue() {
        return value;
    }
    public void setValue(Long value) {
        this.value = value;
    }
    @Column(name="text01", length=20)
    String text01;
    public String getText01() {
        return text01;
    }
    public void setText01(String text01) {
        this.text01 = text01;
    }
    @Column(name="text02", length=20)
    String text02;
    public String getText02() {
        return text02;
    }
    public void setText02(String text02) {
        this.text02 = text02;
    }
    @Column(name="text03", length=20)
    String text03;
    public String getText03() {
        return text03;
    }
    public void setText03(String text03) {
        this.text03 = text03;
    }
    public List<String> getText() {
        List<String> _a = new ArrayList<String>(3);
        _a.add(getText01());
        _a.add(getText02());
        _a.add(getText03());
        return _a;
    }
    public void setText(List<String> _a) {
        setText01(null);
        setText02(null);
        setText03(null);
        if (_a == null)
            return;
        if (_a.size() >= 1) setText01(_a.get(0));
        if (_a.size() >= 2) setText02(_a.get(1));
        if (_a.size() >= 3) setText03(_a.get(2));
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (value == null ? 0 : value.hashCode());
        _hash = 29 * _hash + (text01 == null ? 0 : text01.hashCode())
        + (text02 == null ? 0 : text02.hashCode())
        + (text03 == null ? 0 : text03.hashCode())
        ;
        return _hash;
    }
    
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof EmbedECEntity))
            return false;
        if (this == _that)
            return true;
        EmbedECEntity that = (EmbedECEntity)_that;
        return true
        && ((value == null && that.value == null) || value.equals(that.value))
        && ((text01 == null && that.text01 == null) || (text01 != null && text01.equals(that)))
        && ((text02 == null && that.text02 == null) || (text02 != null && text02.equals(that)))
        && ((text03 == null && that.text03 == null) || (text03 != null && text03.equals(that)))
        ;
    }
    @Override
    public EmbedECEntity clone() {
        try {
            return (EmbedECEntity)super.clone();
        } catch (CloneNotSupportedException e) {
            return this;  // fallback
        }
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/eec/test/Item.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.eec.test;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



public class Item
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 1397633700L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "eec.test.Item";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$dummyRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "dummyRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, true, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$itemNo = new NumericElementaryDataItem(Visibility.DEFAULT, false, "itemNo", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, true, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$itemText = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "itemText", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, false, false, true, false, 80, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(3);
        FieldDefinition [] field$array = new FieldDefinition[3];
        field$array[0] = meta$$dummyRef;
        field$array[1] = meta$$itemNo;
        field$array[2] = meta$$itemText;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    Long dummyRef;
    Integer itemNo;
    String itemText;
    // auto-generated getters and setters
    public Long getDummyRef() {
        return dummyRef;
    }
    public void setDummyRef(Long dummyRef) {
        this.dummyRef = dummyRef;
    }
    public Integer getItemNo() {
        return itemNo;
    }
    public void setItemNo(Integer itemNo) {
        this.itemNo = itemNo;
    }
    public String getItemText() {
        return itemText;
    }
    public void setItemText(String itemText) {
        this.itemText = itemText;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        if (dummyRef == null) w.writeNull(meta$$dummyRef); else w.addField(dummyRef);
        if (itemNo == null) w.writeNull(meta$$itemNo); else w.addField(itemNo);
        w.addField(meta$$itemText, itemText);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("dummyRef")) {
            if (dummyRef == null) w.writeNull(meta$$dummyRef); else w.addField(dummyRef);
            return;
        }
        if (_n.equals("itemNo")) {
            if (itemNo == null) w.writeNull(meta$$itemNo); else w.addField(itemNo);
            return;
        }
        if (_n.equals("itemText")) {
            w.addField(meta$$itemText, itemText);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        dummyRef = p.readLong      ("dummyRef", false, true);
        itemNo = p.readInteger   ("itemNo", true, true);
        itemText = p.readString    ("itemText", true, 80, false, false, true, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (dummyRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "dummyRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (itemText != null) {
            if (itemText.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "itemText.length=" + itemText.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (dummyRef == null ? 0 : dummyRef.hashCode());
        _hash = 29 * _hash + (itemNo == null ? 0 : itemNo.hashCode());
        _hash = 29 * _hash + (itemText == null ? 0 : itemText.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Item))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Item))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        Item that = (Item)_that;
        return true
        && ((dummyRef == null && that.dummyRef == null) || (dummyRef != null && dummyRef.equals(that.dummyRef)))
        && ((itemNo == null && that.itemNo == null) || (itemNo != null && itemNo.equals(that.itemNo)))
        && ((itemText == null && that.itemText == null) || (itemText != null && itemText.equals(that.itemText)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        itemText = _cvt.convert(itemText, meta$$itemText);
    }
    // default no-argument constructor
    public Item() {
    }
    
    // default all-arguments constructor
    public Item(Long dummyRef
    , Integer itemNo
    , String itemText
    ) {
        this.dummyRef = dummyRef;
        this.itemNo = itemNo;
        this.itemText = itemText;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Item.class) {
            return (T) new Item(getDummyRef(), getItemNo(), getItemText());
        }
        throw new IllegalArgumentException("Item does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/eec/test/ItemEntity.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.eec.test;

import javax.persistence.EntityManager;
import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.Version;
import javax.persistence.Column;
import javax.persistence.Lob;
import javax.persistence.Basic;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.Id;
import javax.persistence.IdClass;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.NoResultException;
import javax.persistence.TypedQuery;
import javax.persistence.EmbeddedId;
import javax.persistence.Embedded;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.MapKey;
import javax.persistence.MapKeyJoinColumn;
import javax.persistence.JoinColumn;
import javax.persistence.JoinColumns;
import javax.persistence.ElementCollection;
import javax.persistence.MapKeyColumn;
import javax.persistence.CollectionTable;
import javax.persistence.EntityListeners;
import javax.persistence.UniqueConstraint;
import javax.persistence.AttributeOverride;
import javax.persistence.AttributeOverrides;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Serializable;

import de.jpaw.bonaparte.jpa.BonaPersistableNoData;
import de.jpaw.bonaparte.jpa.BonaPersistableTracking;
import de.jpaw.bonaparte.jpa.BonaPersistableBase;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.jpa.KeyClass;
import de.jpaw.bonaparte.jpa.DataClass;
import de.jpaw.bonaparte.jpa.TrackingClass;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.ByteArrayComposer;
import de.jpaw.bonaparte.core.ByteArrayParser;
import de.jpaw.bonaparte.core.MessageParserException;

@DataClass(Item.class)
@KeyClass(ItemEntityKey.class)
@Entity
@Table(name="tests_item_entity")
public class ItemEntity implements BonaPersistable<ItemEntityKey, Item, BonaPortable> {
    @EmbeddedId
    ItemEntityKey key;
    // forwarding getters and setters
    public void setDummyRef(Long _x) {
        key.setDummyRef(_x);
    }
    public Long getDummyRef() {
        return key.getDummyRef();
    }
    public void setItemNo(Integer _x) {
        key.setItemNo(_x);
    }
    public Integer getItemNo() {
        return key.getItemNo();
    }

    // table columns of java class Item
    @Column(name="item_text", length=80)
    String itemText;
    public String getItemText() {
        return itemText;
    }
    public void setItemText(String itemText) {
        this.itemText = itemText;
    }
    @Override
    public int hashCode() {
        return key == null ? -1 : key.hashCode();
    }
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null || this.getClass() != obj.getClass())
            return false;
        if (key == null) // not yet assigned => treat it as different
            return false;
        return this.key.equals(((ItemEntity)obj).key);
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // no isActive column in this entity, create stubs to satisfy interface
    public void set$Active(boolean _a) {
        // throw new RuntimeException("Entity ItemEntity does not have an isActive field");
    }
    public boolean get$Active() {
        return true;  // no isActive column => all rows are active by default
    }
    // no version column of type int or Integer, write stub
    public void set$IntVersion(int _v) {
        // throw new RuntimeException("Entity ItemEntity does not have an integer type version field");
    }
    public int get$IntVersion() {
        return -1;
    }
    public static Class<BonaPortable> class$TrackingClass() {
        return null;
    }
    @Override
    public String get$TrackingPQON() {
        return null;
    }
    @Override
    public Class<BonaPortable> get$TrackingClass() {
        return null;
    }
    
    public static Class<ItemEntityKey> class$KeyClass() {
        return ItemEntityKey.class;
    }
    @Override
    public Class<ItemEntityKey> get$KeyClass() {
        return ItemEntityKey.class;
    }
    @Override
    public ItemEntityKey get$Key() throws ApplicationException {
        return key.clone(); // as our key fields are all immutable, shallow copy is sufficient
    }
    @Override
    public void set$Key(ItemEntityKey _k) {
        key = _k.clone();   // as our key fields are all immutable, shallow copy is sufficient
    }
    
    @Override
    public BonaPortable get$Tracking() throws ApplicationException {
        return null;
    }
    @Override
    public void set$Tracking(BonaPortable _d) {
    }
    @Override
    public String get$DataPQON() {
        return "eec.test.Item";
    }
    @Override
    public Class<? extends Item> get$DataClass() {
        return Item.class;
    }
    public static Class<Item> class$DataClass() {
        return Item.class;
    }
    public static String class$DataPQON() {
        return "eec.test.Item";
    }
    @Override
    public Item get$Data() throws ApplicationException {
        Item _r = new Item();
        // auto-generated data getter for Item
        _r.setDummyRef(getDummyRef());
        _r.setItemNo(getItemNo());
        _r.setItemText(getItemText());
        return _r;
    }
    @Override
    public void set$Data(Item _d) {
        // auto-generated data setter for Item
        setItemText(_d.getItemText());
    }
    @Override
    public BonaPersistableBase mergeFrom(final BonaPersistableBase _b) {
        if (_b instanceof ItemEntity) {
            ItemEntity _x = (ItemEntity)_b;
            setDummyRef(_x.getDummyRef());
            setItemNo(_x.getItemNo());
            itemText = _x.itemText;
        }
        return this;
    }
    
    
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/eec/test/ItemEntityKey.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.eec.test;

import javax.persistence.EntityManager;
import javax.persistence.Embeddable;
import javax.persistence.Embedded;
import javax.persistence.Column;
import javax.persistence.EmbeddedId;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.ManyToOne;
import javax.persistence.JoinColumn;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Serializable;

import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.ByteArrayComposer;
import de.jpaw.bonaparte.core.ByteArrayParser;
import de.jpaw.bonaparte.core.MessageParserException;

@Embeddable
public class ItemEntityKey implements Serializable, Cloneable {
    @Column(name="dummy_ref", nullable=false)
    Long dummyRef;
    public Long getDummyRef() {
        return dummyRef;
    }
    public void setDummyRef(Long dummyRef) {
        this.dummyRef = dummyRef;
    }
    @Column(name="item_no")
    Integer itemNo;
    public Integer getItemNo() {
        return itemNo;
    }
    public void setItemNo(Integer itemNo) {
        this.itemNo = itemNo;
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (dummyRef == null ? 0 : dummyRef.hashCode());
        _hash = 29 * _hash + (itemNo == null ? 0 : itemNo.hashCode());
        return _hash;
    }
    
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ItemEntityKey))
            return false;
        if (this == _that)
            return true;
        ItemEntityKey that = (ItemEntityKey)_that;
        return true
        && ((dummyRef == null && that.dummyRef == null) || dummyRef.equals(that.dummyRef))
        && ((itemNo == null && that.itemNo == null) || itemNo.equals(that.itemNo))
        ;
    }
    @Override
    public ItemEntityKey clone() {
        try {
            return (ItemEntityKey)super.clone();
        } catch (CloneNotSupportedException e) {
            return this;  // fallback
        }
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/eec/test/Parent.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.eec.test;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



public class Parent
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -1015537669L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "eec.test.Parent";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$key = new NumericElementaryDataItem(Visibility.DEFAULT, true, "key", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, true, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$text = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "text", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, false, false, true, false, 80, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$key;
        field$array[1] = meta$$text;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    Long key;
    String text;
    // auto-generated getters and setters
    public Long getKey() {
        return key;
    }
    public void setKey(Long key) {
        this.key = key;
    }
    public String getText() {
        return text;
    }
    public void setText(String text) {
        this.text = text;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        if (key == null) w.writeNull(meta$$key); else w.addField(key);
        w.addField(meta$$text, text);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("key")) {
            if (key == null) w.writeNull(meta$$key); else w.addField(key);
            return;
        }
        if (_n.equals("text")) {
            w.addField(meta$$text, text);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        key = p.readLong      ("key", false, true);
        text = p.readString    ("text", true, 80, false, false, true, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (key == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "key", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (text != null) {
            if (text.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "text.length=" + text.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (key == null ? 0 : key.hashCode());
        _hash = 29 * _hash + (text == null ? 0 : text.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Parent))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Parent))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        Parent that = (Parent)_that;
        return true
        && ((key == null && that.key == null) || (key != null && key.equals(that.key)))
        && ((text == null && that.text == null) || (text != null && text.equals(that.text)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        text = _cvt.convert(text, meta$$text);
    }
    // default no-argument constructor
    public Parent() {
    }
    
    // default all-arguments constructor
    public Parent(Long key
    , String text
    ) {
        this.key = key;
        this.text = text;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Parent.class) {
            return (T) new Parent(getKey(), getText());
        }
        throw new IllegalArgumentException("Parent does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/eec/test/ParentEntity.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.eec.test;

import javax.persistence.EntityManager;
import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.Version;
import javax.persistence.Column;
import javax.persistence.Lob;
import javax.persistence.Basic;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.Id;
import javax.persistence.IdClass;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.NoResultException;
import javax.persistence.TypedQuery;
import javax.persistence.EmbeddedId;
import javax.persistence.Embedded;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.MapKey;
import javax.persistence.MapKeyJoinColumn;
import javax.persistence.JoinColumn;
import javax.persistence.JoinColumns;
import javax.persistence.ElementCollection;
import javax.persistence.MapKeyColumn;
import javax.persistence.CollectionTable;
import javax.persistence.EntityListeners;
import javax.persistence.UniqueConstraint;
import javax.persistence.AttributeOverride;
import javax.persistence.AttributeOverrides;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Serializable;

import de.jpaw.bonaparte.jpa.BonaPersistableNoData;
import de.jpaw.bonaparte.jpa.BonaPersistableTracking;
import de.jpaw.bonaparte.jpa.BonaPersistableBase;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.jpa.KeyClass;
import de.jpaw.bonaparte.jpa.DataClass;
import de.jpaw.bonaparte.jpa.TrackingClass;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.ByteArrayComposer;
import de.jpaw.bonaparte.core.ByteArrayParser;
import de.jpaw.bonaparte.core.MessageParserException;

@DataClass(Parent.class)
@KeyClass(Long.class)
@Entity
@Table(name="tests_parent_entity")
public class ParentEntity implements BonaPersistable<Long, Parent, BonaPortable> {
    // table columns of java class Parent
    @Id
    @Column(name="key", nullable=false)
    Long key;
    public Long getKey() {
        return key;
    }
    public void setKey(Long key) {
        this.key = key;
    }
    @Column(name="text", length=80)
    String text;
    public String getText() {
        return text;
    }
    public void setText(String text) {
        this.text = text;
    }
    @Override
    public int hashCode() {
        return key == null ? -1 : key.hashCode();
    }
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null || this.getClass() != obj.getClass())
            return false;
        if (key == null) // not yet assigned => treat it as different
            return false;
        return this.key.equals(((ParentEntity)obj).key);
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // no isActive column in this entity, create stubs to satisfy interface
    public void set$Active(boolean _a) {
        // throw new RuntimeException("Entity ParentEntity does not have an isActive field");
    }
    public boolean get$Active() {
        return true;  // no isActive column => all rows are active by default
    }
    // no version column of type int or Integer, write stub
    public void set$IntVersion(int _v) {
        // throw new RuntimeException("Entity ParentEntity does not have an integer type version field");
    }
    public int get$IntVersion() {
        return -1;
    }
    public static Class<BonaPortable> class$TrackingClass() {
        return null;
    }
    @Override
    public String get$TrackingPQON() {
        return null;
    }
    @Override
    public Class<BonaPortable> get$TrackingClass() {
        return null;
    }
    
    public static Class<Long> class$KeyClass() {
        return Long.class;
    }
    @Override
    public Class<Long> get$KeyClass() {
        return Long.class;
    }
    @Override
    public Long get$Key() throws ApplicationException {
        return key;
    }
    @Override
    public void set$Key(Long _k) {
        setKey(_k);  // no direct assigned due to possible enum or temporal type, with implied conversions
    }
    
    @Override
    public BonaPortable get$Tracking() throws ApplicationException {
        return null;
    }
    @Override
    public void set$Tracking(BonaPortable _d) {
    }
    @Override
    public String get$DataPQON() {
        return "eec.test.Parent";
    }
    @Override
    public Class<? extends Parent> get$DataClass() {
        return Parent.class;
    }
    public static Class<Parent> class$DataClass() {
        return Parent.class;
    }
    public static String class$DataPQON() {
        return "eec.test.Parent";
    }
    @Override
    public Parent get$Data() throws ApplicationException {
        Parent _r = new Parent();
        // auto-generated data getter for Parent
        _r.setKey(getKey());
        _r.setText(getText());
        return _r;
    }
    @Override
    public void set$Data(Parent _d) {
        // auto-generated data setter for Parent
        setText(_d.getText());
    }
    @Override
    public BonaPersistableBase mergeFrom(final BonaPersistableBase _b) {
        if (_b instanceof ParentEntity) {
            ParentEntity _x = (ParentEntity)_b;
            setKey(_x.getKey());
            text = _x.text;
        }
        return this;
    }
    
    
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/eec/test/TestObject.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.eec.test;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



public class TestObject
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 2013635906L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "eec.test.TestObject";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$myKey = new NumericElementaryDataItem(Visibility.DEFAULT, false, "myKey", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, true, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$parentRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "parentRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, true, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$name = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "name", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, false, false, true, false, 80, 0, null);
    protected static final NumericElementaryDataItem meta$$prices = new NumericElementaryDataItem(Visibility.DEFAULT, false, "prices", Multiplicity.MAP, 1, 0, 0, DataCategory.NUMERIC,
        "BigDecimal", false, true, 14, 2, false, false);
    protected static final ObjectReference meta$$items = new ObjectReference(Visibility.DEFAULT, false, "items", Multiplicity.LIST, 0, 0, 0, DataCategory.OBJECT,
        "Item", false, true, "Item");
    protected static final ObjectReference meta$$embeddedList = new ObjectReference(Visibility.DEFAULT, false, "embeddedList", Multiplicity.LIST, 0, 0, 0, DataCategory.OBJECT,
        "EmbedEC", false, false, "EmbedEC");
    protected static final ObjectReference meta$$embeddedMap = new ObjectReference(Visibility.DEFAULT, false, "embeddedMap", Multiplicity.MAP, 1, 0, 0, DataCategory.OBJECT,
        "EmbedEC", false, false, "EmbedEC");
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(7);
        FieldDefinition [] field$array = new FieldDefinition[7];
        field$array[0] = meta$$myKey;
        field$array[1] = meta$$parentRef;
        field$array[2] = meta$$name;
        field$array[3] = meta$$prices;
        field$array[4] = meta$$items;
        field$array[5] = meta$$embeddedList;
        field$array[6] = meta$$embeddedMap;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    Long myKey;
    Long parentRef;
    String name;
    Map<String,BigDecimal> prices;
    List<Item> items;
    List<EmbedEC> embeddedList;
    Map<String,EmbedEC> embeddedMap;
    // auto-generated getters and setters
    public Long getMyKey() {
        return myKey;
    }
    public void setMyKey(Long myKey) {
        this.myKey = myKey;
    }
    public Long getParentRef() {
        return parentRef;
    }
    public void setParentRef(Long parentRef) {
        this.parentRef = parentRef;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Map<String,BigDecimal> getPrices() {
        return prices;
    }
    public void setPrices(Map<String,BigDecimal> prices) {
        this.prices = prices;
    }
    public List<Item> getItems() {
        return items;
    }
    public void setItems(List<Item> items) {
        this.items = items;
    }
    public List<EmbedEC> getEmbeddedList() {
        return embeddedList;
    }
    public void setEmbeddedList(List<EmbedEC> embeddedList) {
        this.embeddedList = embeddedList;
    }
    public Map<String,EmbedEC> getEmbeddedMap() {
        return embeddedMap;
    }
    public void setEmbeddedMap(Map<String,EmbedEC> embeddedMap) {
        this.embeddedMap = embeddedMap;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        if (myKey == null) w.writeNull(meta$$myKey); else w.addField(myKey);
        if (parentRef == null) w.writeNull(meta$$parentRef); else w.addField(parentRef);
        w.addField(meta$$name, name);
        if (prices == null) {
            w.writeNullCollection(meta$$prices);
        } else {
            w.startMap(prices.size(), 1);
            for (Map.Entry<String,BigDecimal> _i : prices.entrySet()) {
                // write (key, value) tuples
                w.addField(StaticMeta.MAP_INDEX_META, _i.getKey());
                w.addField(meta$$prices, _i.getValue());
            }
            w.terminateArray();
        }
        if (items == null) {
            w.writeNullCollection(meta$$items);
        } else {
            w.startArray(items.size(), 0, 0);
            for (Item _i : items)
                w.addField((BonaPortable)_i);
            w.terminateArray();
        }
        if (embeddedList == null) {
            w.writeNullCollection(meta$$embeddedList);
        } else {
            w.startArray(embeddedList.size(), 0, 0);
            for (EmbedEC _i : embeddedList)
                w.addField((BonaPortable)_i);
            w.terminateArray();
        }
        if (embeddedMap == null) {
            w.writeNullCollection(meta$$embeddedMap);
        } else {
            w.startMap(embeddedMap.size(), 1);
            for (Map.Entry<String,EmbedEC> _i : embeddedMap.entrySet()) {
                // write (key, value) tuples
                w.addField(StaticMeta.MAP_INDEX_META, _i.getKey());
                w.addField((BonaPortable)_i.getValue());
            }
            w.terminateArray();
        }
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("myKey")) {
            if (myKey == null) w.writeNull(meta$$myKey); else w.addField(myKey);
            return;
        }
        if (_n.equals("parentRef")) {
            if (parentRef == null) w.writeNull(meta$$parentRef); else w.addField(parentRef);
            return;
        }
        if (_n.equals("name")) {
            w.addField(meta$$name, name);
            return;
        }
        if (_n.equals("prices")) {
            if (prices == null) {
                w.writeNullCollection(meta$$prices);
            } else {
                if (pfc.alphaIndex == null) {
                    w.startMap(prices.size(), 1);
                    for (Map.Entry<String,BigDecimal> _i : prices.entrySet()) {
                        // write (key, value) tuples
                        w.addField(StaticMeta.MAP_INDEX_META, _i.getKey());
                        w.addField(meta$$prices, _i.getValue());
                    }
                    w.terminateArray();
                } else {
                    w.addField(meta$$prices, prices.get(pfc.alphaIndex));
                }
            }
            return;
        }
        if (_n.equals("items")) {
            if (items == null) {
                w.writeNullCollection(meta$$items);
            } else {
                if (pfc.index < 0) {
                    w.startArray(items.size(), 0, 0);
                    for (Item _i : items) {
                        if (_i == null) {
                            w.writeNull(meta$$items);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)_i);             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            _i.foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                    w.terminateArray();
                } else {
                    if (pfc.index < items.size()) {
                        // output single element
                        if (items.get(pfc.index) == null) {
                            w.writeNull(meta$$items);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)items.get(pfc.index));             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            items.get(pfc.index).foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                }
            }
            return;
        }
        if (_n.equals("embeddedList")) {
            if (embeddedList == null) {
                w.writeNullCollection(meta$$embeddedList);
            } else {
                if (pfc.index < 0) {
                    w.startArray(embeddedList.size(), 0, 0);
                    for (EmbedEC _i : embeddedList) {
                        if (_i == null) {
                            w.writeNull(meta$$embeddedList);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)_i);             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            _i.foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                    w.terminateArray();
                } else {
                    if (pfc.index < embeddedList.size()) {
                        // output single element
                        if (embeddedList.get(pfc.index) == null) {
                            w.writeNull(meta$$embeddedList);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)embeddedList.get(pfc.index));             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            embeddedList.get(pfc.index).foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                }
            }
            return;
        }
        if (_n.equals("embeddedMap")) {
            if (embeddedMap == null) {
                w.writeNullCollection(meta$$embeddedMap);
            } else {
                if (pfc.alphaIndex == null) {
                    w.startMap(embeddedMap.size(), 1);
                    for (Map.Entry<String,EmbedEC> _i : embeddedMap.entrySet()) {
                        // write (key, value) tuples
                        w.addField(StaticMeta.MAP_INDEX_META, _i.getKey());
                        if (_i.getValue() == null) {
                            w.writeNull(meta$$embeddedMap);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)_i.getValue());             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            _i.getValue().foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                    w.terminateArray();
                } else {
                    if (embeddedMap.get(pfc.alphaIndex) == null) {
                        w.writeNull(meta$$embeddedMap);
                    } else if (pfc.getComponent() == null) {
                        w.addField((BonaPortable)embeddedMap.get(pfc.alphaIndex));             // full / recursive object output
                    } else {
                        // write a specific subcomponent
                        embeddedMap.get(pfc.alphaIndex).foldedOutput(w, pfc.getComponent());   // recurse specific field
                    }
                }
            }
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        myKey = p.readLong      ("myKey", true, true);
        parentRef = p.readLong      ("parentRef", false, true);
        name = p.readString    ("name", true, 80, false, false, true, true);
        _length = p.parseMapStart("prices", true, 1);
        if (_length < 0) {
            prices = null;
        } else {
            prices = new HashMap<String, BigDecimal>(_length);
            for (int _i = 0; _i < _length; ++_i) {
                String _key = p.readString("prices", false, 255, false, false, true, true);
                prices.put(_key, p.readBigDecimal("prices", true, 14, 2, true, false, false));
            }
            p.parseArrayEnd();
        }
        _length = p.parseArrayStart("items", true, 0, 0);
        if (_length < 0) {
            items = null;
        } else {
            items = new ArrayList<Item>(_length);
            for (int _i = 0; _i < _length; ++_i)
                items.add((Item)p.readObject("items", Item.class, true, true));
            p.parseArrayEnd();
        }
        _length = p.parseArrayStart("embeddedList", true, 0, 0);
        if (_length < 0) {
            embeddedList = null;
        } else {
            embeddedList = new ArrayList<EmbedEC>(_length);
            for (int _i = 0; _i < _length; ++_i)
                embeddedList.add((EmbedEC)p.readObject("embeddedList", EmbedEC.class, true, false));
            p.parseArrayEnd();
        }
        _length = p.parseMapStart("embeddedMap", true, 1);
        if (_length < 0) {
            embeddedMap = null;
        } else {
            embeddedMap = new HashMap<String, EmbedEC>(_length);
            for (int _i = 0; _i < _length; ++_i) {
                String _key = p.readString("embeddedMap", false, 255, false, false, true, true);
                embeddedMap.put(_key, (EmbedEC)p.readObject("embeddedMap", EmbedEC.class, true, false));
            }
            p.parseArrayEnd();
        }
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (parentRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "parentRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (items != null)
            for (Item _i : items)
        if (_i != null)
            _i.validate();  // check object
        if (embeddedList != null)
            for (EmbedEC _i : embeddedList)
        if (_i != null)
            _i.validate();  // check object
        if (embeddedMap != null)
            for (Map.Entry<String,EmbedEC> _i : embeddedMap.entrySet())
        if (_i.getValue() != null)
            _i.getValue().validate();  // check object
        if (name != null) {
            if (name.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "name.length=" + name.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (myKey == null ? 0 : myKey.hashCode());
        _hash = 29 * _hash + (parentRef == null ? 0 : parentRef.hashCode());
        _hash = 29 * _hash + (name == null ? 0 : name.hashCode());
        _hash = 29 * _hash + (prices == null ? 0 : prices.hashCode());
        _hash = 29 * _hash + (items == null ? 0 : items.hashCode());
        _hash = 29 * _hash + (embeddedList == null ? 0 : embeddedList.hashCode());
        _hash = 29 * _hash + (embeddedMap == null ? 0 : embeddedMap.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof TestObject))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof TestObject))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        TestObject that = (TestObject)_that;
        return true
        && ((myKey == null && that.myKey == null) || (myKey != null && myKey.equals(that.myKey)))
        && ((parentRef == null && that.parentRef == null) || (parentRef != null && parentRef.equals(that.parentRef)))
        && ((name == null && that.name == null) || (name != null && name.equals(that.name)))
        && ((prices == null && that.prices == null) || (prices != null && that.prices != null && xCompareSub$prices(that)))
        && ((items == null && that.items == null) || (items != null && that.items != null && xCompareSub$items(that)))
        && ((embeddedList == null && that.embeddedList == null) || (embeddedList != null && that.embeddedList != null && xCompareSub$embeddedList(that)))
        && ((embeddedMap == null && that.embeddedMap == null) || (embeddedMap != null && that.embeddedMap != null && xCompareSub$embeddedMap(that)))
        ;
    }
    private boolean xCompareSub$prices(TestObject that) {
        // both prices and that prices are known to be not null
        if (prices.size() != that.prices.size())
            return false;
        // method is to verify all entries are the same
        for (Map.Entry<String, BigDecimal> _i : prices.entrySet()) {
            BigDecimal _t = that.prices.get(_i.getKey());
            if (!(((_i.getValue() == null && _t == null) || (_i.getValue() != null && BigDecimalTools.equals(_i.getValue(), 2, _t, 2)))))
                return false;
        }
        return true;
    }
    private boolean xCompareSub$items(TestObject that) {
        // both items and that items are known to be not null
        if (items.size() != that.items.size())
            return false;
        // indexed access is not optional, but sequential access will be left for later optimization
        for (int _i = 0; _i < items.size(); ++_i)
            if (!(((items.get(_i) == null && that.items.get(_i) == null) || (items.get(_i) != null && items.get(_i).hasSameContentsAs(that.items.get(_i))))))
                return false;
        return true;
    }
    private boolean xCompareSub$embeddedList(TestObject that) {
        // both embeddedList and that embeddedList are known to be not null
        if (embeddedList.size() != that.embeddedList.size())
            return false;
        // indexed access is not optional, but sequential access will be left for later optimization
        for (int _i = 0; _i < embeddedList.size(); ++_i)
            if (!(((embeddedList.get(_i) == null && that.embeddedList.get(_i) == null) || (embeddedList.get(_i) != null && embeddedList.get(_i).hasSameContentsAs(that.embeddedList.get(_i))))))
                return false;
        return true;
    }
    private boolean xCompareSub$embeddedMap(TestObject that) {
        // both embeddedMap and that embeddedMap are known to be not null
        if (embeddedMap.size() != that.embeddedMap.size())
            return false;
        // method is to verify all entries are the same
        for (Map.Entry<String, EmbedEC> _i : embeddedMap.entrySet()) {
            EmbedEC _t = that.embeddedMap.get(_i.getKey());
            if (!(((_i.getValue() == null && _t == null) || (_i.getValue() != null && _i.getValue().hasSameContentsAs(_t)))))
                return false;
        }
        return true;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        name = _cvt.convert(name, meta$$name);
        if (items != null)
            for (Item _i : items)
        if (_i != null)
            _i.treeWalkString(_cvt);
        if (embeddedList != null)
            for (EmbedEC _i : embeddedList)
        if (_i != null)
            _i.treeWalkString(_cvt);
        if (embeddedMap != null)
            for (Map.Entry<String,EmbedEC> _i : embeddedMap.entrySet())
        if (_i.getValue() != null)
            _i.getValue().treeWalkString(_cvt);
    }
    // default no-argument constructor
    public TestObject() {
    }
    
    // default all-arguments constructor
    public TestObject(Long myKey
    , Long parentRef
    , String name
    , Map<String,BigDecimal> prices
    , List<Item> items
    , List<EmbedEC> embeddedList
    , Map<String,EmbedEC> embeddedMap
    ) {
        this.myKey = myKey;
        this.parentRef = parentRef;
        this.name = name;
        this.prices = prices;
        this.items = items;
        this.embeddedList = embeddedList;
        this.embeddedMap = embeddedMap;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == TestObject.class) {
            return (T) new TestObject(getMyKey(), getParentRef(), getName(), getPrices(), getItems(), getEmbeddedList(), getEmbeddedMap());
        }
        throw new IllegalArgumentException("TestObject does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/eec/test/package-info.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

package de.jpaw.bonaparte.pojos.eec.test;
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/embedTest/Add2Entity.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.embedTest;

import javax.persistence.EntityManager;
import javax.persistence.Embeddable;
import javax.persistence.Embedded;
import javax.persistence.Column;
import javax.persistence.EmbeddedId;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.ManyToOne;
import javax.persistence.JoinColumn;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Serializable;

import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.ByteArrayComposer;
import de.jpaw.bonaparte.core.ByteArrayParser;
import de.jpaw.bonaparte.core.MessageParserException;

@Embeddable
public class Add2Entity implements Serializable, Cloneable {
    // table columns of java class Add2
    @Column(name="data1", nullable=false, length=10)
    String data1;
    public String getData1() {
        return data1;
    }
    public void setData1(String data1) {
        this.data1 = data1;
    }
    @Column(name="props01", length=10)
    String props01;
    public String getProps01() {
        return props01;
    }
    public void setProps01(String props01) {
        this.props01 = props01;
    }
    @Column(name="props02", length=10)
    String props02;
    public String getProps02() {
        return props02;
    }
    public void setProps02(String props02) {
        this.props02 = props02;
    }
    @Column(name="props03", length=10)
    String props03;
    public String getProps03() {
        return props03;
    }
    public void setProps03(String props03) {
        this.props03 = props03;
    }
    @Column(name="props04", length=10)
    String props04;
    public String getProps04() {
        return props04;
    }
    public void setProps04(String props04) {
        this.props04 = props04;
    }
    public List<String> getProps() {
        List<String> _a = new ArrayList<String>(4);
        _a.add(getProps01());
        _a.add(getProps02());
        _a.add(getProps03());
        _a.add(getProps04());
        return _a;
    }
    public void setProps(List<String> _a) {
        setProps01(null);
        setProps02(null);
        setProps03(null);
        setProps04(null);
        if (_a == null)
            return;
        if (_a.size() >= 1) setProps01(_a.get(0));
        if (_a.size() >= 2) setProps02(_a.get(1));
        if (_a.size() >= 3) setProps03(_a.get(2));
        if (_a.size() >= 4) setProps04(_a.get(3));
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (data1 == null ? 0 : data1.hashCode());
        _hash = 29 * _hash + (props01 == null ? 0 : props01.hashCode())
        + (props02 == null ? 0 : props02.hashCode())
        + (props03 == null ? 0 : props03.hashCode())
        + (props04 == null ? 0 : props04.hashCode())
        ;
        return _hash;
    }
    
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Add2Entity))
            return false;
        if (this == _that)
            return true;
        Add2Entity that = (Add2Entity)_that;
        return true
        && ((data1 == null && that.data1 == null) || data1.equals(that.data1))
        && ((props01 == null && that.props01 == null) || (props01 != null && props01.equals(that)))
        && ((props02 == null && that.props02 == null) || (props02 != null && props02.equals(that)))
        && ((props03 == null && that.props03 == null) || (props03 != null && props03.equals(that)))
        && ((props04 == null && that.props04 == null) || (props04 != null && props04.equals(that)))
        ;
    }
    @Override
    public Add2Entity clone() {
        try {
            return (Add2Entity)super.clone();
        } catch (CloneNotSupportedException e) {
            return this;  // fallback
        }
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/embedTest/AddressEntity.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.embedTest;

import javax.persistence.EntityManager;
import javax.persistence.Embeddable;
import javax.persistence.Embedded;
import javax.persistence.Column;
import javax.persistence.EmbeddedId;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.ManyToOne;
import javax.persistence.JoinColumn;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Serializable;

import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.ByteArrayComposer;
import de.jpaw.bonaparte.core.ByteArrayParser;
import de.jpaw.bonaparte.core.MessageParserException;

@Embeddable
public class AddressEntity implements Serializable, Cloneable {
    // table columns of java class Address
    @Column(name="street", nullable=false, length=20)
    String street;
    public String getStreet() {
        return street;
    }
    public void setStreet(String street) {
        this.street = street;
    }
    @Column(name="zip_code", length=10)
    String zipCode;
    public String getZipCode() {
        return zipCode;
    }
    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }
    @Column(name="city", length=30)
    String city;
    public String getCity() {
        return city;
    }
    public void setCity(String city) {
        this.city = city;
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (street == null ? 0 : street.hashCode());
        _hash = 29 * _hash + (zipCode == null ? 0 : zipCode.hashCode());
        _hash = 29 * _hash + (city == null ? 0 : city.hashCode());
        return _hash;
    }
    
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof AddressEntity))
            return false;
        if (this == _that)
            return true;
        AddressEntity that = (AddressEntity)_that;
        return true
        && ((street == null && that.street == null) || street.equals(that.street))
        && ((zipCode == null && that.zipCode == null) || zipCode.equals(that.zipCode))
        && ((city == null && that.city == null) || city.equals(that.city))
        ;
    }
    @Override
    public AddressEntity clone() {
        try {
            return (AddressEntity)super.clone();
        } catch (CloneNotSupportedException e) {
            return this;  // fallback
        }
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/embedTest/PersonEntity.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.embedTest;

import javax.persistence.EntityManager;
import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.Version;
import javax.persistence.Column;
import javax.persistence.Lob;
import javax.persistence.Basic;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.Id;
import javax.persistence.IdClass;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.NoResultException;
import javax.persistence.TypedQuery;
import javax.persistence.EmbeddedId;
import javax.persistence.Embedded;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.MapKey;
import javax.persistence.MapKeyJoinColumn;
import javax.persistence.JoinColumn;
import javax.persistence.JoinColumns;
import javax.persistence.ElementCollection;
import javax.persistence.MapKeyColumn;
import javax.persistence.CollectionTable;
import javax.persistence.EntityListeners;
import javax.persistence.UniqueConstraint;
import javax.persistence.AttributeOverride;
import javax.persistence.AttributeOverrides;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Serializable;

import de.jpaw.bonaparte.jpa.BonaPersistableNoData;
import de.jpaw.bonaparte.jpa.BonaPersistableTracking;
import de.jpaw.bonaparte.jpa.BonaPersistableBase;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.jpa.KeyClass;
import de.jpaw.bonaparte.jpa.DataClass;
import de.jpaw.bonaparte.jpa.TrackingClass;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.ByteArrayComposer;
import de.jpaw.bonaparte.core.ByteArrayParser;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.pojos.embeddables.Address;
import de.jpaw.bonaparte.pojos.embeddables.Tracking;
import de.jpaw.bonaparte.pojos.embeddables.Person;
import de.jpaw.bonaparte.pojos.embeddables.Add2;

@DataClass(Person.class)
@TrackingClass(Tracking.class)
@KeyClass(Long.class)
@Entity
@Table(name="jp_cfg_person")
public class PersonEntity implements BonaPersistableNoData<Long, Tracking> {
    // table columns of java class Tracking
    @Column(name="user_id", length=8)
    String userId;
    public String getUserId() {
        return userId;
    }
    public void setUserId(String userId) {
        this.userId = userId;
    }
    // table columns of java class Person
    @Id
    @Column(name="person_key")
    Long personKey;
    public Long getPersonKey() {
        return personKey;
    }
    public void setPersonKey(Long personKey) {
        this.personKey = personKey;
    }
    @Column(name="name", length=20)
    String name;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    @AttributeOverrides({
        @AttributeOverride(name="street", column=@Column(name="home_street")),
        @AttributeOverride(name="zipCode", column=@Column(name="home_zip_code")),
        @AttributeOverride(name="city", column=@Column(name="home_city"))
    })
    @Embedded
    private AddressEntity homeAddress;
    public Address getHomeAddress() {
        if (homeAddress == null)
            return null;
        return new Address(homeAddress.getStreet(), homeAddress.getZipCode(), homeAddress.getCity());
    }
    public void setHomeAddress(Address _x) {
        if (_x == null) {
            homeAddress = null;
        } else {
            homeAddress = new AddressEntity();
            homeAddress.setStreet(_x.getStreet());
            homeAddress.setZipCode(_x.getZipCode());
            homeAddress.setCity(_x.getCity());
        }
    }
    @AttributeOverrides({
        @AttributeOverride(name="street", column=@Column(name="street_work")),
        @AttributeOverride(name="zipCode", column=@Column(name="zip_code_work")),
        @AttributeOverride(name="city", column=@Column(name="city_work"))
    })
    @Embedded
    private AddressEntity addressWork;
    public Address getAddressWork() {
        if (addressWork == null)
            return null;
        return new Address(addressWork.getStreet(), addressWork.getZipCode(), addressWork.getCity());
    }
    public void setAddressWork(Address _x) {
        if (_x == null) {
            addressWork = null;
        } else {
            addressWork = new AddressEntity();
            addressWork.setStreet(_x.getStreet());
            addressWork.setZipCode(_x.getZipCode());
            addressWork.setCity(_x.getCity());
        }
    }
    @AttributeOverrides({
        @AttributeOverride(name="street", column=@Column(name="ex_street_tra")),
        @AttributeOverride(name="zipCode", column=@Column(name="ex_zip_code_tra")),
        @AttributeOverride(name="city", column=@Column(name="ex_city_tra"))
    })
    @Embedded
    private AddressEntity extra;
    public Address getExtra() {
        if (extra == null)
            return null;
        return new Address(extra.getStreet(), extra.getZipCode(), extra.getCity());
    }
    public void setExtra(Address _x) {
        if (_x == null) {
            extra = null;
        } else {
            extra = new AddressEntity();
            extra.setStreet(_x.getStreet());
            extra.setZipCode(_x.getZipCode());
            extra.setCity(_x.getCity());
        }
    }
    @Column(name="address_lines01", length=80)
    String addressLines01;
    public String getAddressLines01() {
        return addressLines01;
    }
    public void setAddressLines01(String addressLines01) {
        this.addressLines01 = addressLines01;
    }
    @Column(name="address_lines02", length=80)
    String addressLines02;
    public String getAddressLines02() {
        return addressLines02;
    }
    public void setAddressLines02(String addressLines02) {
        this.addressLines02 = addressLines02;
    }
    @Column(name="address_lines03", length=80)
    String addressLines03;
    public String getAddressLines03() {
        return addressLines03;
    }
    public void setAddressLines03(String addressLines03) {
        this.addressLines03 = addressLines03;
    }
    public List<String> getAddressLines() {
        List<String> _a = new ArrayList<String>(3);
        _a.add(getAddressLines01());
        _a.add(getAddressLines02());
        _a.add(getAddressLines03());
        return _a;
    }
    public void setAddressLines(List<String> _a) {
        setAddressLines01(null);
        setAddressLines02(null);
        setAddressLines03(null);
        if (_a == null)
            return;
        if (_a.size() >= 1) setAddressLines01(_a.get(0));
        if (_a.size() >= 2) setAddressLines02(_a.get(1));
        if (_a.size() >= 3) setAddressLines03(_a.get(2));
    }
    @AttributeOverrides({
        @AttributeOverride(name="street", column=@Column(name="streetx001")),
        @AttributeOverride(name="zipCode", column=@Column(name="zip_codex001")),
        @AttributeOverride(name="city", column=@Column(name="cityx001"))
    })
    @Embedded
    private AddressEntity evenMorex001;
    public Address getEvenMorex001() {
        if (evenMorex001 == null)
            return null;
        return new Address(evenMorex001.getStreet(), evenMorex001.getZipCode(), evenMorex001.getCity());
    }
    public void setEvenMorex001(Address _x) {
        if (_x == null) {
            evenMorex001 = null;
        } else {
            evenMorex001 = new AddressEntity();
            evenMorex001.setStreet(_x.getStreet());
            evenMorex001.setZipCode(_x.getZipCode());
            evenMorex001.setCity(_x.getCity());
        }
    }
    @AttributeOverrides({
        @AttributeOverride(name="street", column=@Column(name="streetx002")),
        @AttributeOverride(name="zipCode", column=@Column(name="zip_codex002")),
        @AttributeOverride(name="city", column=@Column(name="cityx002"))
    })
    @Embedded
    private AddressEntity evenMorex002;
    public Address getEvenMorex002() {
        if (evenMorex002 == null)
            return null;
        return new Address(evenMorex002.getStreet(), evenMorex002.getZipCode(), evenMorex002.getCity());
    }
    public void setEvenMorex002(Address _x) {
        if (_x == null) {
            evenMorex002 = null;
        } else {
            evenMorex002 = new AddressEntity();
            evenMorex002.setStreet(_x.getStreet());
            evenMorex002.setZipCode(_x.getZipCode());
            evenMorex002.setCity(_x.getCity());
        }
    }
    @AttributeOverrides({
        @AttributeOverride(name="street", column=@Column(name="streetx003")),
        @AttributeOverride(name="zipCode", column=@Column(name="zip_codex003")),
        @AttributeOverride(name="city", column=@Column(name="cityx003"))
    })
    @Embedded
    private AddressEntity evenMorex003;
    public Address getEvenMorex003() {
        if (evenMorex003 == null)
            return null;
        return new Address(evenMorex003.getStreet(), evenMorex003.getZipCode(), evenMorex003.getCity());
    }
    public void setEvenMorex003(Address _x) {
        if (_x == null) {
            evenMorex003 = null;
        } else {
            evenMorex003 = new AddressEntity();
            evenMorex003.setStreet(_x.getStreet());
            evenMorex003.setZipCode(_x.getZipCode());
            evenMorex003.setCity(_x.getCity());
        }
    }
    public List<Address> getEvenMore() {
        List<Address> _a = new ArrayList<Address>(3);
        _a.add(getEvenMorex001());
        _a.add(getEvenMorex002());
        _a.add(getEvenMorex003());
        return _a;
    }
    public void setEvenMore(List<Address> _a) {
        setEvenMorex001(null);
        setEvenMorex002(null);
        setEvenMorex003(null);
        if (_a == null)
            return;
        if (_a.size() >= 1) setEvenMorex001(_a.get(0));
        if (_a.size() >= 2) setEvenMorex002(_a.get(1));
        if (_a.size() >= 3) setEvenMorex003(_a.get(2));
    }
    @AttributeOverrides({
        @AttributeOverride(name="data1", column=@Column(name="my_data1")),
        @AttributeOverride(name="props01", column=@Column(name="my_props01")),
        @AttributeOverride(name="props02", column=@Column(name="my_props02")),
        @AttributeOverride(name="props03", column=@Column(name="my_props03")),
        @AttributeOverride(name="props04", column=@Column(name="my_props04"))
    })
    @Embedded
    private Add2Entity myAdd2;
    public Add2 getMyAdd2() {
        if (myAdd2 == null)
            return null;
        return new Add2(myAdd2.getData1(), myAdd2.getProps());
    }
    public void setMyAdd2(Add2 _x) {
        if (_x == null) {
            myAdd2 = null;
        } else {
            myAdd2 = new Add2Entity();
            myAdd2.setData1(_x.getData1());
            myAdd2.setProps(_x.getProps());
        }
    }
    @Override
    public int hashCode() {
        return personKey == null ? -1 : personKey.hashCode();
    }
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null || this.getClass() != obj.getClass())
            return false;
        if (personKey == null) // not yet assigned => treat it as different
            return false;
        return this.personKey.equals(((PersonEntity)obj).personKey);
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // no isActive column in this entity, create stubs to satisfy interface
    public void set$Active(boolean _a) {
        // throw new RuntimeException("Entity PersonEntity does not have an isActive field");
    }
    public boolean get$Active() {
        return true;  // no isActive column => all rows are active by default
    }
    // no version column of type int or Integer, write stub
    public void set$IntVersion(int _v) {
        // throw new RuntimeException("Entity PersonEntity does not have an integer type version field");
    }
    public int get$IntVersion() {
        return -1;
    }
    public static Class<Tracking> class$TrackingClass() {
        return Tracking.class;
    }
    @Override
    public String get$TrackingPQON() {
        return "embeddables.Tracking";
    }
    @Override
    public Class<Tracking> get$TrackingClass() {
        return Tracking.class;
    }
    
    public static Class<Long> class$KeyClass() {
        return Long.class;
    }
    @Override
    public Class<Long> get$KeyClass() {
        return Long.class;
    }
    @Override
    public Long get$Key() throws ApplicationException {
        return personKey;
    }
    @Override
    public void set$Key(Long _k) {
        setPersonKey(_k);  // no direct assigned due to possible enum or temporal type, with implied conversions
    }
    
    @Override
    public Tracking get$Tracking() throws ApplicationException {
        Tracking _r = new Tracking();
        // auto-generated data getter for Tracking
        _r.setUserId(getUserId());
        return _r;
    }
    @Override
    public void set$Tracking(Tracking _d) {
        // auto-generated data setter for Tracking
        setUserId(_d.getUserId());
    }
    @Override
    public BonaPersistableBase mergeFrom(final BonaPersistableBase _b) {
        if (_b instanceof PersonEntity) {
            PersonEntity _x = (PersonEntity)_b;
            setPersonKey(_x.getPersonKey());
            name = _x.name;
            homeAddress = _x.homeAddress;
            addressWork = _x.addressWork;
            extra = _x.extra;
            addressLines01 = _x.addressLines01;
            addressLines02 = _x.addressLines02;
            addressLines03 = _x.addressLines03;
            evenMorex001 = _x.evenMorex001;
            evenMorex002 = _x.evenMorex002;
            evenMorex003 = _x.evenMorex003;
            myAdd2 = _x.myAdd2;
        }
        return this;
    }
    
    
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/embeddables/Add2.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.embeddables;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



public final class Add2
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -955566799L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        map.putIfAbsent("props.unroll", "");
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "embeddables.Add2";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$data1 = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "data1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 10, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$props = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "props", Multiplicity.LIST, 0, 0, 4, DataCategory.STRING,
        "String", false, true, false, false, false, 10, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$data1;
        field$array[1] = meta$$props;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    String data1;
    List<String> props;
    // auto-generated getters and setters
    public String getData1() {
        return data1;
    }
    public void setData1(String data1) {
        this.data1 = data1;
    }
    public List<String> getProps() {
        return props;
    }
    public void setProps(List<String> props) {
        this.props = props;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(meta$$data1, data1);
        if (props == null) {
            w.writeNullCollection(meta$$props);
        } else {
            w.startArray(props.size(), 4, 0);
            for (String _i : props)
                w.addField(meta$$props, _i);
            w.terminateArray();
        }
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("data1")) {
            w.addField(meta$$data1, data1);
            return;
        }
        if (_n.equals("props")) {
            if (props == null) {
                w.writeNullCollection(meta$$props);
            } else {
                if (pfc.index < 0) {
                    w.startArray(props.size(), 4, 0);
                    for (String _i : props) {
                        w.addField(meta$$props, _i);
                    }
                    w.terminateArray();
                } else {
                    if (pfc.index < props.size()) {
                        // output single element
                        w.addField(meta$$props, props.get(pfc.index));
                    }
                }
            }
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        data1 = p.readString    ("data1", false, 10, true, false, false, true);
        _length = p.parseArrayStart("props", true, 4, 0);
        if (_length < 0) {
            props = null;
        } else {
            props = new ArrayList<String>(_length);
            for (int _i = 0; _i < _length; ++_i)
                props.add(p.readString    ("props", true, 10, true, false, false, true));
            p.parseArrayEnd();
        }
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (data1 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "data1", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (props != null) {
        }
        if (data1 != null) {
            if (data1.length() > 10)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "data1.length=" + data1.length() + " > 10",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (props != null)
            for (String _i : props)
        if (_i != null) {
            if (_i.length() > 10)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "_i.length=" + _i.length() + " > 10",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (data1 == null ? 0 : data1.hashCode());
        _hash = 29 * _hash + (props == null ? 0 : props.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Add2))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Add2))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        Add2 that = (Add2)_that;
        return true
        && ((data1 == null && that.data1 == null) || (data1 != null && data1.equals(that.data1)))
        && ((props == null && that.props == null) || (props != null && that.props != null && xCompareSub$props(that)))
        ;
    }
    private boolean xCompareSub$props(Add2 that) {
        // both props and that props are known to be not null
        if (props.size() != that.props.size())
            return false;
        // indexed access is not optional, but sequential access will be left for later optimization
        for (int _i = 0; _i < props.size(); ++_i)
            if (!(((props.get(_i) == null && that.props.get(_i) == null) || (props.get(_i) != null && props.get(_i).equals(that.props.get(_i))))))
                return false;
        return true;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        data1 = _cvt.convert(data1, meta$$data1);
        props = _cvt.convertList(props, meta$$props);
    }
    // default no-argument constructor
    public Add2() {
    }
    
    // default all-arguments constructor
    public Add2(String data1
    , List<String> props
    ) {
        this.data1 = data1;
        this.props = props;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Add2.class) {
            return (T) new Add2(getData1(), getProps());
        }
        throw new IllegalArgumentException("Add2 does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/embeddables/Address.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.embeddables;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



public final class Address
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -245263756L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "embeddables.Address";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$street = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "street", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 20, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$zipCode = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "zipCode", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 10, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$city = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "city", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 30, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(3);
        FieldDefinition [] field$array = new FieldDefinition[3];
        field$array[0] = meta$$street;
        field$array[1] = meta$$zipCode;
        field$array[2] = meta$$city;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    String street;
    String zipCode;
    String city;
    // auto-generated getters and setters
    public String getStreet() {
        return street;
    }
    public void setStreet(String street) {
        this.street = street;
    }
    public String getZipCode() {
        return zipCode;
    }
    public void setZipCode(String zipCode) {
        this.zipCode = zipCode;
    }
    public String getCity() {
        return city;
    }
    public void setCity(String city) {
        this.city = city;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(meta$$street, street);
        w.addField(meta$$zipCode, zipCode);
        w.addField(meta$$city, city);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("street")) {
            w.addField(meta$$street, street);
            return;
        }
        if (_n.equals("zipCode")) {
            w.addField(meta$$zipCode, zipCode);
            return;
        }
        if (_n.equals("city")) {
            w.addField(meta$$city, city);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        street = p.readString    ("street", false, 20, true, false, false, true);
        zipCode = p.readString    ("zipCode", true, 10, true, false, false, false);
        city = p.readString    ("city", true, 30, true, false, false, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (street == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "street", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (street != null) {
            if (street.length() > 20)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "street.length=" + street.length() + " > 20",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (zipCode != null) {
            if (zipCode.length() > 10)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "zipCode.length=" + zipCode.length() + " > 10",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (city != null) {
            if (city.length() > 30)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "city.length=" + city.length() + " > 30",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (street == null ? 0 : street.hashCode());
        _hash = 29 * _hash + (zipCode == null ? 0 : zipCode.hashCode());
        _hash = 29 * _hash + (city == null ? 0 : city.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Address))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Address))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        Address that = (Address)_that;
        return true
        && ((street == null && that.street == null) || (street != null && street.equals(that.street)))
        && ((zipCode == null && that.zipCode == null) || (zipCode != null && zipCode.equals(that.zipCode)))
        && ((city == null && that.city == null) || (city != null && city.equals(that.city)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        street = _cvt.convert(street, meta$$street);
        zipCode = _cvt.convert(zipCode, meta$$zipCode);
        city = _cvt.convert(city, meta$$city);
    }
    // default no-argument constructor
    public Address() {
    }
    
    // default all-arguments constructor
    public Address(String street
    , String zipCode
    , String city
    ) {
        this.street = street;
        this.zipCode = zipCode;
        this.city = city;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Address.class) {
            return (T) new Address(getStreet(), getZipCode(), getCity());
        }
        throw new IllegalArgumentException("Address does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/embeddables/Person.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.embeddables;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



public class Person
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 1254151381L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
        map.putIfAbsent("addressLines.unroll", "");
        map.putIfAbsent("evenMore.unroll", "x%03d");
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "embeddables.Person";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$personKey = new NumericElementaryDataItem(Visibility.DEFAULT, false, "personKey", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, false, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$name = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "name", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 20, 0, null);
    protected static final ObjectReference meta$$homeAddress = new ObjectReference(Visibility.DEFAULT, false, "homeAddress", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "Address", false, false, "Address");
    protected static final ObjectReference meta$$addressWork = new ObjectReference(Visibility.DEFAULT, false, "addressWork", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "Address", false, false, "Address");
    protected static final ObjectReference meta$$extra = new ObjectReference(Visibility.DEFAULT, false, "extra", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "Address", false, false, "Address");
    protected static final AlphanumericElementaryDataItem meta$$addressLines = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "addressLines", Multiplicity.LIST, 0, 0, 3, DataCategory.STRING,
        "String", false, true, false, false, false, 80, 0, null);
    protected static final ObjectReference meta$$evenMore = new ObjectReference(Visibility.DEFAULT, false, "evenMore", Multiplicity.LIST, 0, 0, 3, DataCategory.OBJECT,
        "Address", false, false, "Address");
    protected static final ObjectReference meta$$myAdd2 = new ObjectReference(Visibility.DEFAULT, false, "myAdd2", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "Add2", false, false, "Add2");
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(8);
        FieldDefinition [] field$array = new FieldDefinition[8];
        field$array[0] = meta$$personKey;
        field$array[1] = meta$$name;
        field$array[2] = meta$$homeAddress;
        field$array[3] = meta$$addressWork;
        field$array[4] = meta$$extra;
        field$array[5] = meta$$addressLines;
        field$array[6] = meta$$evenMore;
        field$array[7] = meta$$myAdd2;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    Long personKey;
    String name;
    Address homeAddress;
    Address addressWork;
    Address extra;
    List<String> addressLines;
    List<Address> evenMore;
    Add2 myAdd2;
    // auto-generated getters and setters
    public Long getPersonKey() {
        return personKey;
    }
    public void setPersonKey(Long personKey) {
        this.personKey = personKey;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Address getHomeAddress() {
        return homeAddress;
    }
    public void setHomeAddress(Address homeAddress) {
        this.homeAddress = homeAddress;
    }
    public Address getAddressWork() {
        return addressWork;
    }
    public void setAddressWork(Address addressWork) {
        this.addressWork = addressWork;
    }
    public Address getExtra() {
        return extra;
    }
    public void setExtra(Address extra) {
        this.extra = extra;
    }
    public List<String> getAddressLines() {
        return addressLines;
    }
    public void setAddressLines(List<String> addressLines) {
        this.addressLines = addressLines;
    }
    public List<Address> getEvenMore() {
        return evenMore;
    }
    public void setEvenMore(List<Address> evenMore) {
        this.evenMore = evenMore;
    }
    public Add2 getMyAdd2() {
        return myAdd2;
    }
    public void setMyAdd2(Add2 myAdd2) {
        this.myAdd2 = myAdd2;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        if (personKey == null) w.writeNull(meta$$personKey); else w.addField(personKey);
        w.addField(meta$$name, name);
        w.addField((BonaPortable)homeAddress);
        w.addField((BonaPortable)addressWork);
        w.addField((BonaPortable)extra);
        if (addressLines == null) {
            w.writeNullCollection(meta$$addressLines);
        } else {
            w.startArray(addressLines.size(), 3, 0);
            for (String _i : addressLines)
                w.addField(meta$$addressLines, _i);
            w.terminateArray();
        }
        if (evenMore == null) {
            w.writeNullCollection(meta$$evenMore);
        } else {
            w.startArray(evenMore.size(), 3, 0);
            for (Address _i : evenMore)
                w.addField((BonaPortable)_i);
            w.terminateArray();
        }
        w.addField((BonaPortable)myAdd2);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("personKey")) {
            if (personKey == null) w.writeNull(meta$$personKey); else w.addField(personKey);
            return;
        }
        if (_n.equals("name")) {
            w.addField(meta$$name, name);
            return;
        }
        if (_n.equals("homeAddress")) {
            if (homeAddress == null) {
                w.writeNull(meta$$homeAddress);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)homeAddress);             // full / recursive object output
            } else {
                // write a specific subcomponent
                homeAddress.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        if (_n.equals("addressWork")) {
            if (addressWork == null) {
                w.writeNull(meta$$addressWork);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)addressWork);             // full / recursive object output
            } else {
                // write a specific subcomponent
                addressWork.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        if (_n.equals("extra")) {
            if (extra == null) {
                w.writeNull(meta$$extra);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)extra);             // full / recursive object output
            } else {
                // write a specific subcomponent
                extra.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        if (_n.equals("addressLines")) {
            if (addressLines == null) {
                w.writeNullCollection(meta$$addressLines);
            } else {
                if (pfc.index < 0) {
                    w.startArray(addressLines.size(), 3, 0);
                    for (String _i : addressLines) {
                        w.addField(meta$$addressLines, _i);
                    }
                    w.terminateArray();
                } else {
                    if (pfc.index < addressLines.size()) {
                        // output single element
                        w.addField(meta$$addressLines, addressLines.get(pfc.index));
                    }
                }
            }
            return;
        }
        if (_n.equals("evenMore")) {
            if (evenMore == null) {
                w.writeNullCollection(meta$$evenMore);
            } else {
                if (pfc.index < 0) {
                    w.startArray(evenMore.size(), 3, 0);
                    for (Address _i : evenMore) {
                        if (_i == null) {
                            w.writeNull(meta$$evenMore);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)_i);             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            _i.foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                    w.terminateArray();
                } else {
                    if (pfc.index < evenMore.size()) {
                        // output single element
                        if (evenMore.get(pfc.index) == null) {
                            w.writeNull(meta$$evenMore);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)evenMore.get(pfc.index));             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            evenMore.get(pfc.index).foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                }
            }
            return;
        }
        if (_n.equals("myAdd2")) {
            if (myAdd2 == null) {
                w.writeNull(meta$$myAdd2);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)myAdd2);             // full / recursive object output
            } else {
                // write a specific subcomponent
                myAdd2.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        personKey = p.readLong      ("personKey", true, false);
        name = p.readString    ("name", true, 20, true, false, false, true);
        homeAddress = (Address)p.readObject("homeAddress", Address.class, true, false);
        addressWork = (Address)p.readObject("addressWork", Address.class, true, false);
        extra = (Address)p.readObject("extra", Address.class, true, false);
        _length = p.parseArrayStart("addressLines", true, 3, 0);
        if (_length < 0) {
            addressLines = null;
        } else {
            addressLines = new ArrayList<String>(_length);
            for (int _i = 0; _i < _length; ++_i)
                addressLines.add(p.readString    ("addressLines", true, 80, true, false, false, true));
            p.parseArrayEnd();
        }
        _length = p.parseArrayStart("evenMore", true, 3, 0);
        if (_length < 0) {
            evenMore = null;
        } else {
            evenMore = new ArrayList<Address>(_length);
            for (int _i = 0; _i < _length; ++_i)
                evenMore.add((Address)p.readObject("evenMore", Address.class, true, false));
            p.parseArrayEnd();
        }
        myAdd2 = (Add2)p.readObject("myAdd2", Add2.class, true, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (homeAddress != null)
            homeAddress.validate();  // check object
        if (addressWork != null)
            addressWork.validate();  // check object
        if (extra != null)
            extra.validate();  // check object
        if (addressLines != null) {
        }
        if (evenMore != null) {
        }
        if (evenMore != null)
            for (Address _i : evenMore)
        if (_i != null)
            _i.validate();  // check object
        if (myAdd2 != null)
            myAdd2.validate();  // check object
        if (name != null) {
            if (name.length() > 20)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "name.length=" + name.length() + " > 20",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (addressLines != null)
            for (String _i : addressLines)
        if (_i != null) {
            if (_i.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "_i.length=" + _i.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (personKey == null ? 0 : personKey.hashCode());
        _hash = 29 * _hash + (name == null ? 0 : name.hashCode());
        _hash = 29 * _hash + (homeAddress == null ? 0 : homeAddress.hashCode());
        _hash = 29 * _hash + (addressWork == null ? 0 : addressWork.hashCode());
        _hash = 29 * _hash + (extra == null ? 0 : extra.hashCode());
        _hash = 29 * _hash + (addressLines == null ? 0 : addressLines.hashCode());
        _hash = 29 * _hash + (evenMore == null ? 0 : evenMore.hashCode());
        _hash = 29 * _hash + (myAdd2 == null ? 0 : myAdd2.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Person))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Person))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        Person that = (Person)_that;
        return true
        && ((personKey == null && that.personKey == null) || (personKey != null && personKey.equals(that.personKey)))
        && ((name == null && that.name == null) || (name != null && name.equals(that.name)))
        && ((homeAddress == null && that.homeAddress == null) || (homeAddress != null && homeAddress.hasSameContentsAs(that.homeAddress)))
        && ((addressWork == null && that.addressWork == null) || (addressWork != null && addressWork.hasSameContentsAs(that.addressWork)))
        && ((extra == null && that.extra == null) || (extra != null && extra.hasSameContentsAs(that.extra)))
        && ((addressLines == null && that.addressLines == null) || (addressLines != null && that.addressLines != null && xCompareSub$addressLines(that)))
        && ((evenMore == null && that.evenMore == null) || (evenMore != null && that.evenMore != null && xCompareSub$evenMore(that)))
        && ((myAdd2 == null && that.myAdd2 == null) || (myAdd2 != null && myAdd2.hasSameContentsAs(that.myAdd2)))
        ;
    }
    private boolean xCompareSub$addressLines(Person that) {
        // both addressLines and that addressLines are known to be not null
        if (addressLines.size() != that.addressLines.size())
            return false;
        // indexed access is not optional, but sequential access will be left for later optimization
        for (int _i = 0; _i < addressLines.size(); ++_i)
            if (!(((addressLines.get(_i) == null && that.addressLines.get(_i) == null) || (addressLines.get(_i) != null && addressLines.get(_i).equals(that.addressLines.get(_i))))))
                return false;
        return true;
    }
    private boolean xCompareSub$evenMore(Person that) {
        // both evenMore and that evenMore are known to be not null
        if (evenMore.size() != that.evenMore.size())
            return false;
        // indexed access is not optional, but sequential access will be left for later optimization
        for (int _i = 0; _i < evenMore.size(); ++_i)
            if (!(((evenMore.get(_i) == null && that.evenMore.get(_i) == null) || (evenMore.get(_i) != null && evenMore.get(_i).hasSameContentsAs(that.evenMore.get(_i))))))
                return false;
        return true;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        name = _cvt.convert(name, meta$$name);
        if (homeAddress != null)
            homeAddress.treeWalkString(_cvt);
        if (addressWork != null)
            addressWork.treeWalkString(_cvt);
        if (extra != null)
            extra.treeWalkString(_cvt);
        addressLines = _cvt.convertList(addressLines, meta$$addressLines);
        if (evenMore != null)
            for (Address _i : evenMore)
        if (_i != null)
            _i.treeWalkString(_cvt);
        if (myAdd2 != null)
            myAdd2.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public Person() {
    }
    
    // default all-arguments constructor
    public Person(Long personKey
    , String name
    , Address homeAddress
    , Address addressWork
    , Address extra
    , List<String> addressLines
    , List<Address> evenMore
    , Add2 myAdd2
    ) {
        this.personKey = personKey;
        this.name = name;
        this.homeAddress = homeAddress;
        this.addressWork = addressWork;
        this.extra = extra;
        this.addressLines = addressLines;
        this.evenMore = evenMore;
        this.myAdd2 = myAdd2;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Person.class) {
            return (T) new Person(getPersonKey(), getName(), getHomeAddress(), getAddressWork(), getExtra(), getAddressLines(), getEvenMore(), getMyAdd2());
        }
        throw new IllegalArgumentException("Person does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/embeddables/Tracking.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.embeddables;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



public class Tracking
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -819005385L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "embeddables.Tracking";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$userId = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "userId", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, true, 8, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(1);
        FieldDefinition [] field$array = new FieldDefinition[1];
        field$array[0] = meta$$userId;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    String userId;
    // auto-generated getters and setters
    public String getUserId() {
        return userId;
    }
    public void setUserId(String userId) {
        this.userId = userId;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(meta$$userId, userId);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("userId")) {
            w.addField(meta$$userId, userId);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        userId = p.readString    ("userId", true, 8, true, false, false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (userId != null) {
            if (userId.length() > 8)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "userId.length=" + userId.length() + " > 8",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (userId == null ? 0 : userId.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Tracking))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Tracking))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        Tracking that = (Tracking)_that;
        return true
        && ((userId == null && that.userId == null) || (userId != null && userId.equals(that.userId)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        userId = _cvt.convert(userId, meta$$userId);
    }
    // default no-argument constructor
    public Tracking() {
    }
    
    // default all-arguments constructor
    public Tracking(String userId
    ) {
        this.userId = userId;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Tracking.class) {
            return (T) new Tracking(getUserId());
        }
        throw new IllegalArgumentException("Tracking does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/embeddables/package-info.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

package de.jpaw.bonaparte.pojos.embeddables;
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/examples/pkey/EDto.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.examples.pkey;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



public class EDto
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 1379541652L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "examples.pkey.EDto";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final ObjectReference meta$$myCompositeKey = new ObjectReference(Visibility.DEFAULT, false, "myCompositeKey", Multiplicity.SCALAR, 0, 0, 0, DataCategory.OBJECT,
        "EKey", false, false, "EKey");
    protected static final AlphanumericElementaryDataItem meta$$data = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "data", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, false, false, true, true, 80, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$myCompositeKey;
        field$array[1] = meta$$data;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    EKey myCompositeKey;
    String data;
    // auto-generated getters and setters
    public EKey getMyCompositeKey() {
        return myCompositeKey;
    }
    public void setMyCompositeKey(EKey myCompositeKey) {
        this.myCompositeKey = myCompositeKey;
    }
    public String getData() {
        return data;
    }
    public void setData(String data) {
        this.data = data;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField((BonaPortable)myCompositeKey);
        w.addField(meta$$data, data);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("myCompositeKey")) {
            if (myCompositeKey == null) {
                w.writeNull(meta$$myCompositeKey);
            } else if (pfc.getComponent() == null) {
                w.addField((BonaPortable)myCompositeKey);             // full / recursive object output
            } else {
                // write a specific subcomponent
                myCompositeKey.foldedOutput(w, pfc.getComponent());   // recurse specific field
            }
            return;
        }
        if (_n.equals("data")) {
            w.addField(meta$$data, data);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        myCompositeKey = (EKey)p.readObject("myCompositeKey", EKey.class, true, false);
        data = p.readString    ("data", true, 80, false, false, false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (myCompositeKey != null)
            myCompositeKey.validate();  // check object
        if (data != null) {
            if (data.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "data.length=" + data.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (myCompositeKey == null ? 0 : myCompositeKey.hashCode());
        _hash = 29 * _hash + (data == null ? 0 : data.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof EDto))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof EDto))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        EDto that = (EDto)_that;
        return true
        && ((myCompositeKey == null && that.myCompositeKey == null) || (myCompositeKey != null && myCompositeKey.hasSameContentsAs(that.myCompositeKey)))
        && ((data == null && that.data == null) || (data != null && data.equals(that.data)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        if (myCompositeKey != null)
            myCompositeKey.treeWalkString(_cvt);
        data = _cvt.convert(data, meta$$data);
    }
    // default no-argument constructor
    public EDto() {
    }
    
    // default all-arguments constructor
    public EDto(EKey myCompositeKey
    , String data
    ) {
        this.myCompositeKey = myCompositeKey;
        this.data = data;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == EDto.class) {
            return (T) new EDto(getMyCompositeKey(), getData());
        }
        throw new IllegalArgumentException("EDto does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/examples/pkey/EDto2.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.examples.pkey;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



public class EDto2
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -183881698L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "examples.pkey.EDto2";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$key1 = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "key1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, false, false, true, true, 8, 0, null);
    protected static final NumericElementaryDataItem meta$$key2 = new NumericElementaryDataItem(Visibility.DEFAULT, true, "key2", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, true, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$data = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "data", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, false, false, true, true, 80, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(3);
        FieldDefinition [] field$array = new FieldDefinition[3];
        field$array[0] = meta$$key1;
        field$array[1] = meta$$key2;
        field$array[2] = meta$$data;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    String key1;
    Integer key2;
    String data;
    // auto-generated getters and setters
    public String getKey1() {
        return key1;
    }
    public void setKey1(String key1) {
        this.key1 = key1;
    }
    public Integer getKey2() {
        return key2;
    }
    public void setKey2(Integer key2) {
        this.key2 = key2;
    }
    public String getData() {
        return data;
    }
    public void setData(String data) {
        this.data = data;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(meta$$key1, key1);
        if (key2 == null) w.writeNull(meta$$key2); else w.addField(key2);
        w.addField(meta$$data, data);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("key1")) {
            w.addField(meta$$key1, key1);
            return;
        }
        if (_n.equals("key2")) {
            if (key2 == null) w.writeNull(meta$$key2); else w.addField(key2);
            return;
        }
        if (_n.equals("data")) {
            w.addField(meta$$data, data);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        key1 = p.readString    ("key1", false, 8, false, false, false, false);
        key2 = p.readInteger   ("key2", false, true);
        data = p.readString    ("data", true, 80, false, false, false, false);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (key1 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "key1", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (key2 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "key2", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (key1 != null) {
            if (key1.length() > 8)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "key1.length=" + key1.length() + " > 8",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (data != null) {
            if (data.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "data.length=" + data.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (key1 == null ? 0 : key1.hashCode());
        _hash = 29 * _hash + (key2 == null ? 0 : key2.hashCode());
        _hash = 29 * _hash + (data == null ? 0 : data.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof EDto2))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof EDto2))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        EDto2 that = (EDto2)_that;
        return true
        && ((key1 == null && that.key1 == null) || (key1 != null && key1.equals(that.key1)))
        && ((key2 == null && that.key2 == null) || (key2 != null && key2.equals(that.key2)))
        && ((data == null && that.data == null) || (data != null && data.equals(that.data)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        key1 = _cvt.convert(key1, meta$$key1);
        data = _cvt.convert(data, meta$$data);
    }
    // default no-argument constructor
    public EDto2() {
    }
    
    // default all-arguments constructor
    public EDto2(String key1
    , Integer key2
    , String data
    ) {
        this.key1 = key1;
        this.key2 = key2;
        this.data = data;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == EDto2.class) {
            return (T) new EDto2(getKey1(), getKey2(), getData());
        }
        throw new IllegalArgumentException("EDto2 does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/examples/pkey/EKey.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.examples.pkey;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



public final class EKey
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 1379547924L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "examples.pkey.EKey";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final AlphanumericElementaryDataItem meta$$key1 = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "key1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, false, false, true, true, 8, 0, null);
    protected static final NumericElementaryDataItem meta$$key2 = new NumericElementaryDataItem(Visibility.DEFAULT, true, "key2", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, true, 0, 0, false, false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(true);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$key1;
        field$array[1] = meta$$key2;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    String key1;
    Integer key2;
    // auto-generated getters and setters
    public String getKey1() {
        return key1;
    }
    public void setKey1(String key1) {
        this.key1 = key1;
    }
    public Integer getKey2() {
        return key2;
    }
    public void setKey2(Integer key2) {
        this.key2 = key2;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(meta$$key1, key1);
        if (key2 == null) w.writeNull(meta$$key2); else w.addField(key2);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("key1")) {
            w.addField(meta$$key1, key1);
            return;
        }
        if (_n.equals("key2")) {
            if (key2 == null) w.writeNull(meta$$key2); else w.addField(key2);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        key1 = p.readString    ("key1", false, 8, false, false, false, false);
        key2 = p.readInteger   ("key2", false, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (key1 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "key1", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (key2 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "key2", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (key1 != null) {
            if (key1.length() > 8)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "key1.length=" + key1.length() + " > 8",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (key1 == null ? 0 : key1.hashCode());
        _hash = 29 * _hash + (key2 == null ? 0 : key2.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof EKey))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof EKey))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        EKey that = (EKey)_that;
        return true
        && ((key1 == null && that.key1 == null) || (key1 != null && key1.equals(that.key1)))
        && ((key2 == null && that.key2 == null) || (key2 != null && key2.equals(that.key2)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        key1 = _cvt.convert(key1, meta$$key1);
    }
    // default no-argument constructor
    public EKey() {
    }
    
    // default all-arguments constructor
    public EKey(String key1
    , Integer key2
    ) {
        this.key1 = key1;
        this.key2 = key2;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == EKey.class) {
            return (T) new EKey(getKey1(), getKey2());
        }
        throw new IllegalArgumentException("EKey does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/examples/pkey/entities/EKeyEntity.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.examples.pkey.entities;

import javax.persistence.EntityManager;
import javax.persistence.Embeddable;
import javax.persistence.Embedded;
import javax.persistence.Column;
import javax.persistence.EmbeddedId;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.ManyToOne;
import javax.persistence.JoinColumn;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Serializable;

import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.ByteArrayComposer;
import de.jpaw.bonaparte.core.ByteArrayParser;
import de.jpaw.bonaparte.core.MessageParserException;

@Embeddable
public class EKeyEntity implements Serializable, Cloneable {
    // table columns of java class EKey
    @Column(name="key1", nullable=false, length=8)
    String key1;
    public String getKey1() {
        return key1;
    }
    public void setKey1(String key1) {
        this.key1 = key1;
    }
    @Column(name="key2", nullable=false)
    Integer key2;
    public Integer getKey2() {
        return key2;
    }
    public void setKey2(Integer key2) {
        this.key2 = key2;
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (key1 == null ? 0 : key1.hashCode());
        _hash = 29 * _hash + (key2 == null ? 0 : key2.hashCode());
        return _hash;
    }
    
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof EKeyEntity))
            return false;
        if (this == _that)
            return true;
        EKeyEntity that = (EKeyEntity)_that;
        return true
        && ((key1 == null && that.key1 == null) || key1.equals(that.key1))
        && ((key2 == null && that.key2 == null) || key2.equals(that.key2))
        ;
    }
    @Override
    public EKeyEntity clone() {
        try {
            return (EKeyEntity)super.clone();
        } catch (CloneNotSupportedException e) {
            return this;  // fallback
        }
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/examples/pkey/entities/EmbeddedPkEntity.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.examples.pkey.entities;

import javax.persistence.EntityManager;
import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.Version;
import javax.persistence.Column;
import javax.persistence.Lob;
import javax.persistence.Basic;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.Id;
import javax.persistence.IdClass;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.NoResultException;
import javax.persistence.TypedQuery;
import javax.persistence.EmbeddedId;
import javax.persistence.Embedded;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.MapKey;
import javax.persistence.MapKeyJoinColumn;
import javax.persistence.JoinColumn;
import javax.persistence.JoinColumns;
import javax.persistence.ElementCollection;
import javax.persistence.MapKeyColumn;
import javax.persistence.CollectionTable;
import javax.persistence.EntityListeners;
import javax.persistence.UniqueConstraint;
import javax.persistence.AttributeOverride;
import javax.persistence.AttributeOverrides;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Serializable;

import de.jpaw.bonaparte.jpa.BonaPersistableNoData;
import de.jpaw.bonaparte.jpa.BonaPersistableTracking;
import de.jpaw.bonaparte.jpa.BonaPersistableBase;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.jpa.KeyClass;
import de.jpaw.bonaparte.jpa.DataClass;
import de.jpaw.bonaparte.jpa.TrackingClass;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.ByteArrayComposer;
import de.jpaw.bonaparte.core.ByteArrayParser;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.pojos.examples.pkey.EDto;
import de.jpaw.bonaparte.pojos.examples.pkey.EKey;

@DataClass(EDto.class)
@KeyClass(EKey.class)
@Entity
@Table(name="tests_embedded_pk_entity")
public class EmbeddedPkEntity implements BonaPersistableNoData<EKey, BonaPortable> {
    // table columns of java class EDto
    @EmbeddedId
    private EKeyEntity myCompositeKey;
    public EKey getMyCompositeKey() {
        if (myCompositeKey == null)
            return null;
        return new EKey(myCompositeKey.getKey1(), myCompositeKey.getKey2());
    }
    public void setMyCompositeKey(EKey _x) {
        if (_x == null) {
            myCompositeKey = null;
        } else {
            myCompositeKey = new EKeyEntity();
            myCompositeKey.setKey1(_x.getKey1());
            myCompositeKey.setKey2(_x.getKey2());
        }
    }
    @Column(name="data", length=80)
    String data;
    public String getData() {
        return data;
    }
    public void setData(String data) {
        this.data = data;
    }
    @Override
    public int hashCode() {
        return myCompositeKey == null ? -1 : myCompositeKey.hashCode();
    }
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null || this.getClass() != obj.getClass())
            return false;
        if (myCompositeKey == null) // not yet assigned => treat it as different
            return false;
        return this.myCompositeKey.equals(((EmbeddedPkEntity)obj).myCompositeKey);
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // no isActive column in this entity, create stubs to satisfy interface
    public void set$Active(boolean _a) {
        // throw new RuntimeException("Entity EmbeddedPkEntity does not have an isActive field");
    }
    public boolean get$Active() {
        return true;  // no isActive column => all rows are active by default
    }
    // no version column of type int or Integer, write stub
    public void set$IntVersion(int _v) {
        // throw new RuntimeException("Entity EmbeddedPkEntity does not have an integer type version field");
    }
    public int get$IntVersion() {
        return -1;
    }
    public static Class<BonaPortable> class$TrackingClass() {
        return null;
    }
    @Override
    public String get$TrackingPQON() {
        return null;
    }
    @Override
    public Class<BonaPortable> get$TrackingClass() {
        return null;
    }
    
    public static Class<EKey> class$KeyClass() {
        return EKey.class;
    }
    @Override
    public Class<EKey> get$KeyClass() {
        return EKey.class;
    }
    @Override
    public EKey get$Key() throws ApplicationException {
        return getMyCompositeKey();
    }
    @Override
    public void set$Key(EKey _k) {
        setMyCompositeKey(_k);
    }
    
    @Override
    public BonaPortable get$Tracking() throws ApplicationException {
        return null;
    }
    @Override
    public void set$Tracking(BonaPortable _d) {
    }
    @Override
    public BonaPersistableBase mergeFrom(final BonaPersistableBase _b) {
        if (_b instanceof EmbeddedPkEntity) {
            EmbeddedPkEntity _x = (EmbeddedPkEntity)_b;
            myCompositeKey = _x.myCompositeKey;
            data = _x.data;
        }
        return this;
    }
    
    
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/examples/pkey/entities/IdClassPkEntity.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.examples.pkey.entities;

import javax.persistence.EntityManager;
import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.Version;
import javax.persistence.Column;
import javax.persistence.Lob;
import javax.persistence.Basic;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.Id;
import javax.persistence.IdClass;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.NoResultException;
import javax.persistence.TypedQuery;
import javax.persistence.EmbeddedId;
import javax.persistence.Embedded;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.MapKey;
import javax.persistence.MapKeyJoinColumn;
import javax.persistence.JoinColumn;
import javax.persistence.JoinColumns;
import javax.persistence.ElementCollection;
import javax.persistence.MapKeyColumn;
import javax.persistence.CollectionTable;
import javax.persistence.EntityListeners;
import javax.persistence.UniqueConstraint;
import javax.persistence.AttributeOverride;
import javax.persistence.AttributeOverrides;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Serializable;

import de.jpaw.bonaparte.jpa.BonaPersistableNoData;
import de.jpaw.bonaparte.jpa.BonaPersistableTracking;
import de.jpaw.bonaparte.jpa.BonaPersistableBase;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.jpa.KeyClass;
import de.jpaw.bonaparte.jpa.DataClass;
import de.jpaw.bonaparte.jpa.TrackingClass;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.ByteArrayComposer;
import de.jpaw.bonaparte.core.ByteArrayParser;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.pojos.examples.pkey.EDto2;
import de.jpaw.bonaparte.pojos.examples.pkey.EKey;

@DataClass(EDto2.class)
@KeyClass(EKey.class)
@Entity
@Table(name="tests_id_class_pk_entity")
@IdClass(EKey.class)
public class IdClassPkEntity implements BonaPersistableNoData<EKey, BonaPortable> {
    // table columns of java class EDto2
    @Id
    @Column(name="key1", nullable=false, length=8)
    String key1;
    public String getKey1() {
        return key1;
    }
    public void setKey1(String key1) {
        this.key1 = key1;
    }
    @Id
    @Column(name="key2", nullable=false)
    Integer key2;
    public Integer getKey2() {
        return key2;
    }
    public void setKey2(Integer key2) {
        this.key2 = key2;
    }
    @Column(name="data", length=80)
    String data;
    public String getData() {
        return data;
    }
    public void setData(String data) {
        this.data = data;
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (key1 == null ? 0 : key1.hashCode());
        _hash = 29 * _hash + (key2 == null ? 0 : key2.hashCode());
        _hash = 29 * _hash + (data == null ? 0 : data.hashCode());
        return _hash;
    }
    
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof IdClassPkEntity))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(Object _that) {
        IdClassPkEntity that = (IdClassPkEntity)_that;
        return true  // there is possible issue here if the related entity extends a Java class for relations, which declares fiels as well
        && ((key1 == null && that.key1 == null) || key1.equals(that.key1))
        && ((key2 == null && that.key2 == null) || key2.equals(that.key2))
        && ((data == null && that.data == null) || data.equals(that.data))
        ;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // no isActive column in this entity, create stubs to satisfy interface
    public void set$Active(boolean _a) {
        // throw new RuntimeException("Entity IdClassPkEntity does not have an isActive field");
    }
    public boolean get$Active() {
        return true;  // no isActive column => all rows are active by default
    }
    // no version column of type int or Integer, write stub
    public void set$IntVersion(int _v) {
        // throw new RuntimeException("Entity IdClassPkEntity does not have an integer type version field");
    }
    public int get$IntVersion() {
        return -1;
    }
    public static Class<BonaPortable> class$TrackingClass() {
        return null;
    }
    @Override
    public String get$TrackingPQON() {
        return null;
    }
    @Override
    public Class<BonaPortable> get$TrackingClass() {
        return null;
    }
    
    public static Class<EKey> class$KeyClass() {
        return EKey.class;
    }
    @Override
    public Class<EKey> get$KeyClass() {
        return EKey.class;
    }
    @Override
    public EKey get$Key() throws ApplicationException {
        return new EKey(getKey1(), getKey2());
    }
    @Override
    public void set$Key(EKey _k) {
        setKey1(_k.getKey1());
        setKey2(_k.getKey2());
    }
    
    @Override
    public BonaPortable get$Tracking() throws ApplicationException {
        return null;
    }
    @Override
    public void set$Tracking(BonaPortable _d) {
    }
    @Override
    public BonaPersistableBase mergeFrom(final BonaPersistableBase _b) {
        if (_b instanceof IdClassPkEntity) {
            IdClassPkEntity _x = (IdClassPkEntity)_b;
            key1 = _x.key1;
            key2 = _x.key2;
            data = _x.data;
        }
        return this;
    }
    
    
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/examples/pkey/entities/MultiFieldPkEntity.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.examples.pkey.entities;

import javax.persistence.EntityManager;
import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.Version;
import javax.persistence.Column;
import javax.persistence.Lob;
import javax.persistence.Basic;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.Id;
import javax.persistence.IdClass;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.NoResultException;
import javax.persistence.TypedQuery;
import javax.persistence.EmbeddedId;
import javax.persistence.Embedded;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.MapKey;
import javax.persistence.MapKeyJoinColumn;
import javax.persistence.JoinColumn;
import javax.persistence.JoinColumns;
import javax.persistence.ElementCollection;
import javax.persistence.MapKeyColumn;
import javax.persistence.CollectionTable;
import javax.persistence.EntityListeners;
import javax.persistence.UniqueConstraint;
import javax.persistence.AttributeOverride;
import javax.persistence.AttributeOverrides;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Serializable;

import de.jpaw.bonaparte.jpa.BonaPersistableNoData;
import de.jpaw.bonaparte.jpa.BonaPersistableTracking;
import de.jpaw.bonaparte.jpa.BonaPersistableBase;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.jpa.KeyClass;
import de.jpaw.bonaparte.jpa.DataClass;
import de.jpaw.bonaparte.jpa.TrackingClass;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.ByteArrayComposer;
import de.jpaw.bonaparte.core.ByteArrayParser;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.pojos.examples.pkey.EDto2;

@DataClass(EDto2.class)
@KeyClass(MultiFieldPkEntityKey.class)
@Entity
@Table(name="tests_multi_field_pk_entity")
public class MultiFieldPkEntity implements BonaPersistableNoData<MultiFieldPkEntityKey, BonaPortable> {
    @EmbeddedId
    MultiFieldPkEntityKey key;
    // forwarding getters and setters
    public void setKey1(String _x) {
        key.setKey1(_x);
    }
    public String getKey1() {
        return key.getKey1();
    }
    public void setKey2(Integer _x) {
        key.setKey2(_x);
    }
    public Integer getKey2() {
        return key.getKey2();
    }

    // table columns of java class EDto2
    @Column(name="data", length=80)
    String data;
    public String getData() {
        return data;
    }
    public void setData(String data) {
        this.data = data;
    }
    @Override
    public int hashCode() {
        return key == null ? -1 : key.hashCode();
    }
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null || this.getClass() != obj.getClass())
            return false;
        if (key == null) // not yet assigned => treat it as different
            return false;
        return this.key.equals(((MultiFieldPkEntity)obj).key);
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // no isActive column in this entity, create stubs to satisfy interface
    public void set$Active(boolean _a) {
        // throw new RuntimeException("Entity MultiFieldPkEntity does not have an isActive field");
    }
    public boolean get$Active() {
        return true;  // no isActive column => all rows are active by default
    }
    // no version column of type int or Integer, write stub
    public void set$IntVersion(int _v) {
        // throw new RuntimeException("Entity MultiFieldPkEntity does not have an integer type version field");
    }
    public int get$IntVersion() {
        return -1;
    }
    public static Class<BonaPortable> class$TrackingClass() {
        return null;
    }
    @Override
    public String get$TrackingPQON() {
        return null;
    }
    @Override
    public Class<BonaPortable> get$TrackingClass() {
        return null;
    }
    
    public static Class<MultiFieldPkEntityKey> class$KeyClass() {
        return MultiFieldPkEntityKey.class;
    }
    @Override
    public Class<MultiFieldPkEntityKey> get$KeyClass() {
        return MultiFieldPkEntityKey.class;
    }
    @Override
    public MultiFieldPkEntityKey get$Key() throws ApplicationException {
        return key.clone(); // as our key fields are all immutable, shallow copy is sufficient
    }
    @Override
    public void set$Key(MultiFieldPkEntityKey _k) {
        key = _k.clone();   // as our key fields are all immutable, shallow copy is sufficient
    }
    
    @Override
    public BonaPortable get$Tracking() throws ApplicationException {
        return null;
    }
    @Override
    public void set$Tracking(BonaPortable _d) {
    }
    @Override
    public BonaPersistableBase mergeFrom(final BonaPersistableBase _b) {
        if (_b instanceof MultiFieldPkEntity) {
            MultiFieldPkEntity _x = (MultiFieldPkEntity)_b;
            setKey1(_x.getKey1());
            setKey2(_x.getKey2());
            data = _x.data;
        }
        return this;
    }
    
    
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/examples/pkey/entities/MultiFieldPkEntityKey.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.examples.pkey.entities;

import javax.persistence.EntityManager;
import javax.persistence.Embeddable;
import javax.persistence.Embedded;
import javax.persistence.Column;
import javax.persistence.EmbeddedId;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.ManyToOne;
import javax.persistence.JoinColumn;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Serializable;

import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.ByteArrayComposer;
import de.jpaw.bonaparte.core.ByteArrayParser;
import de.jpaw.bonaparte.core.MessageParserException;

@Embeddable
public class MultiFieldPkEntityKey implements Serializable, Cloneable {
    @Column(name="key1", nullable=false, length=8)
    String key1;
    public String getKey1() {
        return key1;
    }
    public void setKey1(String key1) {
        this.key1 = key1;
    }
    @Column(name="key2", nullable=false)
    Integer key2;
    public Integer getKey2() {
        return key2;
    }
    public void setKey2(Integer key2) {
        this.key2 = key2;
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (key1 == null ? 0 : key1.hashCode());
        _hash = 29 * _hash + (key2 == null ? 0 : key2.hashCode());
        return _hash;
    }
    
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof MultiFieldPkEntityKey))
            return false;
        if (this == _that)
            return true;
        MultiFieldPkEntityKey that = (MultiFieldPkEntityKey)_that;
        return true
        && ((key1 == null && that.key1 == null) || key1.equals(that.key1))
        && ((key2 == null && that.key2 == null) || key2.equals(that.key2))
        ;
    }
    @Override
    public MultiFieldPkEntityKey clone() {
        try {
            return (MultiFieldPkEntityKey)super.clone();
        } catch (CloneNotSupportedException e) {
            return this;  // fallback
        }
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/examples/pkey/entities/NoPkEntity.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.examples.pkey.entities;

import javax.persistence.EntityManager;
import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.Version;
import javax.persistence.Column;
import javax.persistence.Lob;
import javax.persistence.Basic;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.Id;
import javax.persistence.IdClass;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.NoResultException;
import javax.persistence.TypedQuery;
import javax.persistence.EmbeddedId;
import javax.persistence.Embedded;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.MapKey;
import javax.persistence.MapKeyJoinColumn;
import javax.persistence.JoinColumn;
import javax.persistence.JoinColumns;
import javax.persistence.ElementCollection;
import javax.persistence.MapKeyColumn;
import javax.persistence.CollectionTable;
import javax.persistence.EntityListeners;
import javax.persistence.UniqueConstraint;
import javax.persistence.AttributeOverride;
import javax.persistence.AttributeOverrides;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Serializable;

import de.jpaw.bonaparte.jpa.BonaPersistableNoData;
import de.jpaw.bonaparte.jpa.BonaPersistableTracking;
import de.jpaw.bonaparte.jpa.BonaPersistableBase;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.jpa.KeyClass;
import de.jpaw.bonaparte.jpa.DataClass;
import de.jpaw.bonaparte.jpa.TrackingClass;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.ByteArrayComposer;
import de.jpaw.bonaparte.core.ByteArrayParser;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.pojos.examples.pkey.EDto;
import de.jpaw.bonaparte.pojos.examples.pkey.EKey;

@DataClass(EDto.class)
@Entity
@Table(name="tests_no_pk_entity")
public class NoPkEntity implements BonaPersistableNoData<Serializable, BonaPortable> {
    // table columns of java class EDto
    @Column(name="my_composite_key")
    EKey myCompositeKey;
    public EKey getMyCompositeKey() {
        return myCompositeKey;
    }
    public void setMyCompositeKey(EKey myCompositeKey) {
        this.myCompositeKey = myCompositeKey;
    }
    @Column(name="data", length=80)
    String data;
    public String getData() {
        return data;
    }
    public void setData(String data) {
        this.data = data;
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (myCompositeKey == null ? 0 : myCompositeKey.hashCode());
        _hash = 29 * _hash + (data == null ? 0 : data.hashCode());
        return _hash;
    }
    
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof NoPkEntity))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(Object _that) {
        NoPkEntity that = (NoPkEntity)_that;
        return true  // there is possible issue here if the related entity extends a Java class for relations, which declares fiels as well
        && ((myCompositeKey == null && that.myCompositeKey == null) || myCompositeKey.equals(that.myCompositeKey))
        && ((data == null && that.data == null) || data.equals(that.data))
        ;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // no isActive column in this entity, create stubs to satisfy interface
    public void set$Active(boolean _a) {
        // throw new RuntimeException("Entity NoPkEntity does not have an isActive field");
    }
    public boolean get$Active() {
        return true;  // no isActive column => all rows are active by default
    }
    // no version column of type int or Integer, write stub
    public void set$IntVersion(int _v) {
        // throw new RuntimeException("Entity NoPkEntity does not have an integer type version field");
    }
    public int get$IntVersion() {
        return -1;
    }
    public static Class<BonaPortable> class$TrackingClass() {
        return null;
    }
    @Override
    public String get$TrackingPQON() {
        return null;
    }
    @Override
    public Class<BonaPortable> get$TrackingClass() {
        return null;
    }
    
    public static Class<Serializable> class$KeyClass() {
        return Serializable.class;
    }
    @Override
    public Class<Serializable> get$KeyClass() {
        return Serializable.class;
    }
    @Override
    public Serializable get$Key() throws ApplicationException {
        return null;  // FIXME! not yet implemented!
    }
    @Override
    public void set$Key(Serializable _k) {
        // FIXME! not yet implemented!!!
    }
    
    @Override
    public BonaPortable get$Tracking() throws ApplicationException {
        return null;
    }
    @Override
    public void set$Tracking(BonaPortable _d) {
    }
    @Override
    public BonaPersistableBase mergeFrom(final BonaPersistableBase _b) {
        if (_b instanceof NoPkEntity) {
            NoPkEntity _x = (NoPkEntity)_b;
            myCompositeKey = _x.myCompositeKey;
            data = _x.data;
        }
        return this;
    }
    
    
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/examples/pkey/entities/OneFieldPkEntity.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.examples.pkey.entities;

import javax.persistence.EntityManager;
import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.Version;
import javax.persistence.Column;
import javax.persistence.Lob;
import javax.persistence.Basic;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.Id;
import javax.persistence.IdClass;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.NoResultException;
import javax.persistence.TypedQuery;
import javax.persistence.EmbeddedId;
import javax.persistence.Embedded;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.MapKey;
import javax.persistence.MapKeyJoinColumn;
import javax.persistence.JoinColumn;
import javax.persistence.JoinColumns;
import javax.persistence.ElementCollection;
import javax.persistence.MapKeyColumn;
import javax.persistence.CollectionTable;
import javax.persistence.EntityListeners;
import javax.persistence.UniqueConstraint;
import javax.persistence.AttributeOverride;
import javax.persistence.AttributeOverrides;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Serializable;

import de.jpaw.bonaparte.jpa.BonaPersistableNoData;
import de.jpaw.bonaparte.jpa.BonaPersistableTracking;
import de.jpaw.bonaparte.jpa.BonaPersistableBase;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.jpa.KeyClass;
import de.jpaw.bonaparte.jpa.DataClass;
import de.jpaw.bonaparte.jpa.TrackingClass;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.ByteArrayComposer;
import de.jpaw.bonaparte.core.ByteArrayParser;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.pojos.examples.pkey.EDto;
import de.jpaw.bonaparte.pojos.examples.pkey.EKey;

@DataClass(EDto.class)
@KeyClass(String.class)
@Entity
@Table(name="tests_one_field_pk_entity")
public class OneFieldPkEntity implements BonaPersistableNoData<String, BonaPortable> {
    // table columns of java class EDto
    @Column(name="my_composite_key")
    EKey myCompositeKey;
    public EKey getMyCompositeKey() {
        return myCompositeKey;
    }
    public void setMyCompositeKey(EKey myCompositeKey) {
        this.myCompositeKey = myCompositeKey;
    }
    @Id
    @Column(name="data", length=80)
    String data;
    public String getData() {
        return data;
    }
    public void setData(String data) {
        this.data = data;
    }
    @Override
    public int hashCode() {
        return data == null ? -1 : data.hashCode();
    }
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null || this.getClass() != obj.getClass())
            return false;
        if (data == null) // not yet assigned => treat it as different
            return false;
        return this.data.equals(((OneFieldPkEntity)obj).data);
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // no isActive column in this entity, create stubs to satisfy interface
    public void set$Active(boolean _a) {
        // throw new RuntimeException("Entity OneFieldPkEntity does not have an isActive field");
    }
    public boolean get$Active() {
        return true;  // no isActive column => all rows are active by default
    }
    // no version column of type int or Integer, write stub
    public void set$IntVersion(int _v) {
        // throw new RuntimeException("Entity OneFieldPkEntity does not have an integer type version field");
    }
    public int get$IntVersion() {
        return -1;
    }
    public static Class<BonaPortable> class$TrackingClass() {
        return null;
    }
    @Override
    public String get$TrackingPQON() {
        return null;
    }
    @Override
    public Class<BonaPortable> get$TrackingClass() {
        return null;
    }
    
    public static Class<String> class$KeyClass() {
        return String.class;
    }
    @Override
    public Class<String> get$KeyClass() {
        return String.class;
    }
    @Override
    public String get$Key() throws ApplicationException {
        return data;
    }
    @Override
    public void set$Key(String _k) {
        setData(_k);  // no direct assigned due to possible enum or temporal type, with implied conversions
    }
    
    @Override
    public BonaPortable get$Tracking() throws ApplicationException {
        return null;
    }
    @Override
    public void set$Tracking(BonaPortable _d) {
    }
    @Override
    public BonaPersistableBase mergeFrom(final BonaPersistableBase _b) {
        if (_b instanceof OneFieldPkEntity) {
            OneFieldPkEntity _x = (OneFieldPkEntity)_b;
            setData(_x.getData());
            myCompositeKey = _x.myCompositeKey;
        }
        return this;
    }
    
    
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/examples/pkey/package-info.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

package de.jpaw.bonaparte.pojos.examples.pkey;
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/persistencetest/BoxedTypesEntity.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.persistencetest;

import javax.persistence.EntityManager;
import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.Version;
import javax.persistence.Column;
import javax.persistence.Lob;
import javax.persistence.Basic;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.Id;
import javax.persistence.IdClass;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.NoResultException;
import javax.persistence.TypedQuery;
import javax.persistence.EmbeddedId;
import javax.persistence.Embedded;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.MapKey;
import javax.persistence.MapKeyJoinColumn;
import javax.persistence.JoinColumn;
import javax.persistence.JoinColumns;
import javax.persistence.ElementCollection;
import javax.persistence.MapKeyColumn;
import javax.persistence.CollectionTable;
import javax.persistence.EntityListeners;
import javax.persistence.UniqueConstraint;
import javax.persistence.AttributeOverride;
import javax.persistence.AttributeOverrides;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Serializable;

import de.jpaw.bonaparte.jpa.BonaPersistableNoData;
import de.jpaw.bonaparte.jpa.BonaPersistableTracking;
import de.jpaw.bonaparte.jpa.BonaPersistableBase;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.jpa.KeyClass;
import de.jpaw.bonaparte.jpa.DataClass;
import de.jpaw.bonaparte.jpa.TrackingClass;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.ByteArrayComposer;
import de.jpaw.bonaparte.core.ByteArrayParser;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.pojos.tests1.BoxedTypes;

@DataClass(BoxedTypes.class)
@KeyClass(Integer.class)
@Entity
@Table(name="test_boxed_types_entity")
public class BoxedTypesEntity implements BonaPersistable<Integer, BoxedTypes, BonaPortable> {
    // table columns of java class BoxedTypes
    @Column(name="byte1")
    Byte byte1;
    public Byte getByte1() {
        return byte1;
    }
    public void setByte1(Byte byte1) {
        this.byte1 = byte1;
    }
    @Column(name="short1")
    Short short1;
    public Short getShort1() {
        return short1;
    }
    public void setShort1(Short short1) {
        this.short1 = short1;
    }
    @Id
    @Column(name="int1")
    Integer int1;
    public Integer getInt1() {
        return int1;
    }
    public void setInt1(Integer int1) {
        this.int1 = int1;
    }
    @Column(name="int2")
    Integer int2;
    public Integer getInt2() {
        return int2;
    }
    public void setInt2(Integer int2) {
        this.int2 = int2;
    }
    @Column(name="long1")
    Long long1;
    public Long getLong1() {
        return long1;
    }
    public void setLong1(Long long1) {
        this.long1 = long1;
    }
    @Column(name="boolean1")
    Boolean boolean1;
    public Boolean getBoolean1() {
        return boolean1;
    }
    public void setBoolean1(Boolean boolean1) {
        this.boolean1 = boolean1;
    }
    @Column(name="float1")
    Float float1;
    public Float getFloat1() {
        return float1;
    }
    public void setFloat1(Float float1) {
        this.float1 = float1;
    }
    @Column(name="double1")
    Double double1;
    public Double getDouble1() {
        return double1;
    }
    public void setDouble1(Double double1) {
        this.double1 = double1;
    }
    @Column(name="char1")
    Character char1;
    public Character getChar1() {
        return char1;
    }
    public void setChar1(Character char1) {
        this.char1 = char1;
    }
    @Column(name="char2")
    Character char2;
    public Character getChar2() {
        return char2;
    }
    public void setChar2(Character char2) {
        this.char2 = char2;
    }
    @Override
    public int hashCode() {
        return int1 == null ? -1 : int1.hashCode();
    }
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null || this.getClass() != obj.getClass())
            return false;
        if (int1 == null) // not yet assigned => treat it as different
            return false;
        return this.int1.equals(((BoxedTypesEntity)obj).int1);
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // no isActive column in this entity, create stubs to satisfy interface
    public void set$Active(boolean _a) {
        // throw new RuntimeException("Entity BoxedTypesEntity does not have an isActive field");
    }
    public boolean get$Active() {
        return true;  // no isActive column => all rows are active by default
    }
    // no version column of type int or Integer, write stub
    public void set$IntVersion(int _v) {
        // throw new RuntimeException("Entity BoxedTypesEntity does not have an integer type version field");
    }
    public int get$IntVersion() {
        return -1;
    }
    public static Class<BonaPortable> class$TrackingClass() {
        return null;
    }
    @Override
    public String get$TrackingPQON() {
        return null;
    }
    @Override
    public Class<BonaPortable> get$TrackingClass() {
        return null;
    }
    
    public static Class<Integer> class$KeyClass() {
        return Integer.class;
    }
    @Override
    public Class<Integer> get$KeyClass() {
        return Integer.class;
    }
    @Override
    public Integer get$Key() throws ApplicationException {
        return int1;
    }
    @Override
    public void set$Key(Integer _k) {
        setInt1(_k);  // no direct assigned due to possible enum or temporal type, with implied conversions
    }
    
    @Override
    public BonaPortable get$Tracking() throws ApplicationException {
        return null;
    }
    @Override
    public void set$Tracking(BonaPortable _d) {
    }
    @Override
    public String get$DataPQON() {
        return "tests1.BoxedTypes";
    }
    @Override
    public Class<? extends BoxedTypes> get$DataClass() {
        return BoxedTypes.class;
    }
    public static Class<BoxedTypes> class$DataClass() {
        return BoxedTypes.class;
    }
    public static String class$DataPQON() {
        return "tests1.BoxedTypes";
    }
    @Override
    public BoxedTypes get$Data() throws ApplicationException {
        BoxedTypes _r = new BoxedTypes();
        // auto-generated data getter for BoxedTypes
        _r.setByte1(getByte1());
        _r.setShort1(getShort1());
        _r.setInt1(getInt1());
        _r.setInt2(getInt2());
        _r.setLong1(getLong1());
        _r.setBoolean1(getBoolean1());
        _r.setFloat1(getFloat1());
        _r.setDouble1(getDouble1());
        _r.setChar1(getChar1());
        _r.setChar2(getChar2());
        return _r;
    }
    @Override
    public void set$Data(BoxedTypes _d) {
        // auto-generated data setter for BoxedTypes
        setByte1(_d.getByte1());
        setShort1(_d.getShort1());
        setInt2(_d.getInt2());
        setLong1(_d.getLong1());
        setBoolean1(_d.getBoolean1());
        setFloat1(_d.getFloat1());
        setDouble1(_d.getDouble1());
        setChar1(_d.getChar1());
        setChar2(_d.getChar2());
    }
    @Override
    public BonaPersistableBase mergeFrom(final BonaPersistableBase _b) {
        if (_b instanceof BoxedTypesEntity) {
            BoxedTypesEntity _x = (BoxedTypesEntity)_b;
            setInt1(_x.getInt1());
            byte1 = _x.byte1;
            short1 = _x.short1;
            int2 = _x.int2;
            long1 = _x.long1;
            boolean1 = _x.boolean1;
            float1 = _x.float1;
            double1 = _x.double1;
            char1 = _x.char1;
            char2 = _x.char2;
        }
        return this;
    }
    
    
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/persistencetest/MissingPKEntity.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.persistencetest;

import javax.persistence.EntityManager;
import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.Version;
import javax.persistence.Column;
import javax.persistence.Lob;
import javax.persistence.Basic;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.Id;
import javax.persistence.IdClass;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.NoResultException;
import javax.persistence.TypedQuery;
import javax.persistence.EmbeddedId;
import javax.persistence.Embedded;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.MapKey;
import javax.persistence.MapKeyJoinColumn;
import javax.persistence.JoinColumn;
import javax.persistence.JoinColumns;
import javax.persistence.ElementCollection;
import javax.persistence.MapKeyColumn;
import javax.persistence.CollectionTable;
import javax.persistence.EntityListeners;
import javax.persistence.UniqueConstraint;
import javax.persistence.AttributeOverride;
import javax.persistence.AttributeOverrides;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Serializable;

import de.jpaw.bonaparte.jpa.BonaPersistableNoData;
import de.jpaw.bonaparte.jpa.BonaPersistableTracking;
import de.jpaw.bonaparte.jpa.BonaPersistableBase;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.jpa.KeyClass;
import de.jpaw.bonaparte.jpa.DataClass;
import de.jpaw.bonaparte.jpa.TrackingClass;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.ByteArrayComposer;
import de.jpaw.bonaparte.core.ByteArrayParser;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.pojos.tests1.BoxedTypes;

@DataClass(BoxedTypes.class)
@Entity
@Table(name="test_missing_p_k_entity")
public class MissingPKEntity implements BonaPersistable<Serializable, BoxedTypes, BonaPortable> {
    // table columns of java class BoxedTypes
    @Column(name="byte1")
    Byte byte1;
    public Byte getByte1() {
        return byte1;
    }
    public void setByte1(Byte byte1) {
        this.byte1 = byte1;
    }
    @Column(name="short1")
    Short short1;
    public Short getShort1() {
        return short1;
    }
    public void setShort1(Short short1) {
        this.short1 = short1;
    }
    @Column(name="int1")
    Integer int1;
    public Integer getInt1() {
        return int1;
    }
    public void setInt1(Integer int1) {
        this.int1 = int1;
    }
    @Column(name="int2")
    Integer int2;
    public Integer getInt2() {
        return int2;
    }
    public void setInt2(Integer int2) {
        this.int2 = int2;
    }
    @Column(name="long1")
    Long long1;
    public Long getLong1() {
        return long1;
    }
    public void setLong1(Long long1) {
        this.long1 = long1;
    }
    @Column(name="boolean1")
    Boolean boolean1;
    public Boolean getBoolean1() {
        return boolean1;
    }
    public void setBoolean1(Boolean boolean1) {
        this.boolean1 = boolean1;
    }
    @Column(name="float1")
    Float float1;
    public Float getFloat1() {
        return float1;
    }
    public void setFloat1(Float float1) {
        this.float1 = float1;
    }
    @Column(name="double1")
    Double double1;
    public Double getDouble1() {
        return double1;
    }
    public void setDouble1(Double double1) {
        this.double1 = double1;
    }
    @Column(name="char1")
    Character char1;
    public Character getChar1() {
        return char1;
    }
    public void setChar1(Character char1) {
        this.char1 = char1;
    }
    @Column(name="char2")
    Character char2;
    public Character getChar2() {
        return char2;
    }
    public void setChar2(Character char2) {
        this.char2 = char2;
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (byte1 == null ? 0 : byte1.hashCode());
        _hash = 29 * _hash + (short1 == null ? 0 : short1.hashCode());
        _hash = 29 * _hash + (int1 == null ? 0 : int1.hashCode());
        _hash = 29 * _hash + (int2 == null ? 0 : int2.hashCode());
        _hash = 29 * _hash + (long1 == null ? 0 : long1.hashCode());
        _hash = 29 * _hash + (boolean1 == null ? 0 : boolean1.hashCode());
        _hash = 29 * _hash + (float1 == null ? 0 : float1.hashCode());
        _hash = 29 * _hash + (double1 == null ? 0 : double1.hashCode());
        _hash = 29 * _hash + (char1 == null ? 0 : char1.hashCode());
        _hash = 29 * _hash + (char2 == null ? 0 : char2.hashCode());
        return _hash;
    }
    
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof MissingPKEntity))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(Object _that) {
        MissingPKEntity that = (MissingPKEntity)_that;
        return true  // there is possible issue here if the related entity extends a Java class for relations, which declares fiels as well
        && ((byte1 == null && that.byte1 == null) || byte1.equals(that.byte1))
        && ((short1 == null && that.short1 == null) || short1.equals(that.short1))
        && ((int1 == null && that.int1 == null) || int1.equals(that.int1))
        && ((int2 == null && that.int2 == null) || int2.equals(that.int2))
        && ((long1 == null && that.long1 == null) || long1.equals(that.long1))
        && ((boolean1 == null && that.boolean1 == null) || boolean1.equals(that.boolean1))
        && ((float1 == null && that.float1 == null) || float1.equals(that.float1))
        && ((double1 == null && that.double1 == null) || double1.equals(that.double1))
        && ((char1 == null && that.char1 == null) || char1.equals(that.char1))
        && ((char2 == null && that.char2 == null) || char2.equals(that.char2))
        ;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // no isActive column in this entity, create stubs to satisfy interface
    public void set$Active(boolean _a) {
        // throw new RuntimeException("Entity MissingPKEntity does not have an isActive field");
    }
    public boolean get$Active() {
        return true;  // no isActive column => all rows are active by default
    }
    // no version column of type int or Integer, write stub
    public void set$IntVersion(int _v) {
        // throw new RuntimeException("Entity MissingPKEntity does not have an integer type version field");
    }
    public int get$IntVersion() {
        return -1;
    }
    public static Class<BonaPortable> class$TrackingClass() {
        return null;
    }
    @Override
    public String get$TrackingPQON() {
        return null;
    }
    @Override
    public Class<BonaPortable> get$TrackingClass() {
        return null;
    }
    
    public static Class<Serializable> class$KeyClass() {
        return Serializable.class;
    }
    @Override
    public Class<Serializable> get$KeyClass() {
        return Serializable.class;
    }
    @Override
    public Serializable get$Key() throws ApplicationException {
        return null;  // FIXME! not yet implemented!
    }
    @Override
    public void set$Key(Serializable _k) {
        // FIXME! not yet implemented!!!
    }
    
    @Override
    public BonaPortable get$Tracking() throws ApplicationException {
        return null;
    }
    @Override
    public void set$Tracking(BonaPortable _d) {
    }
    @Override
    public String get$DataPQON() {
        return "tests1.BoxedTypes";
    }
    @Override
    public Class<? extends BoxedTypes> get$DataClass() {
        return BoxedTypes.class;
    }
    public static Class<BoxedTypes> class$DataClass() {
        return BoxedTypes.class;
    }
    public static String class$DataPQON() {
        return "tests1.BoxedTypes";
    }
    @Override
    public BoxedTypes get$Data() throws ApplicationException {
        BoxedTypes _r = new BoxedTypes();
        // auto-generated data getter for BoxedTypes
        _r.setByte1(getByte1());
        _r.setShort1(getShort1());
        _r.setInt1(getInt1());
        _r.setInt2(getInt2());
        _r.setLong1(getLong1());
        _r.setBoolean1(getBoolean1());
        _r.setFloat1(getFloat1());
        _r.setDouble1(getDouble1());
        _r.setChar1(getChar1());
        _r.setChar2(getChar2());
        return _r;
    }
    @Override
    public void set$Data(BoxedTypes _d) {
        // auto-generated data setter for BoxedTypes
        setByte1(_d.getByte1());
        setShort1(_d.getShort1());
        setInt1(_d.getInt1());
        setInt2(_d.getInt2());
        setLong1(_d.getLong1());
        setBoolean1(_d.getBoolean1());
        setFloat1(_d.getFloat1());
        setDouble1(_d.getDouble1());
        setChar1(_d.getChar1());
        setChar2(_d.getChar2());
    }
    @Override
    public BonaPersistableBase mergeFrom(final BonaPersistableBase _b) {
        if (_b instanceof MissingPKEntity) {
            MissingPKEntity _x = (MissingPKEntity)_b;
            byte1 = _x.byte1;
            short1 = _x.short1;
            int1 = _x.int1;
            int2 = _x.int2;
            long1 = _x.long1;
            boolean1 = _x.boolean1;
            float1 = _x.float1;
            double1 = _x.double1;
            char1 = _x.char1;
            char2 = _x.char2;
        }
        return this;
    }
    
    
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/persistencetest/MissingPKEntity2.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.persistencetest;

import javax.persistence.EntityManager;
import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.Version;
import javax.persistence.Column;
import javax.persistence.Lob;
import javax.persistence.Basic;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.Id;
import javax.persistence.IdClass;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.NoResultException;
import javax.persistence.TypedQuery;
import javax.persistence.EmbeddedId;
import javax.persistence.Embedded;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.MapKey;
import javax.persistence.MapKeyJoinColumn;
import javax.persistence.JoinColumn;
import javax.persistence.JoinColumns;
import javax.persistence.ElementCollection;
import javax.persistence.MapKeyColumn;
import javax.persistence.CollectionTable;
import javax.persistence.EntityListeners;
import javax.persistence.UniqueConstraint;
import javax.persistence.AttributeOverride;
import javax.persistence.AttributeOverrides;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Serializable;

import de.jpaw.bonaparte.jpa.BonaPersistableNoData;
import de.jpaw.bonaparte.jpa.BonaPersistableTracking;
import de.jpaw.bonaparte.jpa.BonaPersistableBase;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.jpa.KeyClass;
import de.jpaw.bonaparte.jpa.DataClass;
import de.jpaw.bonaparte.jpa.TrackingClass;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.ByteArrayComposer;
import de.jpaw.bonaparte.core.ByteArrayParser;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.pojos.tests1.BoxedTypes;

@DataClass(BoxedTypes.class)
@KeyClass(Integer.class)
@Entity
@Table(name="test_missing_p_k_entity2")
public class MissingPKEntity2 implements BonaPersistable<Integer, BoxedTypes, BonaPortable> {
    // table columns of java class BoxedTypes
    @Column(name="byte1")
    Byte byte1;
    public Byte getByte1() {
        return byte1;
    }
    public void setByte1(Byte byte1) {
        this.byte1 = byte1;
    }
    @Column(name="short1")
    Short short1;
    public Short getShort1() {
        return short1;
    }
    public void setShort1(Short short1) {
        this.short1 = short1;
    }
    @Id
    @Column(name="int1")
    Integer int1;
    public Integer getInt1() {
        return int1;
    }
    public void setInt1(Integer int1) {
        this.int1 = int1;
    }
    @Column(name="int2")
    Integer int2;
    public Integer getInt2() {
        return int2;
    }
    public void setInt2(Integer int2) {
        this.int2 = int2;
    }
    @Column(name="long1")
    Long long1;
    public Long getLong1() {
        return long1;
    }
    public void setLong1(Long long1) {
        this.long1 = long1;
    }
    @Column(name="boolean1")
    Boolean boolean1;
    public Boolean getBoolean1() {
        return boolean1;
    }
    public void setBoolean1(Boolean boolean1) {
        this.boolean1 = boolean1;
    }
    @Column(name="float1")
    Float float1;
    public Float getFloat1() {
        return float1;
    }
    public void setFloat1(Float float1) {
        this.float1 = float1;
    }
    @Column(name="double1")
    Double double1;
    public Double getDouble1() {
        return double1;
    }
    public void setDouble1(Double double1) {
        this.double1 = double1;
    }
    @Column(name="char1")
    Character char1;
    public Character getChar1() {
        return char1;
    }
    public void setChar1(Character char1) {
        this.char1 = char1;
    }
    @Column(name="char2")
    Character char2;
    public Character getChar2() {
        return char2;
    }
    public void setChar2(Character char2) {
        this.char2 = char2;
    }
    @Override
    public int hashCode() {
        return int1 == null ? -1 : int1.hashCode();
    }
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null || this.getClass() != obj.getClass())
            return false;
        if (int1 == null) // not yet assigned => treat it as different
            return false;
        return this.int1.equals(((MissingPKEntity2)obj).int1);
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // no isActive column in this entity, create stubs to satisfy interface
    public void set$Active(boolean _a) {
        // throw new RuntimeException("Entity MissingPKEntity2 does not have an isActive field");
    }
    public boolean get$Active() {
        return true;  // no isActive column => all rows are active by default
    }
    // no version column of type int or Integer, write stub
    public void set$IntVersion(int _v) {
        // throw new RuntimeException("Entity MissingPKEntity2 does not have an integer type version field");
    }
    public int get$IntVersion() {
        return -1;
    }
    public static Class<BonaPortable> class$TrackingClass() {
        return null;
    }
    @Override
    public String get$TrackingPQON() {
        return null;
    }
    @Override
    public Class<BonaPortable> get$TrackingClass() {
        return null;
    }
    
    public static Class<Integer> class$KeyClass() {
        return Integer.class;
    }
    @Override
    public Class<Integer> get$KeyClass() {
        return Integer.class;
    }
    @Override
    public Integer get$Key() throws ApplicationException {
        return int1;
    }
    @Override
    public void set$Key(Integer _k) {
        setInt1(_k);  // no direct assigned due to possible enum or temporal type, with implied conversions
    }
    
    @Override
    public BonaPortable get$Tracking() throws ApplicationException {
        return null;
    }
    @Override
    public void set$Tracking(BonaPortable _d) {
    }
    @Override
    public String get$DataPQON() {
        return "tests1.BoxedTypes";
    }
    @Override
    public Class<? extends BoxedTypes> get$DataClass() {
        return BoxedTypes.class;
    }
    public static Class<BoxedTypes> class$DataClass() {
        return BoxedTypes.class;
    }
    public static String class$DataPQON() {
        return "tests1.BoxedTypes";
    }
    @Override
    public BoxedTypes get$Data() throws ApplicationException {
        BoxedTypes _r = new BoxedTypes();
        // auto-generated data getter for BoxedTypes
        _r.setByte1(getByte1());
        _r.setShort1(getShort1());
        _r.setInt1(getInt1());
        _r.setInt2(getInt2());
        _r.setLong1(getLong1());
        _r.setBoolean1(getBoolean1());
        _r.setFloat1(getFloat1());
        _r.setDouble1(getDouble1());
        _r.setChar1(getChar1());
        _r.setChar2(getChar2());
        return _r;
    }
    @Override
    public void set$Data(BoxedTypes _d) {
        // auto-generated data setter for BoxedTypes
        setByte1(_d.getByte1());
        setShort1(_d.getShort1());
        setInt2(_d.getInt2());
        setLong1(_d.getLong1());
        setBoolean1(_d.getBoolean1());
        setFloat1(_d.getFloat1());
        setDouble1(_d.getDouble1());
        setChar1(_d.getChar1());
        setChar2(_d.getChar2());
    }
    @Override
    public BonaPersistableBase mergeFrom(final BonaPersistableBase _b) {
        if (_b instanceof MissingPKEntity2) {
            MissingPKEntity2 _x = (MissingPKEntity2)_b;
            setInt1(_x.getInt1());
            byte1 = _x.byte1;
            short1 = _x.short1;
            int2 = _x.int2;
            long1 = _x.long1;
            boolean1 = _x.boolean1;
            float1 = _x.float1;
            double1 = _x.double1;
            char1 = _x.char1;
            char2 = _x.char2;
        }
        return this;
    }
    
    
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/persistencetest/OtherTypesEntity.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.persistencetest;

import javax.persistence.EntityManager;
import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.Version;
import javax.persistence.Column;
import javax.persistence.Lob;
import javax.persistence.Basic;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.Id;
import javax.persistence.IdClass;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.NoResultException;
import javax.persistence.TypedQuery;
import javax.persistence.EmbeddedId;
import javax.persistence.Embedded;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.MapKey;
import javax.persistence.MapKeyJoinColumn;
import javax.persistence.JoinColumn;
import javax.persistence.JoinColumns;
import javax.persistence.ElementCollection;
import javax.persistence.MapKeyColumn;
import javax.persistence.CollectionTable;
import javax.persistence.EntityListeners;
import javax.persistence.UniqueConstraint;
import javax.persistence.AttributeOverride;
import javax.persistence.AttributeOverrides;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Serializable;

import de.jpaw.bonaparte.jpa.BonaPersistableNoData;
import de.jpaw.bonaparte.jpa.BonaPersistableTracking;
import de.jpaw.bonaparte.jpa.BonaPersistableBase;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.jpa.KeyClass;
import de.jpaw.bonaparte.jpa.DataClass;
import de.jpaw.bonaparte.jpa.TrackingClass;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.ByteArrayComposer;
import de.jpaw.bonaparte.core.ByteArrayParser;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.pojos.tests1.VariableLengthUnicode;
import de.jpaw.bonaparte.pojos.tests1.VariableLength;
import de.jpaw.bonaparte.pojos.tests1.AlphaColor;
import de.jpaw.bonaparte.pojos.tests1.OtherTypes;
import de.jpaw.bonaparte.pojos.tests1.Color;

@DataClass(OtherTypes.class)
@KeyClass(Integer.class)
@Entity
@Table(name="test_other_types_entity")
public class OtherTypesEntity implements BonaPersistable<Integer, OtherTypes, BonaPortable> {
    // table columns of java class OtherTypes
    @Column(name="raw1", nullable=false)
    byte [] raw1;
    public byte [] getRaw1() {
        return ByteUtil.deepCopy(raw1);       // deep copy
    }
    public void setRaw1(byte [] raw1) {
        this.raw1 = ByteUtil.deepCopy(raw1);       // deep copy
    }
    @Column(name="binary1", nullable=false)
    ByteArray binary1;
    public ByteArray getBinary1() {
        return binary1;
    }
    public void setBinary1(ByteArray binary1) {
        this.binary1 = binary1;
    }
    @Column(name="day1", nullable=false)
    LocalDate day1;
    public LocalDate getDay1() {
        return day1;
    }
    public void setDay1(LocalDate day1) {
        this.day1 = day1;
    }
    @Column(name="timestamp1", nullable=false)
    LocalDateTime timestamp1;
    public LocalDateTime getTimestamp1() {
        return timestamp1;
    }
    public void setTimestamp1(LocalDateTime timestamp1) {
        this.timestamp1 = timestamp1;
    }
    @Column(name="timestamp2", nullable=false)
    LocalDateTime timestamp2;
    public LocalDateTime getTimestamp2() {
        return timestamp2;
    }
    public void setTimestamp2(LocalDateTime timestamp2) {
        this.timestamp2 = timestamp2;
    }
    @Column(name="timestamp3", nullable=false)
    @Temporal(TemporalType.TIMESTAMP)
    Calendar timestamp3;
    public Calendar getTimestamp3() {
        return timestamp3;
    }
    public void setTimestamp3(Calendar timestamp3) {
        this.timestamp3 = timestamp3;
    }
    @Column(name="timestamp4", nullable=false)
    @Temporal(TemporalType.TIMESTAMP)
    Calendar timestamp4;
    public Calendar getTimestamp4() {
        return timestamp4;
    }
    public void setTimestamp4(Calendar timestamp4) {
        this.timestamp4 = timestamp4;
    }
    @Column(name="ascii1", nullable=false, length=30)
    String ascii1;
    public String getAscii1() {
        return ascii1;
    }
    public void setAscii1(String ascii1) {
        this.ascii1 = ascii1;
    }
    @Column(name="unicode1", nullable=false, length=30)
    String unicode1;
    public String getUnicode1() {
        return unicode1;
    }
    public void setUnicode1(String unicode1) {
        this.unicode1 = unicode1;
    }
    @Id
    @Column(name="number1", nullable=false)
    Integer number1;
    public Integer getNumber1() {
        return number1;
    }
    public void setNumber1(Integer number1) {
        this.number1 = number1;
    }
    @Column(name="decimal1", nullable=false, precision=14, scale=2)
    BigDecimal decimal1;
    public BigDecimal getDecimal1() {
        return decimal1;
    }
    public void setDecimal1(BigDecimal decimal1) {
        this.decimal1 = decimal1;
    }
    @Column(name="color1", nullable=false)
    Integer color1;
    public Color getColor1() throws EnumException {
        return Color.valueOf(color1);
    }
    public void setColor1(Color color1) {
        this.color1 = color1 == null ? null : color1.ordinal();
    }
    @Column(name="color2", nullable=false)
    String color2;
    public AlphaColor getColor2() throws EnumException {
        return AlphaColor.factory(color2);
    }
    public void setColor2(AlphaColor color2) {
        this.color2 = color2 == null ? null : color2.getToken();
    }
    @Column(name="var_enum1", nullable=false)
    String varEnum1;
    public VariableLength getVarEnum1() throws EnumException {
        return VariableLength.factory(varEnum1);
    }
    public void setVarEnum1(VariableLength varEnum1) {
        this.varEnum1 = varEnum1 == null ? null : varEnum1.getToken();
    }
    @Column(name="var_enum2", nullable=false)
    Integer varEnum2;
    public VariableLengthUnicode getVarEnum2() throws EnumException {
        return VariableLengthUnicode.valueOf(varEnum2);
    }
    public void setVarEnum2(VariableLengthUnicode varEnum2) {
        this.varEnum2 = varEnum2 == null ? null : varEnum2.ordinal();
    }
    @Column(name="my_uuid", nullable=false)
    UUID myUuid;
    public UUID getMyUuid() {
        return myUuid;
    }
    public void setMyUuid(UUID myUuid) {
        this.myUuid = myUuid;
    }
    @Column(name="country_code", nullable=false, length=2)
    String countryCode;
    public String getCountryCode() {
        return countryCode;
    }
    public void setCountryCode(String countryCode) {
        this.countryCode = countryCode;
    }
    @Column(name="language_code", length=5)
    String languageCode;
    public String getLanguageCode() {
        return languageCode;
    }
    public void setLanguageCode(String languageCode) {
        this.languageCode = languageCode;
    }
    @Column(name="timestamp1a", nullable=false)
    LocalDateTime timestamp1a;
    public LocalDateTime getTimestamp1a() {
        return timestamp1a;
    }
    public void setTimestamp1a(LocalDateTime timestamp1a) {
        this.timestamp1a = timestamp1a;
    }
    @Column(name="timestamp2a", nullable=false)
    LocalDateTime timestamp2a;
    public LocalDateTime getTimestamp2a() {
        return timestamp2a;
    }
    public void setTimestamp2a(LocalDateTime timestamp2a) {
        this.timestamp2a = timestamp2a;
    }
    @Column(name="timestamp3a", nullable=false)
    @Temporal(TemporalType.TIMESTAMP)
    Calendar timestamp3a;
    public Calendar getTimestamp3a() {
        return timestamp3a;
    }
    public void setTimestamp3a(Calendar timestamp3a) {
        this.timestamp3a = timestamp3a;
    }
    @Column(name="timestamp4a", nullable=false)
    @Temporal(TemporalType.TIMESTAMP)
    Calendar timestamp4a;
    public Calendar getTimestamp4a() {
        return timestamp4a;
    }
    public void setTimestamp4a(Calendar timestamp4a) {
        this.timestamp4a = timestamp4a;
    }
    @Override
    public int hashCode() {
        return number1 == null ? -1 : number1.hashCode();
    }
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null || this.getClass() != obj.getClass())
            return false;
        if (number1 == null) // not yet assigned => treat it as different
            return false;
        return this.number1.equals(((OtherTypesEntity)obj).number1);
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // no isActive column in this entity, create stubs to satisfy interface
    public void set$Active(boolean _a) {
        // throw new RuntimeException("Entity OtherTypesEntity does not have an isActive field");
    }
    public boolean get$Active() {
        return true;  // no isActive column => all rows are active by default
    }
    // no version column of type int or Integer, write stub
    public void set$IntVersion(int _v) {
        // throw new RuntimeException("Entity OtherTypesEntity does not have an integer type version field");
    }
    public int get$IntVersion() {
        return -1;
    }
    public static Class<BonaPortable> class$TrackingClass() {
        return null;
    }
    @Override
    public String get$TrackingPQON() {
        return null;
    }
    @Override
    public Class<BonaPortable> get$TrackingClass() {
        return null;
    }
    
    public static Class<Integer> class$KeyClass() {
        return Integer.class;
    }
    @Override
    public Class<Integer> get$KeyClass() {
        return Integer.class;
    }
    @Override
    public Integer get$Key() throws ApplicationException {
        return number1;
    }
    @Override
    public void set$Key(Integer _k) {
        setNumber1(_k);  // no direct assigned due to possible enum or temporal type, with implied conversions
    }
    
    @Override
    public BonaPortable get$Tracking() throws ApplicationException {
        return null;
    }
    @Override
    public void set$Tracking(BonaPortable _d) {
    }
    @Override
    public String get$DataPQON() {
        return "tests1.OtherTypes";
    }
    @Override
    public Class<? extends OtherTypes> get$DataClass() {
        return OtherTypes.class;
    }
    public static Class<OtherTypes> class$DataClass() {
        return OtherTypes.class;
    }
    public static String class$DataPQON() {
        return "tests1.OtherTypes";
    }
    @Override
    public OtherTypes get$Data() throws ApplicationException {
        OtherTypes _r = new OtherTypes();
        // auto-generated data getter for OtherTypes
        _r.setRaw1(getRaw1());
        _r.setBinary1(getBinary1());
        _r.setDay1(getDay1());
        _r.setTimestamp1(getTimestamp1());
        _r.setTimestamp2(getTimestamp2());
        _r.setTimestamp3(getTimestamp3());
        _r.setTimestamp4(getTimestamp4());
        _r.setAscii1(getAscii1());
        _r.setUnicode1(getUnicode1());
        _r.setNumber1(getNumber1());
        _r.setDecimal1(getDecimal1());
        _r.setColor1(getColor1());
        _r.setColor2(getColor2());
        _r.setVarEnum1(getVarEnum1());
        _r.setVarEnum2(getVarEnum2());
        _r.setMyUuid(getMyUuid());
        _r.setCountryCode(getCountryCode());
        _r.setLanguageCode(getLanguageCode());
        _r.setTimestamp1a(getTimestamp1a());
        _r.setTimestamp2a(getTimestamp2a());
        _r.setTimestamp3a(getTimestamp3a());
        _r.setTimestamp4a(getTimestamp4a());
        return _r;
    }
    @Override
    public void set$Data(OtherTypes _d) {
        // auto-generated data setter for OtherTypes
        setRaw1(_d.getRaw1());
        setBinary1(_d.getBinary1());
        setDay1(_d.getDay1());
        setTimestamp1(_d.getTimestamp1());
        setTimestamp2(_d.getTimestamp2());
        setTimestamp3(_d.getTimestamp3());
        setTimestamp4(_d.getTimestamp4());
        setAscii1(_d.getAscii1());
        setUnicode1(_d.getUnicode1());
        setDecimal1(_d.getDecimal1());
        setColor1(_d.getColor1());
        setColor2(_d.getColor2());
        setVarEnum1(_d.getVarEnum1());
        setVarEnum2(_d.getVarEnum2());
        setMyUuid(_d.getMyUuid());
        setCountryCode(_d.getCountryCode());
        setLanguageCode(_d.getLanguageCode());
        setTimestamp1a(_d.getTimestamp1a());
        setTimestamp2a(_d.getTimestamp2a());
        setTimestamp3a(_d.getTimestamp3a());
        setTimestamp4a(_d.getTimestamp4a());
    }
    @Override
    public BonaPersistableBase mergeFrom(final BonaPersistableBase _b) {
        if (_b instanceof OtherTypesEntity) {
            OtherTypesEntity _x = (OtherTypesEntity)_b;
            setNumber1(_x.getNumber1());
            raw1 = _x.raw1;
            binary1 = _x.binary1;
            day1 = _x.day1;
            timestamp1 = _x.timestamp1;
            timestamp2 = _x.timestamp2;
            timestamp3 = _x.timestamp3;
            timestamp4 = _x.timestamp4;
            ascii1 = _x.ascii1;
            unicode1 = _x.unicode1;
            decimal1 = _x.decimal1;
            color1 = _x.color1;
            color2 = _x.color2;
            varEnum1 = _x.varEnum1;
            varEnum2 = _x.varEnum2;
            myUuid = _x.myUuid;
            countryCode = _x.countryCode;
            languageCode = _x.languageCode;
            timestamp1a = _x.timestamp1a;
            timestamp2a = _x.timestamp2a;
            timestamp3a = _x.timestamp3a;
            timestamp4a = _x.timestamp4a;
        }
        return this;
    }
    
    
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/relations/test/Item.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.relations.test;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



public class Item
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 917946328L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "relations.test.Item";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$dummyRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "dummyRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, true, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$itemNo = new NumericElementaryDataItem(Visibility.DEFAULT, false, "itemNo", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, true, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$itemText = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "itemText", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, false, false, true, false, 80, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(3);
        FieldDefinition [] field$array = new FieldDefinition[3];
        field$array[0] = meta$$dummyRef;
        field$array[1] = meta$$itemNo;
        field$array[2] = meta$$itemText;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    Long dummyRef;
    Integer itemNo;
    String itemText;
    // auto-generated getters and setters
    public Long getDummyRef() {
        return dummyRef;
    }
    public void setDummyRef(Long dummyRef) {
        this.dummyRef = dummyRef;
    }
    public Integer getItemNo() {
        return itemNo;
    }
    public void setItemNo(Integer itemNo) {
        this.itemNo = itemNo;
    }
    public String getItemText() {
        return itemText;
    }
    public void setItemText(String itemText) {
        this.itemText = itemText;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        if (dummyRef == null) w.writeNull(meta$$dummyRef); else w.addField(dummyRef);
        if (itemNo == null) w.writeNull(meta$$itemNo); else w.addField(itemNo);
        w.addField(meta$$itemText, itemText);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("dummyRef")) {
            if (dummyRef == null) w.writeNull(meta$$dummyRef); else w.addField(dummyRef);
            return;
        }
        if (_n.equals("itemNo")) {
            if (itemNo == null) w.writeNull(meta$$itemNo); else w.addField(itemNo);
            return;
        }
        if (_n.equals("itemText")) {
            w.addField(meta$$itemText, itemText);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        dummyRef = p.readLong      ("dummyRef", false, true);
        itemNo = p.readInteger   ("itemNo", true, true);
        itemText = p.readString    ("itemText", true, 80, false, false, true, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (dummyRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "dummyRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (itemText != null) {
            if (itemText.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "itemText.length=" + itemText.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (dummyRef == null ? 0 : dummyRef.hashCode());
        _hash = 29 * _hash + (itemNo == null ? 0 : itemNo.hashCode());
        _hash = 29 * _hash + (itemText == null ? 0 : itemText.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Item))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Item))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        Item that = (Item)_that;
        return true
        && ((dummyRef == null && that.dummyRef == null) || (dummyRef != null && dummyRef.equals(that.dummyRef)))
        && ((itemNo == null && that.itemNo == null) || (itemNo != null && itemNo.equals(that.itemNo)))
        && ((itemText == null && that.itemText == null) || (itemText != null && itemText.equals(that.itemText)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        itemText = _cvt.convert(itemText, meta$$itemText);
    }
    // default no-argument constructor
    public Item() {
    }
    
    // default all-arguments constructor
    public Item(Long dummyRef
    , Integer itemNo
    , String itemText
    ) {
        this.dummyRef = dummyRef;
        this.itemNo = itemNo;
        this.itemText = itemText;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Item.class) {
            return (T) new Item(getDummyRef(), getItemNo(), getItemText());
        }
        throw new IllegalArgumentException("Item does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/relations/test/ItemEntity.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.relations.test;

import javax.persistence.EntityManager;
import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.Version;
import javax.persistence.Column;
import javax.persistence.Lob;
import javax.persistence.Basic;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.Id;
import javax.persistence.IdClass;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.NoResultException;
import javax.persistence.TypedQuery;
import javax.persistence.EmbeddedId;
import javax.persistence.Embedded;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.MapKey;
import javax.persistence.MapKeyJoinColumn;
import javax.persistence.JoinColumn;
import javax.persistence.JoinColumns;
import javax.persistence.ElementCollection;
import javax.persistence.MapKeyColumn;
import javax.persistence.CollectionTable;
import javax.persistence.EntityListeners;
import javax.persistence.UniqueConstraint;
import javax.persistence.AttributeOverride;
import javax.persistence.AttributeOverrides;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Serializable;

import de.jpaw.bonaparte.jpa.BonaPersistableNoData;
import de.jpaw.bonaparte.jpa.BonaPersistableTracking;
import de.jpaw.bonaparte.jpa.BonaPersistableBase;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.jpa.KeyClass;
import de.jpaw.bonaparte.jpa.DataClass;
import de.jpaw.bonaparte.jpa.TrackingClass;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.ByteArrayComposer;
import de.jpaw.bonaparte.core.ByteArrayParser;
import de.jpaw.bonaparte.core.MessageParserException;

@DataClass(Item.class)
@KeyClass(ItemEntityKey.class)
@Entity
@Table(name="tests_item_entity")
public class ItemEntity implements BonaPersistable<ItemEntityKey, Item, BonaPortable> {
    @EmbeddedId
    ItemEntityKey key;
    // forwarding getters and setters
    public void setDummyRef(Long _x) {
        key.setDummyRef(_x);
    }
    public Long getDummyRef() {
        return key.getDummyRef();
    }
    public void setItemNo(Integer _x) {
        key.setItemNo(_x);
    }
    public Integer getItemNo() {
        return key.getItemNo();
    }

    // table columns of java class Item
    @Column(name="item_text", length=80)
    String itemText;
    public String getItemText() {
        return itemText;
    }
    public void setItemText(String itemText) {
        this.itemText = itemText;
    }
    @Override
    public int hashCode() {
        return key == null ? -1 : key.hashCode();
    }
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null || this.getClass() != obj.getClass())
            return false;
        if (key == null) // not yet assigned => treat it as different
            return false;
        return this.key.equals(((ItemEntity)obj).key);
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // no isActive column in this entity, create stubs to satisfy interface
    public void set$Active(boolean _a) {
        // throw new RuntimeException("Entity ItemEntity does not have an isActive field");
    }
    public boolean get$Active() {
        return true;  // no isActive column => all rows are active by default
    }
    // no version column of type int or Integer, write stub
    public void set$IntVersion(int _v) {
        // throw new RuntimeException("Entity ItemEntity does not have an integer type version field");
    }
    public int get$IntVersion() {
        return -1;
    }
    public static Class<BonaPortable> class$TrackingClass() {
        return null;
    }
    @Override
    public String get$TrackingPQON() {
        return null;
    }
    @Override
    public Class<BonaPortable> get$TrackingClass() {
        return null;
    }
    
    public static Class<ItemEntityKey> class$KeyClass() {
        return ItemEntityKey.class;
    }
    @Override
    public Class<ItemEntityKey> get$KeyClass() {
        return ItemEntityKey.class;
    }
    @Override
    public ItemEntityKey get$Key() throws ApplicationException {
        return key.clone(); // as our key fields are all immutable, shallow copy is sufficient
    }
    @Override
    public void set$Key(ItemEntityKey _k) {
        key = _k.clone();   // as our key fields are all immutable, shallow copy is sufficient
    }
    
    @Override
    public BonaPortable get$Tracking() throws ApplicationException {
        return null;
    }
    @Override
    public void set$Tracking(BonaPortable _d) {
    }
    @Override
    public String get$DataPQON() {
        return "relations.test.Item";
    }
    @Override
    public Class<? extends Item> get$DataClass() {
        return Item.class;
    }
    public static Class<Item> class$DataClass() {
        return Item.class;
    }
    public static String class$DataPQON() {
        return "relations.test.Item";
    }
    @Override
    public Item get$Data() throws ApplicationException {
        Item _r = new Item();
        // auto-generated data getter for Item
        _r.setDummyRef(getDummyRef());
        _r.setItemNo(getItemNo());
        _r.setItemText(getItemText());
        return _r;
    }
    @Override
    public void set$Data(Item _d) {
        // auto-generated data setter for Item
        setItemText(_d.getItemText());
    }
    @Override
    public BonaPersistableBase mergeFrom(final BonaPersistableBase _b) {
        if (_b instanceof ItemEntity) {
            ItemEntity _x = (ItemEntity)_b;
            setDummyRef(_x.getDummyRef());
            setItemNo(_x.getItemNo());
            itemText = _x.itemText;
        }
        return this;
    }
    
    
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/relations/test/ItemEntityKey.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.relations.test;

import javax.persistence.EntityManager;
import javax.persistence.Embeddable;
import javax.persistence.Embedded;
import javax.persistence.Column;
import javax.persistence.EmbeddedId;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.ManyToOne;
import javax.persistence.JoinColumn;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Serializable;

import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.ByteArrayComposer;
import de.jpaw.bonaparte.core.ByteArrayParser;
import de.jpaw.bonaparte.core.MessageParserException;

@Embeddable
public class ItemEntityKey implements Serializable, Cloneable {
    @Column(name="dummy_ref", nullable=false)
    Long dummyRef;
    public Long getDummyRef() {
        return dummyRef;
    }
    public void setDummyRef(Long dummyRef) {
        this.dummyRef = dummyRef;
    }
    @Column(name="item_no")
    Integer itemNo;
    public Integer getItemNo() {
        return itemNo;
    }
    public void setItemNo(Integer itemNo) {
        this.itemNo = itemNo;
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (dummyRef == null ? 0 : dummyRef.hashCode());
        _hash = 29 * _hash + (itemNo == null ? 0 : itemNo.hashCode());
        return _hash;
    }
    
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof ItemEntityKey))
            return false;
        if (this == _that)
            return true;
        ItemEntityKey that = (ItemEntityKey)_that;
        return true
        && ((dummyRef == null && that.dummyRef == null) || dummyRef.equals(that.dummyRef))
        && ((itemNo == null && that.itemNo == null) || itemNo.equals(that.itemNo))
        ;
    }
    @Override
    public ItemEntityKey clone() {
        try {
            return (ItemEntityKey)super.clone();
        } catch (CloneNotSupportedException e) {
            return this;  // fallback
        }
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/relations/test/Parent.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.relations.test;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



public class Parent
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 1861365807L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "relations.test.Parent";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$key = new NumericElementaryDataItem(Visibility.DEFAULT, true, "key", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, true, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$text = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "text", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, false, false, true, false, 80, 0, null);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(2);
        FieldDefinition [] field$array = new FieldDefinition[2];
        field$array[0] = meta$$key;
        field$array[1] = meta$$text;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    Long key;
    String text;
    // auto-generated getters and setters
    public Long getKey() {
        return key;
    }
    public void setKey(Long key) {
        this.key = key;
    }
    public String getText() {
        return text;
    }
    public void setText(String text) {
        this.text = text;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        if (key == null) w.writeNull(meta$$key); else w.addField(key);
        w.addField(meta$$text, text);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("key")) {
            if (key == null) w.writeNull(meta$$key); else w.addField(key);
            return;
        }
        if (_n.equals("text")) {
            w.addField(meta$$text, text);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        key = p.readLong      ("key", false, true);
        text = p.readString    ("text", true, 80, false, false, true, true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (key == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "key", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (text != null) {
            if (text.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "text.length=" + text.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (key == null ? 0 : key.hashCode());
        _hash = 29 * _hash + (text == null ? 0 : text.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Parent))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof Parent))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        Parent that = (Parent)_that;
        return true
        && ((key == null && that.key == null) || (key != null && key.equals(that.key)))
        && ((text == null && that.text == null) || (text != null && text.equals(that.text)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        text = _cvt.convert(text, meta$$text);
    }
    // default no-argument constructor
    public Parent() {
    }
    
    // default all-arguments constructor
    public Parent(Long key
    , String text
    ) {
        this.key = key;
        this.text = text;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == Parent.class) {
            return (T) new Parent(getKey(), getText());
        }
        throw new IllegalArgumentException("Parent does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/relations/test/ParentEntity.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.relations.test;

import javax.persistence.EntityManager;
import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.Version;
import javax.persistence.Column;
import javax.persistence.Lob;
import javax.persistence.Basic;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.Id;
import javax.persistence.IdClass;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.NoResultException;
import javax.persistence.TypedQuery;
import javax.persistence.EmbeddedId;
import javax.persistence.Embedded;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.MapKey;
import javax.persistence.MapKeyJoinColumn;
import javax.persistence.JoinColumn;
import javax.persistence.JoinColumns;
import javax.persistence.ElementCollection;
import javax.persistence.MapKeyColumn;
import javax.persistence.CollectionTable;
import javax.persistence.EntityListeners;
import javax.persistence.UniqueConstraint;
import javax.persistence.AttributeOverride;
import javax.persistence.AttributeOverrides;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Serializable;

import de.jpaw.bonaparte.jpa.BonaPersistableNoData;
import de.jpaw.bonaparte.jpa.BonaPersistableTracking;
import de.jpaw.bonaparte.jpa.BonaPersistableBase;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.jpa.KeyClass;
import de.jpaw.bonaparte.jpa.DataClass;
import de.jpaw.bonaparte.jpa.TrackingClass;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.ByteArrayComposer;
import de.jpaw.bonaparte.core.ByteArrayParser;
import de.jpaw.bonaparte.core.MessageParserException;

@DataClass(Parent.class)
@KeyClass(Long.class)
@Entity
@Table(name="tests_parent_entity")
public class ParentEntity implements BonaPersistable<Long, Parent, BonaPortable> {
    // table columns of java class Parent
    @Id
    @Column(name="key", nullable=false)
    Long key;
    public Long getKey() {
        return key;
    }
    public void setKey(Long key) {
        this.key = key;
    }
    @Column(name="text", length=80)
    String text;
    public String getText() {
        return text;
    }
    public void setText(String text) {
        this.text = text;
    }
    @Override
    public int hashCode() {
        return key == null ? -1 : key.hashCode();
    }
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null || this.getClass() != obj.getClass())
            return false;
        if (key == null) // not yet assigned => treat it as different
            return false;
        return this.key.equals(((ParentEntity)obj).key);
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // no isActive column in this entity, create stubs to satisfy interface
    public void set$Active(boolean _a) {
        // throw new RuntimeException("Entity ParentEntity does not have an isActive field");
    }
    public boolean get$Active() {
        return true;  // no isActive column => all rows are active by default
    }
    // no version column of type int or Integer, write stub
    public void set$IntVersion(int _v) {
        // throw new RuntimeException("Entity ParentEntity does not have an integer type version field");
    }
    public int get$IntVersion() {
        return -1;
    }
    public static Class<BonaPortable> class$TrackingClass() {
        return null;
    }
    @Override
    public String get$TrackingPQON() {
        return null;
    }
    @Override
    public Class<BonaPortable> get$TrackingClass() {
        return null;
    }
    
    public static Class<Long> class$KeyClass() {
        return Long.class;
    }
    @Override
    public Class<Long> get$KeyClass() {
        return Long.class;
    }
    @Override
    public Long get$Key() throws ApplicationException {
        return key;
    }
    @Override
    public void set$Key(Long _k) {
        setKey(_k);  // no direct assigned due to possible enum or temporal type, with implied conversions
    }
    
    @Override
    public BonaPortable get$Tracking() throws ApplicationException {
        return null;
    }
    @Override
    public void set$Tracking(BonaPortable _d) {
    }
    @Override
    public String get$DataPQON() {
        return "relations.test.Parent";
    }
    @Override
    public Class<? extends Parent> get$DataClass() {
        return Parent.class;
    }
    public static Class<Parent> class$DataClass() {
        return Parent.class;
    }
    public static String class$DataPQON() {
        return "relations.test.Parent";
    }
    @Override
    public Parent get$Data() throws ApplicationException {
        Parent _r = new Parent();
        // auto-generated data getter for Parent
        _r.setKey(getKey());
        _r.setText(getText());
        return _r;
    }
    @Override
    public void set$Data(Parent _d) {
        // auto-generated data setter for Parent
        setText(_d.getText());
    }
    @Override
    public BonaPersistableBase mergeFrom(final BonaPersistableBase _b) {
        if (_b instanceof ParentEntity) {
            ParentEntity _x = (ParentEntity)_b;
            setKey(_x.getKey());
            text = _x.text;
        }
        return this;
    }
    
    
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/relations/test/TestEntity.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.relations.test;

import javax.persistence.EntityManager;
import javax.persistence.Entity;
import javax.persistence.Table;
import javax.persistence.Version;
import javax.persistence.Column;
import javax.persistence.Lob;
import javax.persistence.Basic;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.Id;
import javax.persistence.IdClass;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.NoResultException;
import javax.persistence.TypedQuery;
import javax.persistence.EmbeddedId;
import javax.persistence.Embedded;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;
import javax.persistence.FetchType;
import javax.persistence.CascadeType;
import javax.persistence.MapKey;
import javax.persistence.MapKeyJoinColumn;
import javax.persistence.JoinColumn;
import javax.persistence.JoinColumns;
import javax.persistence.ElementCollection;
import javax.persistence.MapKeyColumn;
import javax.persistence.CollectionTable;
import javax.persistence.EntityListeners;
import javax.persistence.UniqueConstraint;
import javax.persistence.AttributeOverride;
import javax.persistence.AttributeOverrides;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Serializable;

import de.jpaw.bonaparte.jpa.BonaPersistableNoData;
import de.jpaw.bonaparte.jpa.BonaPersistableTracking;
import de.jpaw.bonaparte.jpa.BonaPersistableBase;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.jpa.KeyClass;
import de.jpaw.bonaparte.jpa.DataClass;
import de.jpaw.bonaparte.jpa.TrackingClass;
import de.jpaw.bonaparte.jpa.BonaPersistable;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.ByteArrayComposer;
import de.jpaw.bonaparte.core.ByteArrayParser;
import de.jpaw.bonaparte.core.MessageParserException;

@DataClass(TestObject.class)
@KeyClass(Long.class)
@Entity
@Table(name="tests_test_entity")
public class TestEntity implements BonaPersistableNoData<Long, BonaPortable> {
    // table columns of java class TestObject
    @Id
    @Column(name="my_key")
    Long myKey;
    public Long getMyKey() {
        return myKey;
    }
    public void setMyKey(Long myKey) {
        this.myKey = myKey;
    }
    @Column(name="parent_ref", nullable=false)
    Long parentRef;
    public Long getParentRef() {
        return parentRef;
    }
    public void setParentRef(Long parentRef) {
        this.parentRef = parentRef;
    }
    @Column(name="name", length=80)
    String name;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    @ElementCollection
    @CollectionTable(name="the_other_table", joinColumns=@JoinColumn(name="test_entity_key"))
    @MapKeyColumn(name="currencyCode")
    @Column(name="prices", precision=14, scale=2)
    Map<String,BigDecimal> prices;
    public Map<String,BigDecimal> getPrices() {
        return prices;
    }
    public void setPrices(Map<String,BigDecimal> prices) {
        this.prices = prices;
    }
    @Override
    public int hashCode() {
        return myKey == null ? -1 : myKey.hashCode();
    }
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null || this.getClass() != obj.getClass())
            return false;
        if (myKey == null) // not yet assigned => treat it as different
            return false;
        return this.myKey.equals(((TestEntity)obj).myKey);
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // no isActive column in this entity, create stubs to satisfy interface
    public void set$Active(boolean _a) {
        // throw new RuntimeException("Entity TestEntity does not have an isActive field");
    }
    public boolean get$Active() {
        return true;  // no isActive column => all rows are active by default
    }
    // no version column of type int or Integer, write stub
    public void set$IntVersion(int _v) {
        // throw new RuntimeException("Entity TestEntity does not have an integer type version field");
    }
    public int get$IntVersion() {
        return -1;
    }
    public static Class<BonaPortable> class$TrackingClass() {
        return null;
    }
    @Override
    public String get$TrackingPQON() {
        return null;
    }
    @Override
    public Class<BonaPortable> get$TrackingClass() {
        return null;
    }
    
    public static Class<Long> class$KeyClass() {
        return Long.class;
    }
    @Override
    public Class<Long> get$KeyClass() {
        return Long.class;
    }
    @Override
    public Long get$Key() throws ApplicationException {
        return myKey;
    }
    @Override
    public void set$Key(Long _k) {
        setMyKey(_k);  // no direct assigned due to possible enum or temporal type, with implied conversions
    }
    
    @Override
    public BonaPortable get$Tracking() throws ApplicationException {
        return null;
    }
    @Override
    public void set$Tracking(BonaPortable _d) {
    }
    @Override
    public BonaPersistableBase mergeFrom(final BonaPersistableBase _b) {
        if (_b instanceof TestEntity) {
            TestEntity _x = (TestEntity)_b;
            setMyKey(_x.getMyKey());
            parentRef = _x.parentRef;
            name = _x.name;
        }
        return this;
    }
    @ManyToOne(fetch=FetchType.LAZY, optional=false)
    @JoinColumn(name="parent_ref", referencedColumnName="key", insertable=false, updatable=false)
    ParentEntity parent;
    
    public ParentEntity getParent() {
        return parent;
    }
    
    
    @OneToMany(orphanRemoval=true, cascade=CascadeType.ALL, fetch=FetchType.EAGER)
    @JoinColumn(name="dummy_ref", referencedColumnName="my_key")
    List<ItemEntity> items = new ArrayList<ItemEntity>();
    
    public List<ItemEntity> getItems() {
        return items;
    }
    public void setItems(List<ItemEntity> items) {
        this.items = items;
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/relations/test/TestObject.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.relations.test;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



public class TestObject
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = -1160479882L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "relations.test.TestObject";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$myKey = new NumericElementaryDataItem(Visibility.DEFAULT, false, "myKey", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, true, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$parentRef = new NumericElementaryDataItem(Visibility.DEFAULT, true, "parentRef", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, true, 0, 0, false, false);
    protected static final AlphanumericElementaryDataItem meta$$name = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "name", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, false, false, true, false, 80, 0, null);
    protected static final NumericElementaryDataItem meta$$prices = new NumericElementaryDataItem(Visibility.DEFAULT, false, "prices", Multiplicity.MAP, 1, 0, 0, DataCategory.NUMERIC,
        "BigDecimal", false, true, 14, 2, false, false);
    protected static final ObjectReference meta$$items = new ObjectReference(Visibility.DEFAULT, false, "items", Multiplicity.LIST, 0, 0, 0, DataCategory.OBJECT,
        "Item", false, true, "Item");
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(5);
        FieldDefinition [] field$array = new FieldDefinition[5];
        field$array[0] = meta$$myKey;
        field$array[1] = meta$$parentRef;
        field$array[2] = meta$$name;
        field$array[3] = meta$$prices;
        field$array[4] = meta$$items;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    Long myKey;
    Long parentRef;
    String name;
    Map<String,BigDecimal> prices;
    List<Item> items;
    // auto-generated getters and setters
    public Long getMyKey() {
        return myKey;
    }
    public void setMyKey(Long myKey) {
        this.myKey = myKey;
    }
    public Long getParentRef() {
        return parentRef;
    }
    public void setParentRef(Long parentRef) {
        this.parentRef = parentRef;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Map<String,BigDecimal> getPrices() {
        return prices;
    }
    public void setPrices(Map<String,BigDecimal> prices) {
        this.prices = prices;
    }
    public List<Item> getItems() {
        return items;
    }
    public void setItems(List<Item> items) {
        this.items = items;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        if (myKey == null) w.writeNull(meta$$myKey); else w.addField(myKey);
        if (parentRef == null) w.writeNull(meta$$parentRef); else w.addField(parentRef);
        w.addField(meta$$name, name);
        if (prices == null) {
            w.writeNullCollection(meta$$prices);
        } else {
            w.startMap(prices.size(), 1);
            for (Map.Entry<String,BigDecimal> _i : prices.entrySet()) {
                // write (key, value) tuples
                w.addField(StaticMeta.MAP_INDEX_META, _i.getKey());
                w.addField(meta$$prices, _i.getValue());
            }
            w.terminateArray();
        }
        if (items == null) {
            w.writeNullCollection(meta$$items);
        } else {
            w.startArray(items.size(), 0, 0);
            for (Item _i : items)
                w.addField((BonaPortable)_i);
            w.terminateArray();
        }
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("myKey")) {
            if (myKey == null) w.writeNull(meta$$myKey); else w.addField(myKey);
            return;
        }
        if (_n.equals("parentRef")) {
            if (parentRef == null) w.writeNull(meta$$parentRef); else w.addField(parentRef);
            return;
        }
        if (_n.equals("name")) {
            w.addField(meta$$name, name);
            return;
        }
        if (_n.equals("prices")) {
            if (prices == null) {
                w.writeNullCollection(meta$$prices);
            } else {
                if (pfc.alphaIndex == null) {
                    w.startMap(prices.size(), 1);
                    for (Map.Entry<String,BigDecimal> _i : prices.entrySet()) {
                        // write (key, value) tuples
                        w.addField(StaticMeta.MAP_INDEX_META, _i.getKey());
                        w.addField(meta$$prices, _i.getValue());
                    }
                    w.terminateArray();
                } else {
                    w.addField(meta$$prices, prices.get(pfc.alphaIndex));
                }
            }
            return;
        }
        if (_n.equals("items")) {
            if (items == null) {
                w.writeNullCollection(meta$$items);
            } else {
                if (pfc.index < 0) {
                    w.startArray(items.size(), 0, 0);
                    for (Item _i : items) {
                        if (_i == null) {
                            w.writeNull(meta$$items);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)_i);             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            _i.foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                    w.terminateArray();
                } else {
                    if (pfc.index < items.size()) {
                        // output single element
                        if (items.get(pfc.index) == null) {
                            w.writeNull(meta$$items);
                        } else if (pfc.getComponent() == null) {
                            w.addField((BonaPortable)items.get(pfc.index));             // full / recursive object output
                        } else {
                            // write a specific subcomponent
                            items.get(pfc.index).foldedOutput(w, pfc.getComponent());   // recurse specific field
                        }
                    }
                }
            }
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        myKey = p.readLong      ("myKey", true, true);
        parentRef = p.readLong      ("parentRef", false, true);
        name = p.readString    ("name", true, 80, false, false, true, true);
        _length = p.parseMapStart("prices", true, 1);
        if (_length < 0) {
            prices = null;
        } else {
            prices = new HashMap<String, BigDecimal>(_length);
            for (int _i = 0; _i < _length; ++_i) {
                String _key = p.readString("prices", false, 255, false, false, true, true);
                prices.put(_key, p.readBigDecimal("prices", true, 14, 2, true, false, false));
            }
            p.parseArrayEnd();
        }
        _length = p.parseArrayStart("items", true, 0, 0);
        if (_length < 0) {
            items = null;
        } else {
            items = new ArrayList<Item>(_length);
            for (int _i = 0; _i < _length; ++_i)
                items.add((Item)p.readObject("items", Item.class, true, true));
            p.parseArrayEnd();
        }
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (parentRef == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "parentRef", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (items != null)
            for (Item _i : items)
        if (_i != null)
            _i.validate();  // check object
        if (name != null) {
            if (name.length() > 80)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "name.length=" + name.length() + " > 80",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (myKey == null ? 0 : myKey.hashCode());
        _hash = 29 * _hash + (parentRef == null ? 0 : parentRef.hashCode());
        _hash = 29 * _hash + (name == null ? 0 : name.hashCode());
        _hash = 29 * _hash + (prices == null ? 0 : prices.hashCode());
        _hash = 29 * _hash + (items == null ? 0 : items.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof TestObject))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof TestObject))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        TestObject that = (TestObject)_that;
        return true
        && ((myKey == null && that.myKey == null) || (myKey != null && myKey.equals(that.myKey)))
        && ((parentRef == null && that.parentRef == null) || (parentRef != null && parentRef.equals(that.parentRef)))
        && ((name == null && that.name == null) || (name != null && name.equals(that.name)))
        && ((prices == null && that.prices == null) || (prices != null && that.prices != null && xCompareSub$prices(that)))
        && ((items == null && that.items == null) || (items != null && that.items != null && xCompareSub$items(that)))
        ;
    }
    private boolean xCompareSub$prices(TestObject that) {
        // both prices and that prices are known to be not null
        if (prices.size() != that.prices.size())
            return false;
        // method is to verify all entries are the same
        for (Map.Entry<String, BigDecimal> _i : prices.entrySet()) {
            BigDecimal _t = that.prices.get(_i.getKey());
            if (!(((_i.getValue() == null && _t == null) || (_i.getValue() != null && BigDecimalTools.equals(_i.getValue(), 2, _t, 2)))))
                return false;
        }
        return true;
    }
    private boolean xCompareSub$items(TestObject that) {
        // both items and that items are known to be not null
        if (items.size() != that.items.size())
            return false;
        // indexed access is not optional, but sequential access will be left for later optimization
        for (int _i = 0; _i < items.size(); ++_i)
            if (!(((items.get(_i) == null && that.items.get(_i) == null) || (items.get(_i) != null && items.get(_i).hasSameContentsAs(that.items.get(_i))))))
                return false;
        return true;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        name = _cvt.convert(name, meta$$name);
        if (items != null)
            for (Item _i : items)
        if (_i != null)
            _i.treeWalkString(_cvt);
    }
    // default no-argument constructor
    public TestObject() {
    }
    
    // default all-arguments constructor
    public TestObject(Long myKey
    , Long parentRef
    , String name
    , Map<String,BigDecimal> prices
    , List<Item> items
    ) {
        this.myKey = myKey;
        this.parentRef = parentRef;
        this.name = name;
        this.prices = prices;
        this.items = items;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == TestObject.class) {
            return (T) new TestObject(getMyKey(), getParentRef(), getName(), getPrices(), getItems());
        }
        throw new IllegalArgumentException("TestObject does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/relations/test/package-info.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

package de.jpaw.bonaparte.pojos.relations.test;
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/tests1/AlphaColor.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.tests1;

import de.jpaw.util.EnumException;
import de.jpaw.enums.TokenizableEnum;


public enum AlphaColor implements TokenizableEnum {
    RED("R"), GREEN("G"), BLUE("B");

    // constructor by token
    private String _token;
    private AlphaColor(String _token) {
        this._token = _token;
    }

    // token retrieval
    @Override
    public String getToken() {
        return _token;
    }

    // static factory method.
    public static AlphaColor factory(String _token) throws EnumException {
        if (_token != null) {
            if (_token.equals("R")) return RED;
            if (_token.equals("G")) return GREEN;
            if (_token.equals("B")) return BLUE;
            throw new EnumException(EnumException.INVALID_NUM, _token);
        }
        return null;
    }

    public static AlphaColor valueOf(Integer ordinal) throws EnumException {
        if (ordinal != null) {
            switch (ordinal.intValue()) {
            case 0: return RED;
            case 1: return GREEN;
            case 2: return BLUE;
            default: throw new EnumException(EnumException.INVALID_NUM, ordinal.toString());
            }
        }
        return null;
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/tests1/BoxedTypes.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.tests1;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



public class BoxedTypes
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 621061517L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "tests1.BoxedTypes";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final NumericElementaryDataItem meta$$byte1 = new NumericElementaryDataItem(Visibility.DEFAULT, false, "byte1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Byte", false, true, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$short1 = new NumericElementaryDataItem(Visibility.DEFAULT, false, "short1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Short", false, true, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$int1 = new NumericElementaryDataItem(Visibility.DEFAULT, false, "int1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, true, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$int2 = new NumericElementaryDataItem(Visibility.DEFAULT, false, "int2", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, true, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$long1 = new NumericElementaryDataItem(Visibility.DEFAULT, false, "long1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Long", false, true, 0, 0, false, false);
    protected static final MiscElementaryDataItem meta$$boolean1 = new MiscElementaryDataItem(Visibility.DEFAULT, false, "boolean1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Boolean", false);
    protected static final NumericElementaryDataItem meta$$float1 = new NumericElementaryDataItem(Visibility.DEFAULT, false, "float1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Float", false, true, 0, 0, false, false);
    protected static final NumericElementaryDataItem meta$$double1 = new NumericElementaryDataItem(Visibility.DEFAULT, false, "double1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Double", false, true, 0, 0, false, false);
    protected static final MiscElementaryDataItem meta$$char1 = new MiscElementaryDataItem(Visibility.DEFAULT, false, "char1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Character", false);
    protected static final MiscElementaryDataItem meta$$char2 = new MiscElementaryDataItem(Visibility.DEFAULT, false, "char2", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "Character", false);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(10);
        FieldDefinition [] field$array = new FieldDefinition[10];
        field$array[0] = meta$$byte1;
        field$array[1] = meta$$short1;
        field$array[2] = meta$$int1;
        field$array[3] = meta$$int2;
        field$array[4] = meta$$long1;
        field$array[5] = meta$$boolean1;
        field$array[6] = meta$$float1;
        field$array[7] = meta$$double1;
        field$array[8] = meta$$char1;
        field$array[9] = meta$$char2;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    Byte byte1;
    Short short1;
    Integer int1;
    Integer int2;
    Long long1;
    Boolean boolean1;
    Float float1;
    Double double1;
    Character char1;
    Character char2;
    // auto-generated getters and setters
    public Byte getByte1() {
        return byte1;
    }
    public void setByte1(Byte byte1) {
        this.byte1 = byte1;
    }
    public Short getShort1() {
        return short1;
    }
    public void setShort1(Short short1) {
        this.short1 = short1;
    }
    public Integer getInt1() {
        return int1;
    }
    public void setInt1(Integer int1) {
        this.int1 = int1;
    }
    public Integer getInt2() {
        return int2;
    }
    public void setInt2(Integer int2) {
        this.int2 = int2;
    }
    public Long getLong1() {
        return long1;
    }
    public void setLong1(Long long1) {
        this.long1 = long1;
    }
    public Boolean getBoolean1() {
        return boolean1;
    }
    public void setBoolean1(Boolean boolean1) {
        this.boolean1 = boolean1;
    }
    public Float getFloat1() {
        return float1;
    }
    public void setFloat1(Float float1) {
        this.float1 = float1;
    }
    public Double getDouble1() {
        return double1;
    }
    public void setDouble1(Double double1) {
        this.double1 = double1;
    }
    public Character getChar1() {
        return char1;
    }
    public void setChar1(Character char1) {
        this.char1 = char1;
    }
    public Character getChar2() {
        return char2;
    }
    public void setChar2(Character char2) {
        this.char2 = char2;
    }
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        if (byte1 == null) w.writeNull(meta$$byte1); else w.addField(byte1);
        if (short1 == null) w.writeNull(meta$$short1); else w.addField(short1);
        if (int1 == null) w.writeNull(meta$$int1); else w.addField(int1);
        if (int2 == null) w.writeNull(meta$$int2); else w.addField(int2);
        if (long1 == null) w.writeNull(meta$$long1); else w.addField(long1);
        if (boolean1 == null) w.writeNull(meta$$boolean1); else w.addField(boolean1);
        if (float1 == null) w.writeNull(meta$$float1); else w.addField(float1);
        if (double1 == null) w.writeNull(meta$$double1); else w.addField(double1);
        if (char1 == null) w.writeNull(meta$$char1); else w.addField(char1);
        if (char2 == null) w.writeNull(meta$$char2); else w.addField(char2);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("byte1")) {
            if (byte1 == null) w.writeNull(meta$$byte1); else w.addField(byte1);
            return;
        }
        if (_n.equals("short1")) {
            if (short1 == null) w.writeNull(meta$$short1); else w.addField(short1);
            return;
        }
        if (_n.equals("int1")) {
            if (int1 == null) w.writeNull(meta$$int1); else w.addField(int1);
            return;
        }
        if (_n.equals("int2")) {
            if (int2 == null) w.writeNull(meta$$int2); else w.addField(int2);
            return;
        }
        if (_n.equals("long1")) {
            if (long1 == null) w.writeNull(meta$$long1); else w.addField(long1);
            return;
        }
        if (_n.equals("boolean1")) {
            if (boolean1 == null) w.writeNull(meta$$boolean1); else w.addField(boolean1);
            return;
        }
        if (_n.equals("float1")) {
            if (float1 == null) w.writeNull(meta$$float1); else w.addField(float1);
            return;
        }
        if (_n.equals("double1")) {
            if (double1 == null) w.writeNull(meta$$double1); else w.addField(double1);
            return;
        }
        if (_n.equals("char1")) {
            if (char1 == null) w.writeNull(meta$$char1); else w.addField(char1);
            return;
        }
        if (_n.equals("char2")) {
            if (char2 == null) w.writeNull(meta$$char2); else w.addField(char2);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        byte1 = p.readByte      ("byte1", true, true);
        short1 = p.readShort     ("short1", true, true);
        int1 = p.readInteger   ("int1", true, true);
        int2 = p.readInteger   ("int2", true, true);
        long1 = p.readLong      ("long1", true, true);
        boolean1 = p.readBoolean   ("boolean1", true);
        float1 = p.readFloat     ("float1", true, true);
        double1 = p.readDouble    ("double1", true, true);
        char1 = p.readCharacter ("char1", true);
        char2 = p.readCharacter ("char2", true);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (byte1 == null ? 0 : byte1.hashCode());
        _hash = 29 * _hash + (short1 == null ? 0 : short1.hashCode());
        _hash = 29 * _hash + (int1 == null ? 0 : int1.hashCode());
        _hash = 29 * _hash + (int2 == null ? 0 : int2.hashCode());
        _hash = 29 * _hash + (long1 == null ? 0 : long1.hashCode());
        _hash = 29 * _hash + (boolean1 == null ? 0 : boolean1.hashCode());
        _hash = 29 * _hash + (float1 == null ? 0 : float1.hashCode());
        _hash = 29 * _hash + (double1 == null ? 0 : double1.hashCode());
        _hash = 29 * _hash + (char1 == null ? 0 : char1.hashCode());
        _hash = 29 * _hash + (char2 == null ? 0 : char2.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof BoxedTypes))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof BoxedTypes))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        BoxedTypes that = (BoxedTypes)_that;
        return true
        && ((byte1 == null && that.byte1 == null) || (byte1 != null && byte1.equals(that.byte1)))
        && ((short1 == null && that.short1 == null) || (short1 != null && short1.equals(that.short1)))
        && ((int1 == null && that.int1 == null) || (int1 != null && int1.equals(that.int1)))
        && ((int2 == null && that.int2 == null) || (int2 != null && int2.equals(that.int2)))
        && ((long1 == null && that.long1 == null) || (long1 != null && long1.equals(that.long1)))
        && ((boolean1 == null && that.boolean1 == null) || (boolean1 != null && boolean1.equals(that.boolean1)))
        && ((float1 == null && that.float1 == null) || (float1 != null && float1.equals(that.float1)))
        && ((double1 == null && that.double1 == null) || (double1 != null && double1.equals(that.double1)))
        && ((char1 == null && that.char1 == null) || (char1 != null && char1.equals(that.char1)))
        && ((char2 == null && that.char2 == null) || (char2 != null && char2.equals(that.char2)))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
    }
    // default no-argument constructor
    public BoxedTypes() {
    }
    
    // default all-arguments constructor
    public BoxedTypes(Byte byte1
    , Short short1
    , Integer int1
    , Integer int2
    , Long long1
    , Boolean boolean1
    , Float float1
    , Double double1
    , Character char1
    , Character char2
    ) {
        this.byte1 = byte1;
        this.short1 = short1;
        this.int1 = int1;
        this.int2 = int2;
        this.long1 = long1;
        this.boolean1 = boolean1;
        this.float1 = float1;
        this.double1 = double1;
        this.char1 = char1;
        this.char2 = char2;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == BoxedTypes.class) {
            return (T) new BoxedTypes(getByte1(), getShort1(), getInt1(), getInt2(), getLong1(), getBoolean1(), getFloat1(), getDouble1(), getChar1(), getChar2());
        }
        throw new IllegalArgumentException("BoxedTypes does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/tests1/Color.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.tests1;

import de.jpaw.util.EnumException;
import de.jpaw.enums.TokenizableEnum;


public enum Color {
    RED, GREEN, BLUE;

    public static Color valueOf(Integer ordinal) throws EnumException {
        if (ordinal != null) {
            switch (ordinal.intValue()) {
            case 0: return RED;
            case 1: return GREEN;
            case 2: return BLUE;
            default: throw new EnumException(EnumException.INVALID_NUM, ordinal.toString());
            }
        }
        return null;
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/tests1/OtherTypes.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.tests1;

import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.UUID;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.math.BigDecimal;
import de.jpaw.util.EnumException;
import de.jpaw.util.ByteArray;
import de.jpaw.util.CharTestsASCII;
import de.jpaw.util.ToStringHelper;
import de.jpaw.util.ApplicationException;
import de.jpaw.util.DayTime;
import de.jpaw.util.ByteUtil;
import de.jpaw.util.BigDecimalTools;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import de.jpaw.bonaparte.core.ExternalizableConstants;
import de.jpaw.bonaparte.core.ExternalizableComposer;
import de.jpaw.bonaparte.core.ExternalizableParser;
import de.jpaw.bonaparte.core.BonaPortable;
import de.jpaw.bonaparte.core.MessageParser;
import de.jpaw.bonaparte.core.MessageComposer;
import de.jpaw.bonaparte.core.MessageParserException;
import de.jpaw.bonaparte.core.ObjectValidationException;
import de.jpaw.bonaparte.core.StringConverter;
import de.jpaw.bonaparte.core.StaticMeta;
import de.jpaw.bonaparte.pojos.meta.*;



public class OtherTypes
  implements BonaPortable, Externalizable {
    private static final long serialVersionUID = 199662055L;

    // property map
    private static final ConcurrentMap<String,String> property$Map = new ConcurrentHashMap<String,String>();
    
    // initializer
    protected static void class$fillProperties(ConcurrentMap<String,String> map) {
    }
    static {
        class$fillProperties(property$Map);
    }
    static public ConcurrentMap<String,String> class$PropertyMap() {
        return property$Map;
    }
    public ConcurrentMap<String,String> get$PropertyMap() {
        return property$Map;
    }
    static public String get$Property(String propertyname, String fieldname) {
        return property$Map.get(fieldname == null ? propertyname : fieldname + "." + propertyname);
    }
    
    static public String class$Property(String id) {
        return property$Map.get(id);
    }
    static public String field$Property(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.get(id);
    }
    static public boolean class$hasProperty(String id) {
        return property$Map.containsKey(id);
    }
    static public boolean field$hasProperty(String fieldname, String propertyname) {
        String id = fieldname + "." + propertyname;
        return property$Map.containsKey(id);
    }
    public String get$Property(String id) {
        return class$Property(id);
    }
    
    static public Class<? extends BonaPortable> class$returns() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$returns() {
        return class$returns();
    }
    
    
    static public Class<? extends BonaPortable> class$pk() {
        return null;
    }
    
    @Override
    public Class<? extends BonaPortable> get$pk() {
        return class$pk();
    }
    
    // my name and revision
    private static final String PARTIALLY_QUALIFIED_CLASS_NAME = "tests1.OtherTypes";
    private static final String REVISION = null;
    private static final String PARENT = null;
    private static final String BUNDLE = null;
    
    protected static final BinaryElementaryDataItem meta$$raw1 = new BinaryElementaryDataItem(Visibility.DEFAULT, true, "raw1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.BINARY,
        "byte []", false, 1000000);
    protected static final BinaryElementaryDataItem meta$$binary1 = new BinaryElementaryDataItem(Visibility.DEFAULT, true, "binary1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.BINARY,
        "ByteArray", false, 1000000);
    protected static final TemporalElementaryDataItem meta$$day1 = new TemporalElementaryDataItem(Visibility.DEFAULT, true, "day1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDate", false, 0, false);
    protected static final TemporalElementaryDataItem meta$$timestamp1 = new TemporalElementaryDataItem(Visibility.DEFAULT, true, "timestamp1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, false);
    protected static final TemporalElementaryDataItem meta$$timestamp2 = new TemporalElementaryDataItem(Visibility.DEFAULT, true, "timestamp2", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 3, false);
    protected static final TemporalElementaryDataItem meta$$timestamp3 = new TemporalElementaryDataItem(Visibility.DEFAULT, true, "timestamp3", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "Calendar", false, 0, false);
    protected static final TemporalElementaryDataItem meta$$timestamp4 = new TemporalElementaryDataItem(Visibility.DEFAULT, true, "timestamp4", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "Calendar", false, 3, false);
    protected static final AlphanumericElementaryDataItem meta$$ascii1 = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "ascii1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, false, false, true, true, 30, 0, null);
    protected static final AlphanumericElementaryDataItem meta$$unicode1 = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "unicode1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, false, false, true, false, 30, 0, null);
    protected static final NumericElementaryDataItem meta$$number1 = new NumericElementaryDataItem(Visibility.DEFAULT, true, "number1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "Integer", false, true, 4, 0, false, false);
    protected static final NumericElementaryDataItem meta$$decimal1 = new NumericElementaryDataItem(Visibility.DEFAULT, true, "decimal1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "BigDecimal", false, true, 14, 2, false, false);
    protected static final NumericElementaryDataItem meta$$color1$token = new NumericElementaryDataItem(Visibility.DEFAULT, true, "color1$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.NUMERIC,
        "int", true, false, 4, 0, false, false);  // assume 4 digits
    protected static final EnumDataItem meta$$color1 = new EnumDataItem(Visibility.DEFAULT, true, "color1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "Color", false, "Color", null);
    protected static final AlphanumericElementaryDataItem meta$$color2$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "color2$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 1, 0, null);
    protected static final EnumDataItem meta$$color2 = new EnumDataItem(Visibility.DEFAULT, true, "color2", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "AlphaColor", false, "AlphaColor", null);
    protected static final AlphanumericElementaryDataItem meta$$varEnum1$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "varEnum1$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 19, 0, null);
    protected static final EnumDataItem meta$$varEnum1 = new EnumDataItem(Visibility.DEFAULT, true, "varEnum1", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "VariableLength", false, "VariableLength", null);
    protected static final AlphanumericElementaryDataItem meta$$varEnum2$token = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "varEnum2$token", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, true, false, false, false, 4, 0, null);
    protected static final EnumDataItem meta$$varEnum2 = new EnumDataItem(Visibility.DEFAULT, true, "varEnum2", Multiplicity.SCALAR, 0, 0, 0, DataCategory.ENUM,
        "VariableLengthUnicode", false, "VariableLengthUnicode", null);
    protected static final MiscElementaryDataItem meta$$myUuid = new MiscElementaryDataItem(Visibility.DEFAULT, true, "myUuid", Multiplicity.SCALAR, 0, 0, 0, DataCategory.MISC,
        "UUID", false);
    protected static final AlphanumericElementaryDataItem meta$$countryCode = new AlphanumericElementaryDataItem(Visibility.DEFAULT, true, "countryCode", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, false, false, true, true, 2, 2, null);
    protected static final AlphanumericElementaryDataItem meta$$languageCode = new AlphanumericElementaryDataItem(Visibility.DEFAULT, false, "languageCode", Multiplicity.SCALAR, 0, 0, 0, DataCategory.STRING,
        "String", false, false, false, true, true, 5, 2, "[a-z][a-z](_[A-Z][A-Z])?");
    protected static final TemporalElementaryDataItem meta$$timestamp1a = new TemporalElementaryDataItem(Visibility.DEFAULT, true, "timestamp1a", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 0, true);
    protected static final TemporalElementaryDataItem meta$$timestamp2a = new TemporalElementaryDataItem(Visibility.DEFAULT, true, "timestamp2a", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "LocalDateTime", false, 3, true);
    protected static final TemporalElementaryDataItem meta$$timestamp3a = new TemporalElementaryDataItem(Visibility.DEFAULT, true, "timestamp3a", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "Calendar", false, 0, true);
    protected static final TemporalElementaryDataItem meta$$timestamp4a = new TemporalElementaryDataItem(Visibility.DEFAULT, true, "timestamp4a", Multiplicity.SCALAR, 0, 0, 0, DataCategory.TEMPORAL,
        "Calendar", false, 3, true);
    
    // extended meta data (for the enhanced interface)
    private static final ClassDefinition my$MetaData = new ClassDefinition();
    static {
        my$MetaData.setIsAbstract(false);
        my$MetaData.setIsFinal(false);
        my$MetaData.setName(PARTIALLY_QUALIFIED_CLASS_NAME);
        my$MetaData.setRevision(REVISION);
        my$MetaData.setParent(PARENT);
        my$MetaData.setBundle(BUNDLE);
        my$MetaData.setSerialUID(serialVersionUID);
        my$MetaData.setNumberOfFields(22);
        FieldDefinition [] field$array = new FieldDefinition[22];
        field$array[0] = meta$$raw1;
        field$array[1] = meta$$binary1;
        field$array[2] = meta$$day1;
        field$array[3] = meta$$timestamp1;
        field$array[4] = meta$$timestamp2;
        field$array[5] = meta$$timestamp3;
        field$array[6] = meta$$timestamp4;
        field$array[7] = meta$$ascii1;
        field$array[8] = meta$$unicode1;
        field$array[9] = meta$$number1;
        field$array[10] = meta$$decimal1;
        field$array[11] = meta$$color1;
        field$array[12] = meta$$color2;
        field$array[13] = meta$$varEnum1;
        field$array[14] = meta$$varEnum2;
        field$array[15] = meta$$myUuid;
        field$array[16] = meta$$countryCode;
        field$array[17] = meta$$languageCode;
        field$array[18] = meta$$timestamp1a;
        field$array[19] = meta$$timestamp2a;
        field$array[20] = meta$$timestamp3a;
        field$array[21] = meta$$timestamp4a;
        my$MetaData.setFields(field$array);
        my$MetaData.setPropertiesInherited(false);
        my$MetaData.setWhenLoaded(new LocalDateTime());
    };
    
    // get all the meta data in one go
    static public ClassDefinition class$MetaData() {
        return my$MetaData;
    }
    
    // some methods intentionally use the $ sign, because use in normal code is discouraged, so we expect
    // no namespace conflicts here
    // must be repeated as a member method to make it available in the (extended) interface
    // feature of extended BonaPortable, not in the core interface
    @Override
    public ClassDefinition get$MetaData() {
        return my$MetaData;
    }
    
    // convenience functions for faster access if the metadata structure is not used
    @Override
    public String get$PQON() {
        return PARTIALLY_QUALIFIED_CLASS_NAME;
    }
    @Override
    public String get$Revision() {
        return REVISION;
    }
    @Override
    public String get$Parent() {
        return PARENT;
    }
    @Override
    public String get$Bundle() {
        return BUNDLE;
    }
    @Override
    public long get$Serial() {
        return serialVersionUID;
    }
    private static final int MY_RTTI = 0;
    public static int class$rtti() {
        return MY_RTTI;
    }
    public int get$rtti() {
        return MY_RTTI;
    }
    // fields as defined in DSL
    byte [] raw1;
    ByteArray binary1;
    LocalDate day1;
    LocalDateTime timestamp1;
    LocalDateTime timestamp2;
    Calendar timestamp3;
    Calendar timestamp4;
    String ascii1;
    String unicode1;
    Integer number1;
    BigDecimal decimal1;
    Color color1;
    AlphaColor color2;
    VariableLength varEnum1;
    VariableLengthUnicode varEnum2;
    UUID myUuid;
    String countryCode;
    String languageCode;
    LocalDateTime timestamp1a;
    LocalDateTime timestamp2a;
    Calendar timestamp3a;
    Calendar timestamp4a;
    // auto-generated getters and setters
    public byte [] getRaw1() {
        return raw1;
    }
    public void setRaw1(byte [] raw1) {
        this.raw1 = raw1;
    }
    public ByteArray getBinary1() {
        return binary1;
    }
    public void setBinary1(ByteArray binary1) {
        this.binary1 = binary1;
    }
    public LocalDate getDay1() {
        return day1;
    }
    public void setDay1(LocalDate day1) {
        this.day1 = day1;
    }
    public LocalDateTime getTimestamp1() {
        return timestamp1;
    }
    public void setTimestamp1(LocalDateTime timestamp1) {
        this.timestamp1 = timestamp1;
    }
    public LocalDateTime getTimestamp2() {
        return timestamp2;
    }
    public void setTimestamp2(LocalDateTime timestamp2) {
        this.timestamp2 = timestamp2;
    }
    public Calendar getTimestamp3() {
        return timestamp3;
    }
    public void setTimestamp3(Calendar timestamp3) {
        this.timestamp3 = timestamp3;
    }
    public Calendar getTimestamp4() {
        return timestamp4;
    }
    public void setTimestamp4(Calendar timestamp4) {
        this.timestamp4 = timestamp4;
    }
    public String getAscii1() {
        return ascii1;
    }
    public void setAscii1(String ascii1) {
        this.ascii1 = ascii1;
    }
    public String getUnicode1() {
        return unicode1;
    }
    public void setUnicode1(String unicode1) {
        this.unicode1 = unicode1;
    }
    public Integer getNumber1() {
        return number1;
    }
    public void setNumber1(Integer number1) {
        this.number1 = number1;
    }
    public BigDecimal getDecimal1() {
        return decimal1;
    }
    public void setDecimal1(BigDecimal decimal1) {
        this.decimal1 = decimal1;
    }
    public Color getColor1() {
        return color1;
    }
    public void setColor1(Color color1) {
        this.color1 = color1;
    }
    public AlphaColor getColor2() {
        return color2;
    }
    public void setColor2(AlphaColor color2) {
        this.color2 = color2;
    }
    public VariableLength getVarEnum1() {
        return varEnum1;
    }
    public void setVarEnum1(VariableLength varEnum1) {
        this.varEnum1 = varEnum1;
    }
    public VariableLengthUnicode getVarEnum2() {
        return varEnum2;
    }
    public void setVarEnum2(VariableLengthUnicode varEnum2) {
        this.varEnum2 = varEnum2;
    }
    public UUID getMyUuid() {
        return myUuid;
    }
    public void setMyUuid(UUID myUuid) {
        this.myUuid = myUuid;
    }
    public String getCountryCode() {
        return countryCode;
    }
    public void setCountryCode(String countryCode) {
        this.countryCode = countryCode;
    }
    public String getLanguageCode() {
        return languageCode;
    }
    public void setLanguageCode(String languageCode) {
        this.languageCode = languageCode;
    }
    public LocalDateTime getTimestamp1a() {
        return timestamp1a;
    }
    public void setTimestamp1a(LocalDateTime timestamp1a) {
        this.timestamp1a = timestamp1a;
    }
    public LocalDateTime getTimestamp2a() {
        return timestamp2a;
    }
    public void setTimestamp2a(LocalDateTime timestamp2a) {
        this.timestamp2a = timestamp2a;
    }
    public Calendar getTimestamp3a() {
        return timestamp3a;
    }
    public void setTimestamp3a(Calendar timestamp3a) {
        this.timestamp3a = timestamp3a;
    }
    public Calendar getTimestamp4a() {
        return timestamp4a;
    }
    public void setTimestamp4a(Calendar timestamp4a) {
        this.timestamp4a = timestamp4a;
    }
    private static final Pattern regexp$languageCode = Pattern.compile("\\A[a-z][a-z](_[A-Z][A-Z])?\\z");
    /* serialize the object into a String. uses implicit toString() member functions of elementary data types */
    @Override
    public <E extends Exception> void serializeSub(MessageComposer<E> w) throws E {
        w.addField(meta$$raw1, raw1);
        w.addField(meta$$binary1, binary1);
        w.addField(meta$$day1, day1);
        w.addField(meta$$timestamp1, timestamp1);
        w.addField(meta$$timestamp2, timestamp2);
        w.addField(meta$$timestamp3, timestamp3);
        w.addField(meta$$timestamp4, timestamp4);
        w.addField(meta$$ascii1, ascii1);
        w.addField(meta$$unicode1, unicode1);
        w.addField(meta$$number1, number1);
        w.addField(meta$$decimal1, decimal1);
        w.addField(meta$$color1$token, color1 == null ? null : Integer.valueOf(color1.ordinal()));
        w.addField(meta$$color2$token, color2 == null ? null : color2.getToken());
        w.addField(meta$$varEnum1$token, varEnum1 == null ? null : varEnum1.getToken());
        w.addField(meta$$varEnum2$token, varEnum2 == null ? null : varEnum2.getToken());
        w.addField(meta$$myUuid, myUuid);
        w.addField(meta$$countryCode, countryCode);
        w.addField(meta$$languageCode, languageCode);
        w.addField(meta$$timestamp1a, timestamp1a);
        w.addField(meta$$timestamp2a, timestamp2a);
        w.addField(meta$$timestamp3a, timestamp3a);
        w.addField(meta$$timestamp4a, timestamp4a);
        w.writeSuperclassSeparator();
    }
    
    /* serialize selected fields of the object. */
    @Override
    public <E extends Exception> void foldedOutput(MessageComposer<E> w, ParsedFoldingComponent pfc) throws E {
        String _n = pfc.getFieldname();
        if (_n.equals("raw1")) {
            w.addField(meta$$raw1, raw1);
            return;
        }
        if (_n.equals("binary1")) {
            w.addField(meta$$binary1, binary1);
            return;
        }
        if (_n.equals("day1")) {
            w.addField(meta$$day1, day1);
            return;
        }
        if (_n.equals("timestamp1")) {
            w.addField(meta$$timestamp1, timestamp1);
            return;
        }
        if (_n.equals("timestamp2")) {
            w.addField(meta$$timestamp2, timestamp2);
            return;
        }
        if (_n.equals("timestamp3")) {
            w.addField(meta$$timestamp3, timestamp3);
            return;
        }
        if (_n.equals("timestamp4")) {
            w.addField(meta$$timestamp4, timestamp4);
            return;
        }
        if (_n.equals("ascii1")) {
            w.addField(meta$$ascii1, ascii1);
            return;
        }
        if (_n.equals("unicode1")) {
            w.addField(meta$$unicode1, unicode1);
            return;
        }
        if (_n.equals("number1")) {
            w.addField(meta$$number1, number1);
            return;
        }
        if (_n.equals("decimal1")) {
            w.addField(meta$$decimal1, decimal1);
            return;
        }
        if (_n.equals("color1")) {
            w.addField(meta$$color1$token, color1 == null ? null : Integer.valueOf(color1.ordinal()));
            return;
        }
        if (_n.equals("color2")) {
            w.addField(meta$$color2$token, color2 == null ? null : color2.getToken());
            return;
        }
        if (_n.equals("varEnum1")) {
            w.addField(meta$$varEnum1$token, varEnum1 == null ? null : varEnum1.getToken());
            return;
        }
        if (_n.equals("varEnum2")) {
            w.addField(meta$$varEnum2$token, varEnum2 == null ? null : varEnum2.getToken());
            return;
        }
        if (_n.equals("myUuid")) {
            w.addField(meta$$myUuid, myUuid);
            return;
        }
        if (_n.equals("countryCode")) {
            w.addField(meta$$countryCode, countryCode);
            return;
        }
        if (_n.equals("languageCode")) {
            w.addField(meta$$languageCode, languageCode);
            return;
        }
        if (_n.equals("timestamp1a")) {
            w.addField(meta$$timestamp1a, timestamp1a);
            return;
        }
        if (_n.equals("timestamp2a")) {
            w.addField(meta$$timestamp2a, timestamp2a);
            return;
        }
        if (_n.equals("timestamp3a")) {
            w.addField(meta$$timestamp3a, timestamp3a);
            return;
        }
        if (_n.equals("timestamp4a")) {
            w.addField(meta$$timestamp4a, timestamp4a);
            return;
        }
        // not found
    }
    
    @Override
    public <E extends Exception> void deserialize(MessageParser<E> p) throws E {
    //public void deserialize(MessageParser p) throws MessageParserException {
        int _length;
        // String embeddingObject = p.setCurrentClass(getPartiallyQualifiedClassName); // backup for the class name currently parsed
        p.setClassName(PARTIALLY_QUALIFIED_CLASS_NAME);  // just for debug info
        raw1 = p.readRaw       ("raw1", false, 1000000);
        binary1 = p.readByteArray ("binary1", false, 1000000);
        day1 = p.readDay("day1", false);
        timestamp1 = p.readDayTime("timestamp1", false, false, 0);
        timestamp2 = p.readDayTime("timestamp2", false, false, 3);
        timestamp3 = p.readCalendar  ("timestamp3", false, false, 0);
        timestamp4 = p.readCalendar  ("timestamp4", false, false, 3);
        ascii1 = p.readString    ("ascii1", false, 30, false, false, false, false);
        unicode1 = p.readString    ("unicode1", false, 30, false, false, true, true);
        number1 = p.readNumber    ("number1", false, 4, true);
        decimal1 = p.readBigDecimal("decimal1", false, 14, 2, true, false, false);
        try {  // for possible EnumExceptions
        color1 = de.jpaw.bonaparte.pojos.tests1.Color.valueOf(p.readInteger("color1", false, false));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        try {  // for possible EnumExceptions
        color2 = de.jpaw.bonaparte.pojos.tests1.AlphaColor.factory(p.readString("color2", false, 1, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        try {  // for possible EnumExceptions
        varEnum1 = de.jpaw.bonaparte.pojos.tests1.VariableLength.factory(p.readString("varEnum1", false, 19, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        try {  // for possible EnumExceptions
        varEnum2 = de.jpaw.bonaparte.pojos.tests1.VariableLengthUnicode.factory(p.readString("varEnum2", false, 4, true, false, false, true));
        } catch (EnumException e) {
            // convert type of exception to the only one allowed (as indiated by interface generics parameter). Enrich with additional data useful to locate the error, if exception type allows.
            throw p.enumExceptionConverter(e);
        }
        myUuid = p.readUUID      ("myUuid", false);
        countryCode = p.readString    ("countryCode", false, 2, false, false, false, false);
        languageCode = p.readString    ("languageCode", true, 5, false, false, false, false);
        timestamp1a = p.readDayTime("timestamp1a", false, true, 0);
        timestamp2a = p.readDayTime("timestamp2a", false, true, 3);
        timestamp3a = p.readCalendar  ("timestamp3a", false, true, 0);
        timestamp4a = p.readCalendar  ("timestamp4a", false, true, 3);
        p.eatParentSeparator();
        // p.setCurrentClass(embeddingObject); // ignore result
    }
    @Override
    public void validate() throws ObjectValidationException {
        // perform checks for required fields
        if (raw1 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "raw1", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (binary1 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "binary1", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (day1 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "day1", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (timestamp1 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "timestamp1", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (timestamp2 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "timestamp2", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (timestamp3 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "timestamp3", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (timestamp4 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "timestamp4", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (ascii1 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "ascii1", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (unicode1 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "unicode1", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (number1 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "number1", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (decimal1 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "decimal1", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (color1 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "color1", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (color2 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "color2", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (varEnum1 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "varEnum1", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (varEnum2 == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "varEnum2", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (myUuid == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "myUuid", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (countryCode == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "countryCode", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (timestamp1a == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "timestamp1a", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (timestamp2a == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "timestamp2a", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (timestamp3a == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "timestamp3a", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (timestamp4a == null)
            throw new ObjectValidationException(ObjectValidationException.MAY_NOT_BE_BLANK,
                                        "timestamp4a", PARTIALLY_QUALIFIED_CLASS_NAME);
        if (ascii1 != null) {
            if (ascii1.length() > 30)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "ascii1.length=" + ascii1.length() + " > 30",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (unicode1 != null) {
            if (unicode1.length() > 30)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "unicode1.length=" + unicode1.length() + " > 30",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (countryCode != null) {
            if (countryCode.length() > 2)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "countryCode.length=" + countryCode.length() + " > 2",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
            if (countryCode.length() < 2)
                throw new ObjectValidationException(ObjectValidationException.TOO_SHORT,
                                                    "countryCode.length=" + countryCode.length() + " < 2",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (countryCode != null) {
            if (!CharTestsASCII.isUpperCase(countryCode))
                throw new ObjectValidationException(ObjectValidationException.NO_PATTERN_MATCH,
                                                    "countryCode", PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (languageCode != null) {
            if (languageCode.length() > 5)
                throw new ObjectValidationException(ObjectValidationException.TOO_LONG,
                                                    "languageCode.length=" + languageCode.length() + " > 5",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
            if (languageCode.length() < 2)
                throw new ObjectValidationException(ObjectValidationException.TOO_SHORT,
                                                    "languageCode.length=" + languageCode.length() + " < 2",
                                                    PARTIALLY_QUALIFIED_CLASS_NAME);
        }
        if (languageCode != null) {
            Matcher _m =  regexp$languageCode.matcher(languageCode);
            if (!_m.find())
                throw new ObjectValidationException(ObjectValidationException.NO_PATTERN_MATCH,
                                                    "languageCode", PARTIALLY_QUALIFIED_CLASS_NAME);
        }
    }
    @Override
    public int hashCode() {
        int _hash = 997;
        _hash = 29 * _hash + (raw1 == null ? 0 : Arrays.hashCode(raw1));
        _hash = 29 * _hash + (binary1 == null ? 0 : binary1.hashCode());
        _hash = 29 * _hash + (day1 == null ? 0 : day1.hashCode());
        _hash = 29 * _hash + (timestamp1 == null ? 0 : timestamp1.hashCode());
        _hash = 29 * _hash + (timestamp2 == null ? 0 : timestamp2.hashCode());
        _hash = 29 * _hash + (timestamp3 == null ? 0 : timestamp3.hashCode());
        _hash = 29 * _hash + (timestamp4 == null ? 0 : timestamp4.hashCode());
        _hash = 29 * _hash + (ascii1 == null ? 0 : ascii1.hashCode());
        _hash = 29 * _hash + (unicode1 == null ? 0 : unicode1.hashCode());
        _hash = 29 * _hash + (number1 == null ? 0 : number1.hashCode());
        _hash = 29 * _hash + BigDecimalTools.hashCode(decimal1, 2);
        _hash = 29 * _hash + (color1 == null ? 0 : color1.hashCode());
        _hash = 29 * _hash + (color2 == null ? 0 : color2.hashCode());
        _hash = 29 * _hash + (varEnum1 == null ? 0 : varEnum1.hashCode());
        _hash = 29 * _hash + (varEnum2 == null ? 0 : varEnum2.hashCode());
        _hash = 29 * _hash + (myUuid == null ? 0 : myUuid.hashCode());
        _hash = 29 * _hash + (countryCode == null ? 0 : countryCode.hashCode());
        _hash = 29 * _hash + (languageCode == null ? 0 : languageCode.hashCode());
        _hash = 29 * _hash + (timestamp1a == null ? 0 : timestamp1a.hashCode());
        _hash = 29 * _hash + (timestamp2a == null ? 0 : timestamp2a.hashCode());
        _hash = 29 * _hash + (timestamp3a == null ? 0 : timestamp3a.hashCode());
        _hash = 29 * _hash + (timestamp4a == null ? 0 : timestamp4a.hashCode());
        return _hash;
    }
    
    // see http://www.artima.com/lejava/articles/equality.html for all the pitfalls with equals()...
    @Override
    public boolean equals(Object _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof OtherTypes))
            return false;
        if (this == _that)
            return true;
        return equalsSub((BonaPortable)_that);
    }
    
    // same function, but with second argument of (almost) known type
    @Override
    public boolean hasSameContentsAs(BonaPortable _that) {
        if (_that == null)
            return false;
        if (!(_that instanceof OtherTypes))
            return false;
        if (this == _that)
            return true;
        return equalsSub(_that);
    }
    
    protected boolean equalsSub(BonaPortable _that) {
        OtherTypes that = (OtherTypes)_that;
        return true
        && ((raw1 == null && that.raw1 == null) || (raw1 != null && Arrays.equals(raw1, that.raw1)))
        && ((binary1 == null && that.binary1 == null) || (binary1 != null && binary1.contentEquals(that.binary1)))
        && ((day1 == null && that.day1 == null) || (day1 != null && day1.equals(that.day1)))
        && ((timestamp1 == null && that.timestamp1 == null) || (timestamp1 != null && timestamp1.equals(that.timestamp1)))
        && ((timestamp2 == null && that.timestamp2 == null) || (timestamp2 != null && timestamp2.equals(that.timestamp2)))
        && ((timestamp3 == null && that.timestamp3 == null) || (timestamp3 != null && timestamp3.compareTo(that.timestamp3) == 0))
        && ((timestamp4 == null && that.timestamp4 == null) || (timestamp4 != null && timestamp4.compareTo(that.timestamp4) == 0))
        && ((ascii1 == null && that.ascii1 == null) || (ascii1 != null && ascii1.equals(that.ascii1)))
        && ((unicode1 == null && that.unicode1 == null) || (unicode1 != null && unicode1.equals(that.unicode1)))
        && ((number1 == null && that.number1 == null) || (number1 != null && number1.equals(that.number1)))
        && ((decimal1 == null && that.decimal1 == null) || (decimal1 != null && BigDecimalTools.equals(decimal1, 2, that.decimal1, 2)))
        && ((color1 == null && that.color1 == null) || (color1 != null && color1.equals(that.color1)))
        && ((color2 == null && that.color2 == null) || (color2 != null && color2.equals(that.color2)))
        && ((varEnum1 == null && that.varEnum1 == null) || (varEnum1 != null && varEnum1.equals(that.varEnum1)))
        && ((varEnum2 == null && that.varEnum2 == null) || (varEnum2 != null && varEnum2.equals(that.varEnum2)))
        && ((myUuid == null && that.myUuid == null) || (myUuid != null && myUuid.equals(that.myUuid)))
        && ((countryCode == null && that.countryCode == null) || (countryCode != null && countryCode.equals(that.countryCode)))
        && ((languageCode == null && that.languageCode == null) || (languageCode != null && languageCode.equals(that.languageCode)))
        && ((timestamp1a == null && that.timestamp1a == null) || (timestamp1a != null && timestamp1a.equals(that.timestamp1a)))
        && ((timestamp2a == null && that.timestamp2a == null) || (timestamp2a != null && timestamp2a.equals(that.timestamp2a)))
        && ((timestamp3a == null && that.timestamp3a == null) || (timestamp3a != null && timestamp3a.compareTo(that.timestamp3a) == 0))
        && ((timestamp4a == null && that.timestamp4a == null) || (timestamp4a != null && timestamp4a.compareTo(that.timestamp4a) == 0))
        ;
    }
    @Override
    public void writeExternal(ObjectOutput _out) throws IOException {
        serializeSub(new ExternalizableComposer(_out));
    }
    
    @Override
    public void readExternal(ObjectInput _in) throws IOException,
            ClassNotFoundException {
        deserialize(new ExternalizableParser(_in));
    }
    @Override
    public void treeWalkString(StringConverter _cvt) {
        ascii1 = _cvt.convert(ascii1, meta$$ascii1);
        unicode1 = _cvt.convert(unicode1, meta$$unicode1);
        countryCode = _cvt.convert(countryCode, meta$$countryCode);
        languageCode = _cvt.convert(languageCode, meta$$languageCode);
    }
    // default no-argument constructor
    public OtherTypes() {
    }
    
    // default all-arguments constructor
    public OtherTypes(byte [] raw1
    , ByteArray binary1
    , LocalDate day1
    , LocalDateTime timestamp1
    , LocalDateTime timestamp2
    , Calendar timestamp3
    , Calendar timestamp4
    , String ascii1
    , String unicode1
    , Integer number1
    , BigDecimal decimal1
    , Color color1
    , AlphaColor color2
    , VariableLength varEnum1
    , VariableLengthUnicode varEnum2
    , UUID myUuid
    , String countryCode
    , String languageCode
    , LocalDateTime timestamp1a
    , LocalDateTime timestamp2a
    , Calendar timestamp3a
    , Calendar timestamp4a
    ) {
        this.raw1 = raw1;
        this.binary1 = binary1;
        this.day1 = day1;
        this.timestamp1 = timestamp1;
        this.timestamp2 = timestamp2;
        this.timestamp3 = timestamp3;
        this.timestamp4 = timestamp4;
        this.ascii1 = ascii1;
        this.unicode1 = unicode1;
        this.number1 = number1;
        this.decimal1 = decimal1;
        this.color1 = color1;
        this.color2 = color2;
        this.varEnum1 = varEnum1;
        this.varEnum2 = varEnum2;
        this.myUuid = myUuid;
        this.countryCode = countryCode;
        this.languageCode = languageCode;
        this.timestamp1a = timestamp1a;
        this.timestamp2a = timestamp2a;
        this.timestamp3a = timestamp3a;
        this.timestamp4a = timestamp4a;
    }
    
    // copyOf clone method
    @Override
    public <T extends BonaPortable> T copyAs(Class<T> desiredSuperType) {
        if (desiredSuperType == null || desiredSuperType == OtherTypes.class) {
            return (T) new OtherTypes(getRaw1(), getBinary1(), getDay1(), getTimestamp1(), getTimestamp2(), getTimestamp3(), getTimestamp4(), getAscii1(), getUnicode1(), getNumber1(), getDecimal1(), getColor1(), getColor2(), getVarEnum1(), getVarEnum2(), getMyUuid(), getCountryCode(), getLanguageCode(), getTimestamp1a(), getTimestamp2a(), getTimestamp3a(), getTimestamp4a());
        }
        throw new IllegalArgumentException("OtherTypes does not support copyOf(" + desiredSuperType.getCanonicalName() + ")");
    }

    @Override
    public String toString() {
        return ToStringHelper.toStringSL(this);
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/tests1/VariableLength.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.tests1;

import de.jpaw.util.EnumException;
import de.jpaw.enums.TokenizableEnum;


public enum VariableLength implements TokenizableEnum {
    ONE("1"), NULL(""), LONG("This is a long text");

    // constructor by token
    private String _token;
    private VariableLength(String _token) {
        this._token = _token;
    }

    // token retrieval
    @Override
    public String getToken() {
        return _token;
    }

    // static factory method.
    public static VariableLength factory(String _token) throws EnumException {
        if (_token != null) {
            if (_token.equals("1")) return ONE;
            if (_token.equals("")) return NULL;
            if (_token.equals("This is a long text")) return LONG;
            throw new EnumException(EnumException.INVALID_NUM, _token);
        }
        return null;
    }

    public static VariableLength valueOf(Integer ordinal) throws EnumException {
        if (ordinal != null) {
            switch (ordinal.intValue()) {
            case 0: return ONE;
            case 1: return NULL;
            case 2: return LONG;
            default: throw new EnumException(EnumException.INVALID_NUM, ordinal.toString());
            }
        }
        return null;
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/tests1/VariableLengthUnicode.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git
package de.jpaw.bonaparte.pojos.tests1;

import de.jpaw.util.EnumException;
import de.jpaw.enums.TokenizableEnum;


public enum VariableLengthUnicode implements TokenizableEnum {
    UMLAUT("Jäh!"), EURO("€");

    // constructor by token
    private String _token;
    private VariableLengthUnicode(String _token) {
        this._token = _token;
    }

    // token retrieval
    @Override
    public String getToken() {
        return _token;
    }

    // static factory method.
    public static VariableLengthUnicode factory(String _token) throws EnumException {
        if (_token != null) {
            if (_token.equals("Jäh!")) return UMLAUT;
            if (_token.equals("€")) return EURO;
            throw new EnumException(EnumException.INVALID_NUM, _token);
        }
        return null;
    }

    public static VariableLengthUnicode valueOf(Integer ordinal) throws EnumException {
        if (ordinal != null) {
            switch (ordinal.intValue()) {
            case 0: return UMLAUT;
            case 1: return EURO;
            default: throw new EnumException(EnumException.INVALID_NUM, ordinal.toString());
            }
        }
        return null;
    }
}
, DEFAULT_OUTPUTjava/de/jpaw/bonaparte/pojos/tests1/package-info.java=// This source has been automatically created by the bonaparte DSL. Do not modify, changes will be lost.
// The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
// The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

package de.jpaw.bonaparte.pojos.tests1;
, DEFAULT_OUTPUTresources/persistence/def.txt=, DEFAULT_OUTPUTresources/persistence/eec.test.txt=eec.test.ParentEntity
eec.test.ItemEntity
, DEFAULT_OUTPUTresources/persistence/embedTest.txt=embedTest.PersonEntity
, DEFAULT_OUTPUTresources/persistence/examples.pkey.entities.txt=examples.pkey.entities.NoPkEntity
examples.pkey.entities.OneFieldPkEntity
examples.pkey.entities.MultiFieldPkEntity
examples.pkey.entities.EmbeddedPkEntity
examples.pkey.entities.IdClassPkEntity
, DEFAULT_OUTPUTresources/persistence/persistencetest.txt=persistencetest.BoxedTypesEntity
persistencetest.OtherTypesEntity
persistencetest.MissingPKEntity
persistencetest.MissingPKEntity2
, DEFAULT_OUTPUTresources/persistence/relations.test.txt=relations.test.ParentEntity
relations.test.ItemEntity
relations.test.TestEntity
, DEFAULT_OUTPUTsql/MSSQLSERVER/Table/jp_cfg_person.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE jp_cfg_person (
    -- table columns of java class Tracking
      user_id varchar(8)
    -- table columns of java class Person
    , person_key bigint NOT NULL
    , name nvarchar(20)
    , home_street nvarchar(20)
    , home_zip_code varchar(10)
    , home_city nvarchar(30)
    , street_work nvarchar(20)
    , zip_code_work varchar(10)
    , city_work nvarchar(30)
    , ex_street_tra nvarchar(20)
    , ex_zip_code_tra varchar(10)
    , ex_city_tra nvarchar(30)
    , address_lines01 nvarchar(80)
    , address_lines02 nvarchar(80)
    , address_lines03 nvarchar(80)
    , streetx001 nvarchar(20)
    , zip_codex001 varchar(10)
    , cityx001 nvarchar(30)
    , streetx002 nvarchar(20)
    , zip_codex002 varchar(10)
    , cityx002 nvarchar(30)
    , streetx003 nvarchar(20)
    , zip_codex003 varchar(10)
    , cityx003 nvarchar(30)
    , my_data1 nvarchar(10)
    , my_props01 nvarchar(10)
    , my_props02 nvarchar(10)
    , my_props03 nvarchar(10)
    , my_props04 nvarchar(10)
);

ALTER TABLE jp_cfg_person ADD CONSTRAINT jp_cfg_person_pk PRIMARY KEY (
    person_key
);
GRANT SELECT ON jp_cfg_person TO jpawro;
GRANT SELECT,INSERT,UPDATE,DELETE ON jp_cfg_person TO jpawrw;

, DEFAULT_OUTPUTsql/MSSQLSERVER/Table/test_boxed_types_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE test_boxed_types_entity (
    -- table columns of java class BoxedTypes
      byte1 tinyint
    , short1 smallint
    , int1 int NOT NULL
    , int2 int
    , long1 bigint
    , boolean1 bit
    , float1 float
    , double1 double
    , char1 char(1)
    , char2 char(1)
);

ALTER TABLE test_boxed_types_entity ADD CONSTRAINT test_boxed_types_entity_pk PRIMARY KEY (
    int1
);
GRANT SELECT,INSERT,UPDATE,DELETE ON test_boxed_types_entity TO demorole;

, DEFAULT_OUTPUTsql/MSSQLSERVER/Table/test_missing_p_k_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE test_missing_p_k_entity (
    -- table columns of java class BoxedTypes
      byte1 tinyint
    , short1 smallint
    , int1 int
    , int2 int
    , long1 bigint
    , boolean1 bit
    , float1 float
    , double1 double
    , char1 char(1)
    , char2 char(1)
);

GRANT SELECT,INSERT,UPDATE,DELETE ON test_missing_p_k_entity TO demorole;

, DEFAULT_OUTPUTsql/MSSQLSERVER/Table/test_missing_p_k_entity2.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE test_missing_p_k_entity2 (
    -- table columns of java class BoxedTypes
      byte1 tinyint
    , short1 smallint
    , int1 int NOT NULL
    , int2 int
    , long1 bigint
    , boolean1 bit
    , float1 float
    , double1 double
    , char1 char(1)
    , char2 char(1)
);

ALTER TABLE test_missing_p_k_entity2 ADD CONSTRAINT test_missing_p_k_entity2_pk PRIMARY KEY (
    int1
);
GRANT SELECT,INSERT,UPDATE,DELETE ON test_missing_p_k_entity2 TO demorole;

, DEFAULT_OUTPUTsql/MSSQLSERVER/Table/test_other_types_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE test_other_types_entity (
    -- table columns of java class OtherTypes
      raw1 varbinary(MAX) NOT NULL
    , binary1 varbinary(MAX) NOT NULL
    , day1 date NOT NULL
    , timestamp1 datetime2(0) NOT NULL
    , timestamp2 datetime2(3) NOT NULL
    , timestamp3 datetime2(0) NOT NULL
    , timestamp4 datetime2(3) NOT NULL
    , ascii1 varchar(30) NOT NULL
    , unicode1 nvarchar(30) NOT NULL
    , number1 decimal(4) NOT NULL
    , decimal1 decimal(14,2) NOT NULL
    , color1 smallint NOT NULL
    , color2 nvarchar(1) NOT NULL
    , var_enum1 nvarchar(19) NOT NULL
    , var_enum2 nvarchar(4) NOT NULL
    , my_uuid varbinary(16) NOT NULL
    , country_code varchar(2) NOT NULL
    , language_code varchar(5)
    , timestamp1a datetime2(0) NOT NULL
    , timestamp2a datetime2(3) NOT NULL
    , timestamp3a datetime2(0) NOT NULL
    , timestamp4a datetime2(3) NOT NULL
);

ALTER TABLE test_other_types_entity ADD CONSTRAINT test_other_types_entity_pk PRIMARY KEY (
    number1
);
GRANT SELECT,INSERT,UPDATE,DELETE ON test_other_types_entity TO demorole;

, DEFAULT_OUTPUTsql/MSSQLSERVER/Table/tests_embedded_pk_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_embedded_pk_entity (
    -- table columns of java class EDto
      key1 varchar(8)
    , key2 int
    , data varchar(80)
);

ALTER TABLE tests_embedded_pk_entity ADD CONSTRAINT tests_embedded_pk_entity_pk PRIMARY KEY (
    key1, key2
);
GRANT SELECT,INSERT,UPDATE,DELETE ON tests_embedded_pk_entity TO demorole;

, DEFAULT_OUTPUTsql/MSSQLSERVER/Table/tests_id_class_pk_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_id_class_pk_entity (
    -- table columns of java class EDto2
      key1 varchar(8) NOT NULL
    , key2 int NOT NULL
    , data varchar(80)
);

ALTER TABLE tests_id_class_pk_entity ADD CONSTRAINT tests_id_class_pk_entity_pk PRIMARY KEY (
    key1, key2
);
GRANT SELECT,INSERT,UPDATE,DELETE ON tests_id_class_pk_entity TO demorole;

, DEFAULT_OUTPUTsql/MSSQLSERVER/Table/tests_item_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_item_entity (
    -- table columns of java class Item
      dummy_ref bigint NOT NULL
    , item_no int NOT NULL
    , item_text nvarchar(80)
);

ALTER TABLE tests_item_entity ADD CONSTRAINT tests_item_entity_pk PRIMARY KEY (
    dummy_ref, item_no
);
GRANT SELECT,INSERT,UPDATE,DELETE ON tests_item_entity TO demorole;

, DEFAULT_OUTPUTsql/MSSQLSERVER/Table/tests_multi_field_pk_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_multi_field_pk_entity (
    -- table columns of java class EDto2
      key1 varchar(8) NOT NULL
    , key2 int NOT NULL
    , data varchar(80)
);

ALTER TABLE tests_multi_field_pk_entity ADD CONSTRAINT tests_multi_field_pk_entity_pk PRIMARY KEY (
    key1, key2
);
GRANT SELECT,INSERT,UPDATE,DELETE ON tests_multi_field_pk_entity TO demorole;

, DEFAULT_OUTPUTsql/MSSQLSERVER/Table/tests_no_pk_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_no_pk_entity (
    -- table columns of java class EDto
      my_composite_key bigint
    , data varchar(80)
);

GRANT SELECT,INSERT,UPDATE,DELETE ON tests_no_pk_entity TO demorole;

, DEFAULT_OUTPUTsql/MSSQLSERVER/Table/tests_one_field_pk_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_one_field_pk_entity (
    -- table columns of java class EDto
      my_composite_key bigint
    , data varchar(80) NOT NULL
);

ALTER TABLE tests_one_field_pk_entity ADD CONSTRAINT tests_one_field_pk_entity_pk PRIMARY KEY (
    data
);
GRANT SELECT,INSERT,UPDATE,DELETE ON tests_one_field_pk_entity TO demorole;

, DEFAULT_OUTPUTsql/MSSQLSERVER/Table/tests_parent_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_parent_entity (
    -- table columns of java class Parent
      key bigint NOT NULL
    , text nvarchar(80)
);

ALTER TABLE tests_parent_entity ADD CONSTRAINT tests_parent_entity_pk PRIMARY KEY (
    key
);
GRANT SELECT,INSERT,UPDATE,DELETE ON tests_parent_entity TO demorole;

, DEFAULT_OUTPUTsql/MSSQLSERVER/Table/tests_test_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_test_entity (
    -- table columns of java class TestObject
      my_key bigint NOT NULL
    , parent_ref bigint NOT NULL
    , name nvarchar(80)
);

ALTER TABLE tests_test_entity ADD CONSTRAINT tests_test_entity_pk PRIMARY KEY (
    my_key
);
GRANT SELECT,INSERT,UPDATE,DELETE ON tests_test_entity TO demorole;

, DEFAULT_OUTPUTsql/MSSQLSERVER/Table/the_other_table.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE the_other_table (
    -- tenant
    -- base table PK
      my_key bigint NOT NULL
    -- element collection key
    , currency_code nvarchar(255) NOT NULL,
    -- contents field
    , prices decimal(14,2)
);

ALTER TABLE the_other_table ADD CONSTRAINT the_other_table_pk PRIMARY KEY (
    my_key, currency_code
);
, DEFAULT_OUTPUTsql/ORACLE/Synonym/jp_cfg_person.sql=CREATE OR REPLACE PUBLIC SYNONYM jp_cfg_person FOR jp_cfg_person;, DEFAULT_OUTPUTsql/ORACLE/Synonym/test_boxed_types_entity.sql=CREATE OR REPLACE PUBLIC SYNONYM test_boxed_types_entity FOR test_boxed_types_entity;, DEFAULT_OUTPUTsql/ORACLE/Synonym/test_missing_p_k_entity.sql=CREATE OR REPLACE PUBLIC SYNONYM test_missing_p_k_entity FOR test_missing_p_k_entity;, DEFAULT_OUTPUTsql/ORACLE/Synonym/test_missing_p_k_entity2.sql=CREATE OR REPLACE PUBLIC SYNONYM test_missing_p_k_entity2 FOR test_missing_p_k_entity2;, DEFAULT_OUTPUTsql/ORACLE/Synonym/test_other_types_entity.sql=CREATE OR REPLACE PUBLIC SYNONYM test_other_types_entity FOR test_other_types_entity;, DEFAULT_OUTPUTsql/ORACLE/Synonym/tests_embedded_pk_entity.sql=CREATE OR REPLACE PUBLIC SYNONYM tests_embedded_pk_entity FOR tests_embedded_pk_entity;, DEFAULT_OUTPUTsql/ORACLE/Synonym/tests_id_class_pk_entity.sql=CREATE OR REPLACE PUBLIC SYNONYM tests_id_class_pk_entity FOR tests_id_class_pk_entity;, DEFAULT_OUTPUTsql/ORACLE/Synonym/tests_item_entity.sql=CREATE OR REPLACE PUBLIC SYNONYM tests_item_entity FOR tests_item_entity;, DEFAULT_OUTPUTsql/ORACLE/Synonym/tests_multi_field_pk_entity.sql=CREATE OR REPLACE PUBLIC SYNONYM tests_multi_field_pk_entity FOR tests_multi_field_pk_entity;, DEFAULT_OUTPUTsql/ORACLE/Synonym/tests_no_pk_entity.sql=CREATE OR REPLACE PUBLIC SYNONYM tests_no_pk_entity FOR tests_no_pk_entity;, DEFAULT_OUTPUTsql/ORACLE/Synonym/tests_one_field_pk_entity.sql=CREATE OR REPLACE PUBLIC SYNONYM tests_one_field_pk_entity FOR tests_one_field_pk_entity;, DEFAULT_OUTPUTsql/ORACLE/Synonym/tests_parent_entity.sql=CREATE OR REPLACE PUBLIC SYNONYM tests_parent_entity FOR tests_parent_entity;, DEFAULT_OUTPUTsql/ORACLE/Synonym/tests_test_entity.sql=CREATE OR REPLACE PUBLIC SYNONYM tests_test_entity FOR tests_test_entity;, DEFAULT_OUTPUTsql/ORACLE/Synonym/the_other_table.sql=CREATE OR REPLACE PUBLIC SYNONYM the_other_table FOR the_other_table;, DEFAULT_OUTPUTsql/ORACLE/Table/jp_cfg_person.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE jp_cfg_person (
    -- table columns of java class Tracking
      user_id varchar2(8)
    -- table columns of java class Person
    , person_key number(20) NOT NULL
    , name varchar2(20 char)
    , home_street varchar2(20 char)
    , home_zip_code varchar2(10)
    , home_city varchar2(30 char)
    , street_work varchar2(20 char)
    , zip_code_work varchar2(10)
    , city_work varchar2(30 char)
    , ex_street_tra varchar2(20 char)
    , ex_zip_code_tra varchar2(10)
    , ex_city_tra varchar2(30 char)
    , address_lines01 varchar2(80 char)
    , address_lines02 varchar2(80 char)
    , address_lines03 varchar2(80 char)
    , streetx001 varchar2(20 char)
    , zip_codex001 varchar2(10)
    , cityx001 varchar2(30 char)
    , streetx002 varchar2(20 char)
    , zip_codex002 varchar2(10)
    , cityx002 varchar2(30 char)
    , streetx003 varchar2(20 char)
    , zip_codex003 varchar2(10)
    , cityx003 varchar2(30 char)
    , my_data1 varchar2(10 char)
    , my_props01 varchar2(10 char)
    , my_props02 varchar2(10 char)
    , my_props03 varchar2(10 char)
    , my_props04 varchar2(10 char)
) TABLESPACE rts42cfg0D;

ALTER TABLE jp_cfg_person ADD CONSTRAINT jp_cfg_person_pk PRIMARY KEY (
    person_key
) USING INDEX TABLESPACE rts42cfg0I;
GRANT SELECT ON jp_cfg_person TO jpawro;
GRANT SELECT,INSERT,UPDATE,DELETE ON jp_cfg_person TO jpawrw;

-- comments for columns of java class Tracking
-- comments for columns of java class Person
, DEFAULT_OUTPUTsql/ORACLE/Table/test_boxed_types_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE test_boxed_types_entity (
    -- table columns of java class BoxedTypes
      byte1 number(3)
    , short1 number(5)
    , int1 number(10) NOT NULL
    , int2 number(10)
    , long1 number(20)
    , boolean1 number(1)
    , float1 binary_float
    , double1 binary_double
    , char1 varchar2(1 char)
    , char2 varchar2(1 char)
) TABLESPACE system;

ALTER TABLE test_boxed_types_entity ADD CONSTRAINT test_boxed_types_entity_pk PRIMARY KEY (
    int1
) USING INDEX TABLESPACE system;
GRANT SELECT,INSERT,UPDATE,DELETE ON test_boxed_types_entity TO demorole;

-- comments for columns of java class BoxedTypes
, DEFAULT_OUTPUTsql/ORACLE/Table/test_missing_p_k_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE test_missing_p_k_entity (
    -- table columns of java class BoxedTypes
      byte1 number(3)
    , short1 number(5)
    , int1 number(10)
    , int2 number(10)
    , long1 number(20)
    , boolean1 number(1)
    , float1 binary_float
    , double1 binary_double
    , char1 varchar2(1 char)
    , char2 varchar2(1 char)
) TABLESPACE system;

GRANT SELECT,INSERT,UPDATE,DELETE ON test_missing_p_k_entity TO demorole;

-- comments for columns of java class BoxedTypes
, DEFAULT_OUTPUTsql/ORACLE/Table/test_missing_p_k_entity2.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE test_missing_p_k_entity2 (
    -- table columns of java class BoxedTypes
      byte1 number(3)
    , short1 number(5)
    , int1 number(10) NOT NULL
    , int2 number(10)
    , long1 number(20)
    , boolean1 number(1)
    , float1 binary_float
    , double1 binary_double
    , char1 varchar2(1 char)
    , char2 varchar2(1 char)
) TABLESPACE system;

ALTER TABLE test_missing_p_k_entity2 ADD CONSTRAINT test_missing_p_k_entity2_pk PRIMARY KEY (
    int1
) USING INDEX TABLESPACE system;
GRANT SELECT,INSERT,UPDATE,DELETE ON test_missing_p_k_entity2 TO demorole;

-- comments for columns of java class BoxedTypes
, DEFAULT_OUTPUTsql/ORACLE/Table/test_other_types_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE test_other_types_entity (
    -- table columns of java class OtherTypes
      raw1 blob NOT NULL
    , binary1 blob NOT NULL
    , day1 date NOT NULL
    , timestamp1 date NOT NULL
    , timestamp2 timestamp(3) NOT NULL
    , timestamp3 date NOT NULL
    , timestamp4 timestamp(3) NOT NULL
    , ascii1 varchar2(30) NOT NULL
    , unicode1 varchar2(30 char) NOT NULL
    , number1 number(4) NOT NULL
    , decimal1 number(14,2) NOT NULL
    , color1 number(4) NOT NULL
    , color2 varchar2(1) NOT NULL
    , var_enum1 varchar2(19) NOT NULL
    , var_enum2 varchar2(4 char) NOT NULL
    , my_uuid raw(16) NOT NULL
    , country_code varchar2(2) NOT NULL
    , language_code varchar2(5)
    , timestamp1a date NOT NULL
    , timestamp2a timestamp(3) NOT NULL
    , timestamp3a date NOT NULL
    , timestamp4a timestamp(3) NOT NULL
) TABLESPACE system;

ALTER TABLE test_other_types_entity ADD CONSTRAINT test_other_types_entity_pk PRIMARY KEY (
    number1
) USING INDEX TABLESPACE system;
GRANT SELECT,INSERT,UPDATE,DELETE ON test_other_types_entity TO demorole;

-- comments for columns of java class OtherTypes
, DEFAULT_OUTPUTsql/ORACLE/Table/tests_embedded_pk_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_embedded_pk_entity (
    -- table columns of java class EDto
      key1 varchar2(8)
    , key2 number(10)
    , data varchar2(80)
);

ALTER TABLE tests_embedded_pk_entity ADD CONSTRAINT tests_embedded_pk_entity_pk PRIMARY KEY (
    key1, key2
);
GRANT SELECT,INSERT,UPDATE,DELETE ON tests_embedded_pk_entity TO demorole;

-- comments for columns of java class EDto
, DEFAULT_OUTPUTsql/ORACLE/Table/tests_id_class_pk_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_id_class_pk_entity (
    -- table columns of java class EDto2
      key1 varchar2(8) NOT NULL
    , key2 number(10) NOT NULL
    , data varchar2(80)
);

ALTER TABLE tests_id_class_pk_entity ADD CONSTRAINT tests_id_class_pk_entity_pk PRIMARY KEY (
    key1, key2
);
GRANT SELECT,INSERT,UPDATE,DELETE ON tests_id_class_pk_entity TO demorole;

-- comments for columns of java class EDto2
, DEFAULT_OUTPUTsql/ORACLE/Table/tests_item_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_item_entity (
    -- table columns of java class Item
      dummy_ref number(20) NOT NULL
    , item_no number(10) NOT NULL
    , item_text varchar2(80 char)
);

ALTER TABLE tests_item_entity ADD CONSTRAINT tests_item_entity_pk PRIMARY KEY (
    dummy_ref, item_no
);
GRANT SELECT,INSERT,UPDATE,DELETE ON tests_item_entity TO demorole;

-- comments for columns of java class Item
, DEFAULT_OUTPUTsql/ORACLE/Table/tests_multi_field_pk_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_multi_field_pk_entity (
    -- table columns of java class EDto2
      key1 varchar2(8) NOT NULL
    , key2 number(10) NOT NULL
    , data varchar2(80)
);

ALTER TABLE tests_multi_field_pk_entity ADD CONSTRAINT tests_multi_field_pk_entity_pk PRIMARY KEY (
    key1, key2
);
GRANT SELECT,INSERT,UPDATE,DELETE ON tests_multi_field_pk_entity TO demorole;

-- comments for columns of java class EDto2
, DEFAULT_OUTPUTsql/ORACLE/Table/tests_no_pk_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_no_pk_entity (
    -- table columns of java class EDto
      my_composite_key number(20)
    , data varchar2(80)
);

GRANT SELECT,INSERT,UPDATE,DELETE ON tests_no_pk_entity TO demorole;

-- comments for columns of java class EDto
, DEFAULT_OUTPUTsql/ORACLE/Table/tests_one_field_pk_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_one_field_pk_entity (
    -- table columns of java class EDto
      my_composite_key number(20)
    , data varchar2(80) NOT NULL
);

ALTER TABLE tests_one_field_pk_entity ADD CONSTRAINT tests_one_field_pk_entity_pk PRIMARY KEY (
    data
);
GRANT SELECT,INSERT,UPDATE,DELETE ON tests_one_field_pk_entity TO demorole;

-- comments for columns of java class EDto
, DEFAULT_OUTPUTsql/ORACLE/Table/tests_parent_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_parent_entity (
    -- table columns of java class Parent
      key number(20) NOT NULL
    , text varchar2(80 char)
);

ALTER TABLE tests_parent_entity ADD CONSTRAINT tests_parent_entity_pk PRIMARY KEY (
    key
);
GRANT SELECT,INSERT,UPDATE,DELETE ON tests_parent_entity TO demorole;

-- comments for columns of java class Parent
, DEFAULT_OUTPUTsql/ORACLE/Table/tests_test_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_test_entity (
    -- table columns of java class TestObject
      my_key number(20) NOT NULL
    , parent_ref number(20) NOT NULL
    , name varchar2(80 char)
);

ALTER TABLE tests_test_entity ADD CONSTRAINT tests_test_entity_pk PRIMARY KEY (
    my_key
);
GRANT SELECT,INSERT,UPDATE,DELETE ON tests_test_entity TO demorole;

-- comments for columns of java class TestObject
, DEFAULT_OUTPUTsql/ORACLE/Table/the_other_table.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE the_other_table (
    -- tenant
    -- base table PK
      my_key number(20) NOT NULL
    -- element collection key
    , currency_code varchar2(255) NOT NULL,
    -- contents field
    , prices number(14,2)
);

ALTER TABLE the_other_table ADD CONSTRAINT the_other_table_pk PRIMARY KEY (
    my_key, currency_code
);
, DEFAULT_OUTPUTsql/ORACLE/View/jp_cfg_person_nt.sql=CREATE OR REPLACE VIEW jp_cfg_person_nt AS SELECT
    -- columns of java class Person
    t0.person_key AS person_key
    , t0.name AS name
    , t0.home_street AS home_street
    , t0.home_zip_code AS home_zip_code
    , t0.home_city AS home_city
    , t0.street_work AS street_work
    , t0.zip_code_work AS zip_code_work
    , t0.city_work AS city_work
    , t0.ex_street_tra AS ex_street_tra
    , t0.ex_zip_code_tra AS ex_zip_code_tra
    , t0.ex_city_tra AS ex_city_tra
    , t0.address_lines01 AS address_lines01
    , t0.address_lines02 AS address_lines02
    , t0.address_lines03 AS address_lines03
    , t0.streetx001 AS streetx001
    , t0.zip_codex001 AS zip_codex001
    , t0.cityx001 AS cityx001
    , t0.streetx002 AS streetx002
    , t0.zip_codex002 AS zip_codex002
    , t0.cityx002 AS cityx002
    , t0.streetx003 AS streetx003
    , t0.zip_codex003 AS zip_codex003
    , t0.cityx003 AS cityx003
    , t0.my_data1 AS my_data1
    , t0.my_props01 AS my_props01
    , t0.my_props02 AS my_props02
    , t0.my_props03 AS my_props03
    , t0.my_props04 AS my_props04
FROM jp_cfg_person t0;
, DEFAULT_OUTPUTsql/ORACLE/View/jp_cfg_person_v.sql=CREATE OR REPLACE VIEW jp_cfg_person_v AS SELECT
    -- columns of java class Tracking
    t0.user_id AS user_id
    -- columns of java class Person
    , t0.person_key AS person_key
    , t0.name AS name
    , t0.home_street AS home_street
    , t0.home_zip_code AS home_zip_code
    , t0.home_city AS home_city
    , t0.street_work AS street_work
    , t0.zip_code_work AS zip_code_work
    , t0.city_work AS city_work
    , t0.ex_street_tra AS ex_street_tra
    , t0.ex_zip_code_tra AS ex_zip_code_tra
    , t0.ex_city_tra AS ex_city_tra
    , t0.address_lines01 AS address_lines01
    , t0.address_lines02 AS address_lines02
    , t0.address_lines03 AS address_lines03
    , t0.streetx001 AS streetx001
    , t0.zip_codex001 AS zip_codex001
    , t0.cityx001 AS cityx001
    , t0.streetx002 AS streetx002
    , t0.zip_codex002 AS zip_codex002
    , t0.cityx002 AS cityx002
    , t0.streetx003 AS streetx003
    , t0.zip_codex003 AS zip_codex003
    , t0.cityx003 AS cityx003
    , t0.my_data1 AS my_data1
    , t0.my_props01 AS my_props01
    , t0.my_props02 AS my_props02
    , t0.my_props03 AS my_props03
    , t0.my_props04 AS my_props04
FROM jp_cfg_person t0;
, DEFAULT_OUTPUTsql/ORACLE/View/test_boxed_types_entity_nt.sql=CREATE OR REPLACE VIEW test_boxed_types_entity_nt AS SELECT
    -- columns of java class BoxedTypes
    t0.byte1 AS byte1
    , t0.short1 AS short1
    , t0.int1 AS int1
    , t0.int2 AS int2
    , t0.long1 AS long1
    , t0.boolean1 AS boolean1
    , t0.float1 AS float1
    , t0.double1 AS double1
    , t0.char1 AS char1
    , t0.char2 AS char2
FROM test_boxed_types_entity t0;
, DEFAULT_OUTPUTsql/ORACLE/View/test_boxed_types_entity_v.sql=CREATE OR REPLACE VIEW test_boxed_types_entity_v AS SELECT
    -- columns of java class BoxedTypes
    t0.byte1 AS byte1
    , t0.short1 AS short1
    , t0.int1 AS int1
    , t0.int2 AS int2
    , t0.long1 AS long1
    , t0.boolean1 AS boolean1
    , t0.float1 AS float1
    , t0.double1 AS double1
    , t0.char1 AS char1
    , t0.char2 AS char2
FROM test_boxed_types_entity t0;
, DEFAULT_OUTPUTsql/ORACLE/View/test_missing_p_k_entity2_nt.sql=CREATE OR REPLACE VIEW test_missing_p_k_entity2_nt AS SELECT
    -- columns of java class BoxedTypes
    t0.byte1 AS byte1
    , t0.short1 AS short1
    , t0.int1 AS int1
    , t0.int2 AS int2
    , t0.long1 AS long1
    , t0.boolean1 AS boolean1
    , t0.float1 AS float1
    , t0.double1 AS double1
    , t0.char1 AS char1
    , t0.char2 AS char2
FROM test_missing_p_k_entity2 t0;
, DEFAULT_OUTPUTsql/ORACLE/View/test_missing_p_k_entity2_v.sql=CREATE OR REPLACE VIEW test_missing_p_k_entity2_v AS SELECT
    -- columns of java class BoxedTypes
    t0.byte1 AS byte1
    , t0.short1 AS short1
    , t0.int1 AS int1
    , t0.int2 AS int2
    , t0.long1 AS long1
    , t0.boolean1 AS boolean1
    , t0.float1 AS float1
    , t0.double1 AS double1
    , t0.char1 AS char1
    , t0.char2 AS char2
FROM test_missing_p_k_entity2 t0;
, DEFAULT_OUTPUTsql/ORACLE/View/test_missing_p_k_entity_nt.sql=CREATE OR REPLACE VIEW test_missing_p_k_entity_nt AS SELECT
    -- columns of java class BoxedTypes
    t0.byte1 AS byte1
    , t0.short1 AS short1
    , t0.int1 AS int1
    , t0.int2 AS int2
    , t0.long1 AS long1
    , t0.boolean1 AS boolean1
    , t0.float1 AS float1
    , t0.double1 AS double1
    , t0.char1 AS char1
    , t0.char2 AS char2
FROM test_missing_p_k_entity t0;
, DEFAULT_OUTPUTsql/ORACLE/View/test_missing_p_k_entity_v.sql=CREATE OR REPLACE VIEW test_missing_p_k_entity_v AS SELECT
    -- columns of java class BoxedTypes
    t0.byte1 AS byte1
    , t0.short1 AS short1
    , t0.int1 AS int1
    , t0.int2 AS int2
    , t0.long1 AS long1
    , t0.boolean1 AS boolean1
    , t0.float1 AS float1
    , t0.double1 AS double1
    , t0.char1 AS char1
    , t0.char2 AS char2
FROM test_missing_p_k_entity t0;
, DEFAULT_OUTPUTsql/ORACLE/View/test_other_types_entity_nt.sql=CREATE OR REPLACE VIEW test_other_types_entity_nt AS SELECT
    -- columns of java class OtherTypes
    t0.raw1 AS raw1
    , t0.binary1 AS binary1
    , t0.day1 AS day1
    , t0.timestamp1 AS timestamp1
    , t0.timestamp2 AS timestamp2
    , t0.timestamp3 AS timestamp3
    , t0.timestamp4 AS timestamp4
    , t0.ascii1 AS ascii1
    , t0.unicode1 AS unicode1
    , t0.number1 AS number1
    , t0.decimal1 AS decimal1
    , Color2s(t0.color1) AS color1
    , AlphaColor2s(t0.color2) AS color2
    , VariableLength2s(t0.var_enum1) AS var_enum1
    , VariableLengthUnicode2s(t0.var_enum2) AS var_enum2
    , t0.my_uuid AS my_uuid
    , t0.country_code AS country_code
    , t0.language_code AS language_code
    , t0.timestamp1a AS timestamp1a
    , t0.timestamp2a AS timestamp2a
    , t0.timestamp3a AS timestamp3a
    , t0.timestamp4a AS timestamp4a
FROM test_other_types_entity t0;
, DEFAULT_OUTPUTsql/ORACLE/View/test_other_types_entity_v.sql=CREATE OR REPLACE VIEW test_other_types_entity_v AS SELECT
    -- columns of java class OtherTypes
    t0.raw1 AS raw1
    , t0.binary1 AS binary1
    , t0.day1 AS day1
    , t0.timestamp1 AS timestamp1
    , t0.timestamp2 AS timestamp2
    , t0.timestamp3 AS timestamp3
    , t0.timestamp4 AS timestamp4
    , t0.ascii1 AS ascii1
    , t0.unicode1 AS unicode1
    , t0.number1 AS number1
    , t0.decimal1 AS decimal1
    , Color2s(t0.color1) AS color1
    , AlphaColor2s(t0.color2) AS color2
    , VariableLength2s(t0.var_enum1) AS var_enum1
    , VariableLengthUnicode2s(t0.var_enum2) AS var_enum2
    , t0.my_uuid AS my_uuid
    , t0.country_code AS country_code
    , t0.language_code AS language_code
    , t0.timestamp1a AS timestamp1a
    , t0.timestamp2a AS timestamp2a
    , t0.timestamp3a AS timestamp3a
    , t0.timestamp4a AS timestamp4a
FROM test_other_types_entity t0;
, DEFAULT_OUTPUTsql/ORACLE/View/tests_embedded_pk_entity_nt.sql=CREATE OR REPLACE VIEW tests_embedded_pk_entity_nt AS SELECT
    -- columns of java class EDto
    t0.key1 AS key1
    , t0.key2 AS key2
    , t0.data AS data
FROM tests_embedded_pk_entity t0;
, DEFAULT_OUTPUTsql/ORACLE/View/tests_embedded_pk_entity_v.sql=CREATE OR REPLACE VIEW tests_embedded_pk_entity_v AS SELECT
    -- columns of java class EDto
    t0.key1 AS key1
    , t0.key2 AS key2
    , t0.data AS data
FROM tests_embedded_pk_entity t0;
, DEFAULT_OUTPUTsql/ORACLE/View/tests_id_class_pk_entity_nt.sql=CREATE OR REPLACE VIEW tests_id_class_pk_entity_nt AS SELECT
    -- columns of java class EDto2
    t0.key1 AS key1
    , t0.key2 AS key2
    , t0.data AS data
FROM tests_id_class_pk_entity t0;
, DEFAULT_OUTPUTsql/ORACLE/View/tests_id_class_pk_entity_v.sql=CREATE OR REPLACE VIEW tests_id_class_pk_entity_v AS SELECT
    -- columns of java class EDto2
    t0.key1 AS key1
    , t0.key2 AS key2
    , t0.data AS data
FROM tests_id_class_pk_entity t0;
, DEFAULT_OUTPUTsql/ORACLE/View/tests_item_entity_nt.sql=CREATE OR REPLACE VIEW tests_item_entity_nt AS SELECT
    -- columns of java class Item
    t0.dummy_ref AS dummy_ref
    , t0.item_no AS item_no
    , t0.item_text AS item_text
FROM tests_item_entity t0;
, DEFAULT_OUTPUTsql/ORACLE/View/tests_item_entity_v.sql=CREATE OR REPLACE VIEW tests_item_entity_v AS SELECT
    -- columns of java class Item
    t0.dummy_ref AS dummy_ref
    , t0.item_no AS item_no
    , t0.item_text AS item_text
FROM tests_item_entity t0;
, DEFAULT_OUTPUTsql/ORACLE/View/tests_multi_field_pk_entity_nt.sql=CREATE OR REPLACE VIEW tests_multi_field_pk_entity_nt AS SELECT
    -- columns of java class EDto2
    t0.key1 AS key1
    , t0.key2 AS key2
    , t0.data AS data
FROM tests_multi_field_pk_entity t0;
, DEFAULT_OUTPUTsql/ORACLE/View/tests_multi_field_pk_entity_v.sql=CREATE OR REPLACE VIEW tests_multi_field_pk_entity_v AS SELECT
    -- columns of java class EDto2
    t0.key1 AS key1
    , t0.key2 AS key2
    , t0.data AS data
FROM tests_multi_field_pk_entity t0;
, DEFAULT_OUTPUTsql/ORACLE/View/tests_no_pk_entity_nt.sql=CREATE OR REPLACE VIEW tests_no_pk_entity_nt AS SELECT
    -- columns of java class EDto
    t0.my_composite_key AS my_composite_key
    , t0.data AS data
FROM tests_no_pk_entity t0;
, DEFAULT_OUTPUTsql/ORACLE/View/tests_no_pk_entity_v.sql=CREATE OR REPLACE VIEW tests_no_pk_entity_v AS SELECT
    -- columns of java class EDto
    t0.my_composite_key AS my_composite_key
    , t0.data AS data
FROM tests_no_pk_entity t0;
, DEFAULT_OUTPUTsql/ORACLE/View/tests_one_field_pk_entity_nt.sql=CREATE OR REPLACE VIEW tests_one_field_pk_entity_nt AS SELECT
    -- columns of java class EDto
    t0.my_composite_key AS my_composite_key
    , t0.data AS data
FROM tests_one_field_pk_entity t0;
, DEFAULT_OUTPUTsql/ORACLE/View/tests_one_field_pk_entity_v.sql=CREATE OR REPLACE VIEW tests_one_field_pk_entity_v AS SELECT
    -- columns of java class EDto
    t0.my_composite_key AS my_composite_key
    , t0.data AS data
FROM tests_one_field_pk_entity t0;
, DEFAULT_OUTPUTsql/ORACLE/View/tests_parent_entity_nt.sql=CREATE OR REPLACE VIEW tests_parent_entity_nt AS SELECT
    -- columns of java class Parent
    t0.key AS key
    , t0.text AS text
FROM tests_parent_entity t0;
, DEFAULT_OUTPUTsql/ORACLE/View/tests_parent_entity_v.sql=CREATE OR REPLACE VIEW tests_parent_entity_v AS SELECT
    -- columns of java class Parent
    t0.key AS key
    , t0.text AS text
FROM tests_parent_entity t0;
, DEFAULT_OUTPUTsql/ORACLE/View/tests_test_entity_nt.sql=CREATE OR REPLACE VIEW tests_test_entity_nt AS SELECT
    -- columns of java class TestObject
    t0.my_key AS my_key
    , t0.parent_ref AS parent_ref
    , t0.name AS name
FROM tests_test_entity t0;
, DEFAULT_OUTPUTsql/ORACLE/View/tests_test_entity_v.sql=CREATE OR REPLACE VIEW tests_test_entity_v AS SELECT
    -- columns of java class TestObject
    t0.my_key AS my_key
    , t0.parent_ref AS parent_ref
    , t0.name AS name
FROM tests_test_entity t0;
, DEFAULT_OUTPUTsql/POSTGRES/Function/AlphaColor.sql=-- convert a token (as stored in DB tables) of enum tests1.AlphaColor into the more readable symbolic constant string
CREATE OR REPLACE FUNCTION AlphaColor2s(token VARCHAR) RETURNS VARCHAR
    IMMUTABLE STRICT
    AS $$
DECLARE
BEGIN
    IF token = 'R' THEN
        RETURN 'RED';
    END IF;
    IF token = 'G' THEN
        RETURN 'GREEN';
    END IF;
    IF token = 'B' THEN
        RETURN 'BLUE';
    END IF;
    RETURN '~';  -- token for undefined mapping
END;
$$ LANGUAGE plpgsql;

-- convert a constant string of enum tests1.AlphaColor into the token used for DB table storage
CREATE OR REPLACE FUNCTION AlphaColor2t(token VARCHAR) RETURNS VARCHAR
    IMMUTABLE STRICT
    AS $$
DECLARE
BEGIN
    IF token = 'RED' THEN
        RETURN 'R';
    END IF;
    IF token = 'GREEN' THEN
        RETURN 'G';
    END IF;
    IF token = 'BLUE' THEN
        RETURN 'B';
    END IF;
    RETURN '~';  -- token for undefined mapping
END;
$$ LANGUAGE plpgsql;
, DEFAULT_OUTPUTsql/POSTGRES/Function/Color.sql=-- convert a token (as stored in DB tables) of enum tests1.Color into the more readable symbolic constant string
CREATE OR REPLACE FUNCTION Color2s(token INTEGER) RETURNS VARCHAR
    IMMUTABLE STRICT
    AS $$
DECLARE
BEGIN
    IF token = 0 THEN
        RETURN 'RED';
    END IF;
    IF token = 1 THEN
        RETURN 'GREEN';
    END IF;
    IF token = 2 THEN
        RETURN 'BLUE';
    END IF;
    RETURN '~';  -- token for undefined mapping
END;
$$ LANGUAGE plpgsql;

-- convert a constant string of enum tests1.Color into the token used for DB table storage (which matches the Java enum ordinal())
CREATE OR REPLACE FUNCTION Color2t(token VARCHAR) RETURNS INTEGER
    IMMUTABLE STRICT
    AS $$
DECLARE
BEGIN
    IF token = 'RED' THEN
        RETURN 0;
    END IF;
    IF token = 'GREEN' THEN
        RETURN 1;
    END IF;
    IF token = 'BLUE' THEN
        RETURN 2;
    END IF;
    RETURN -1;  -- token for undefined mapping
END;
$$ LANGUAGE plpgsql;
, DEFAULT_OUTPUTsql/POSTGRES/Function/VariableLength.sql=-- convert a token (as stored in DB tables) of enum tests1.VariableLength into the more readable symbolic constant string
CREATE OR REPLACE FUNCTION VariableLength2s(token VARCHAR) RETURNS VARCHAR
    IMMUTABLE STRICT
    AS $$
DECLARE
BEGIN
    IF token = '1' THEN
        RETURN 'ONE';
    END IF;
    IF token = '' THEN
        RETURN 'NULL';
    END IF;
    IF token = 'This is a long text' THEN
        RETURN 'LONG';
    END IF;
    RETURN '~';  -- token for undefined mapping
END;
$$ LANGUAGE plpgsql;

-- convert a constant string of enum tests1.VariableLength into the token used for DB table storage
CREATE OR REPLACE FUNCTION VariableLength2t(token VARCHAR) RETURNS VARCHAR
    IMMUTABLE STRICT
    AS $$
DECLARE
BEGIN
    IF token = 'ONE' THEN
        RETURN '1';
    END IF;
    IF token = 'NULL' THEN
        RETURN '';
    END IF;
    IF token = 'LONG' THEN
        RETURN 'This is a long text';
    END IF;
    RETURN '~';  -- token for undefined mapping
END;
$$ LANGUAGE plpgsql;
, DEFAULT_OUTPUTsql/POSTGRES/Function/VariableLengthUnicode.sql=-- convert a token (as stored in DB tables) of enum tests1.VariableLengthUnicode into the more readable symbolic constant string
CREATE OR REPLACE FUNCTION VariableLengthUnicode2s(token VARCHAR) RETURNS VARCHAR
    IMMUTABLE STRICT
    AS $$
DECLARE
BEGIN
    IF token = 'Jäh!' THEN
        RETURN 'UMLAUT';
    END IF;
    IF token = '€' THEN
        RETURN 'EURO';
    END IF;
    RETURN '~';  -- token for undefined mapping
END;
$$ LANGUAGE plpgsql;

-- convert a constant string of enum tests1.VariableLengthUnicode into the token used for DB table storage
CREATE OR REPLACE FUNCTION VariableLengthUnicode2t(token VARCHAR) RETURNS VARCHAR
    IMMUTABLE STRICT
    AS $$
DECLARE
BEGIN
    IF token = 'UMLAUT' THEN
        RETURN 'Jäh!';
    END IF;
    IF token = 'EURO' THEN
        RETURN '€';
    END IF;
    RETURN '~';  -- token for undefined mapping
END;
$$ LANGUAGE plpgsql;
, DEFAULT_OUTPUTsql/POSTGRES/Table/jp_cfg_person.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE jp_cfg_person (
    -- table columns of java class Tracking
      user_id varchar(8)
    -- table columns of java class Person
    , person_key bigint NOT NULL
    , name varchar(20)
    , home_street varchar(20)
    , home_zip_code varchar(10)
    , home_city varchar(30)
    , street_work varchar(20)
    , zip_code_work varchar(10)
    , city_work varchar(30)
    , ex_street_tra varchar(20)
    , ex_zip_code_tra varchar(10)
    , ex_city_tra varchar(30)
    , address_lines01 varchar(80)
    , address_lines02 varchar(80)
    , address_lines03 varchar(80)
    , streetx001 varchar(20)
    , zip_codex001 varchar(10)
    , cityx001 varchar(30)
    , streetx002 varchar(20)
    , zip_codex002 varchar(10)
    , cityx002 varchar(30)
    , streetx003 varchar(20)
    , zip_codex003 varchar(10)
    , cityx003 varchar(30)
    , my_data1 varchar(10)
    , my_props01 varchar(10)
    , my_props02 varchar(10)
    , my_props03 varchar(10)
    , my_props04 varchar(10)
);

ALTER TABLE jp_cfg_person ADD CONSTRAINT jp_cfg_person_pk PRIMARY KEY (
    person_key
);
GRANT SELECT ON jp_cfg_person TO jpawro;
GRANT SELECT,INSERT,UPDATE,DELETE ON jp_cfg_person TO jpawrw;

-- comments for columns of java class Tracking
-- comments for columns of java class Person
, DEFAULT_OUTPUTsql/POSTGRES/Table/test_boxed_types_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE test_boxed_types_entity (
    -- table columns of java class BoxedTypes
      byte1 smallint
    , short1 smallint
    , int1 integer NOT NULL
    , int2 integer
    , long1 bigint
    , boolean1 boolean
    , float1 real
    , double1 double precision
    , char1 char(1)
    , char2 char(1)
);

ALTER TABLE test_boxed_types_entity ADD CONSTRAINT test_boxed_types_entity_pk PRIMARY KEY (
    int1
);
GRANT SELECT,INSERT,UPDATE,DELETE ON test_boxed_types_entity TO demorole;

-- comments for columns of java class BoxedTypes
, DEFAULT_OUTPUTsql/POSTGRES/Table/test_missing_p_k_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE test_missing_p_k_entity (
    -- table columns of java class BoxedTypes
      byte1 smallint
    , short1 smallint
    , int1 integer
    , int2 integer
    , long1 bigint
    , boolean1 boolean
    , float1 real
    , double1 double precision
    , char1 char(1)
    , char2 char(1)
);

GRANT SELECT,INSERT,UPDATE,DELETE ON test_missing_p_k_entity TO demorole;

-- comments for columns of java class BoxedTypes
, DEFAULT_OUTPUTsql/POSTGRES/Table/test_missing_p_k_entity2.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE test_missing_p_k_entity2 (
    -- table columns of java class BoxedTypes
      byte1 smallint
    , short1 smallint
    , int1 integer NOT NULL
    , int2 integer
    , long1 bigint
    , boolean1 boolean
    , float1 real
    , double1 double precision
    , char1 char(1)
    , char2 char(1)
);

ALTER TABLE test_missing_p_k_entity2 ADD CONSTRAINT test_missing_p_k_entity2_pk PRIMARY KEY (
    int1
);
GRANT SELECT,INSERT,UPDATE,DELETE ON test_missing_p_k_entity2 TO demorole;

-- comments for columns of java class BoxedTypes
, DEFAULT_OUTPUTsql/POSTGRES/Table/test_other_types_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE test_other_types_entity (
    -- table columns of java class OtherTypes
      raw1 bytea NOT NULL
    , binary1 bytea NOT NULL
    , day1 date NOT NULL
    , timestamp1 timestamp(0) NOT NULL
    , timestamp2 timestamp(3) NOT NULL
    , timestamp3 timestamp(0) NOT NULL
    , timestamp4 timestamp(3) NOT NULL
    , ascii1 varchar(30) NOT NULL
    , unicode1 varchar(30) NOT NULL
    , number1 numeric(4) NOT NULL
    , decimal1 decimal(14,2) NOT NULL
    , color1 smallint NOT NULL
    , color2 varchar(1) NOT NULL
    , var_enum1 varchar(19) NOT NULL
    , var_enum2 varchar(4) NOT NULL
    , my_uuid uuid NOT NULL
    , country_code varchar(2) NOT NULL
    , language_code varchar(5)
    , timestamp1a timestamp(0) NOT NULL
    , timestamp2a timestamp(3) NOT NULL
    , timestamp3a timestamp(0) NOT NULL
    , timestamp4a timestamp(3) NOT NULL
);

ALTER TABLE test_other_types_entity ADD CONSTRAINT test_other_types_entity_pk PRIMARY KEY (
    number1
);
GRANT SELECT,INSERT,UPDATE,DELETE ON test_other_types_entity TO demorole;

-- comments for columns of java class OtherTypes
, DEFAULT_OUTPUTsql/POSTGRES/Table/tests_embedded_pk_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_embedded_pk_entity (
    -- table columns of java class EDto
      key1 varchar(8)
    , key2 integer
    , data varchar(80)
);

ALTER TABLE tests_embedded_pk_entity ADD CONSTRAINT tests_embedded_pk_entity_pk PRIMARY KEY (
    key1, key2
);
GRANT SELECT,INSERT,UPDATE,DELETE ON tests_embedded_pk_entity TO demorole;

-- comments for columns of java class EDto
, DEFAULT_OUTPUTsql/POSTGRES/Table/tests_id_class_pk_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_id_class_pk_entity (
    -- table columns of java class EDto2
      key1 varchar(8) NOT NULL
    , key2 integer NOT NULL
    , data varchar(80)
);

ALTER TABLE tests_id_class_pk_entity ADD CONSTRAINT tests_id_class_pk_entity_pk PRIMARY KEY (
    key1, key2
);
GRANT SELECT,INSERT,UPDATE,DELETE ON tests_id_class_pk_entity TO demorole;

-- comments for columns of java class EDto2
, DEFAULT_OUTPUTsql/POSTGRES/Table/tests_item_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_item_entity (
    -- table columns of java class Item
      dummy_ref bigint NOT NULL
    , item_no integer NOT NULL
    , item_text varchar(80)
);

ALTER TABLE tests_item_entity ADD CONSTRAINT tests_item_entity_pk PRIMARY KEY (
    dummy_ref, item_no
);
GRANT SELECT,INSERT,UPDATE,DELETE ON tests_item_entity TO demorole;

-- comments for columns of java class Item
, DEFAULT_OUTPUTsql/POSTGRES/Table/tests_multi_field_pk_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_multi_field_pk_entity (
    -- table columns of java class EDto2
      key1 varchar(8) NOT NULL
    , key2 integer NOT NULL
    , data varchar(80)
);

ALTER TABLE tests_multi_field_pk_entity ADD CONSTRAINT tests_multi_field_pk_entity_pk PRIMARY KEY (
    key1, key2
);
GRANT SELECT,INSERT,UPDATE,DELETE ON tests_multi_field_pk_entity TO demorole;

-- comments for columns of java class EDto2
, DEFAULT_OUTPUTsql/POSTGRES/Table/tests_no_pk_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_no_pk_entity (
    -- table columns of java class EDto
      my_composite_key bigint
    , data varchar(80)
);

GRANT SELECT,INSERT,UPDATE,DELETE ON tests_no_pk_entity TO demorole;

-- comments for columns of java class EDto
, DEFAULT_OUTPUTsql/POSTGRES/Table/tests_one_field_pk_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_one_field_pk_entity (
    -- table columns of java class EDto
      my_composite_key bigint
    , data varchar(80) NOT NULL
);

ALTER TABLE tests_one_field_pk_entity ADD CONSTRAINT tests_one_field_pk_entity_pk PRIMARY KEY (
    data
);
GRANT SELECT,INSERT,UPDATE,DELETE ON tests_one_field_pk_entity TO demorole;

-- comments for columns of java class EDto
, DEFAULT_OUTPUTsql/POSTGRES/Table/tests_parent_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_parent_entity (
    -- table columns of java class Parent
      key bigint NOT NULL
    , text varchar(80)
);

ALTER TABLE tests_parent_entity ADD CONSTRAINT tests_parent_entity_pk PRIMARY KEY (
    key
);
GRANT SELECT,INSERT,UPDATE,DELETE ON tests_parent_entity TO demorole;

-- comments for columns of java class Parent
, DEFAULT_OUTPUTsql/POSTGRES/Table/tests_test_entity.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE tests_test_entity (
    -- table columns of java class TestObject
      my_key bigint NOT NULL
    , parent_ref bigint NOT NULL
    , name varchar(80)
);

ALTER TABLE tests_test_entity ADD CONSTRAINT tests_test_entity_pk PRIMARY KEY (
    my_key
);
GRANT SELECT,INSERT,UPDATE,DELETE ON tests_test_entity TO demorole;

-- comments for columns of java class TestObject
, DEFAULT_OUTPUTsql/POSTGRES/Table/the_other_table.sql=-- This source has been automatically created by the bonaparte DSL (persistence addon). Do not modify, changes will be lost.
-- The bonaparte DSL is open source, licensed under Apache License, Version 2.0. It is based on Eclipse Xtext2.
-- The sources for bonaparte-DSL can be obtained at www.github.com/jpaw/bonaparte-dsl.git

CREATE TABLE the_other_table (
    -- tenant
    -- base table PK
      my_key bigint NOT NULL
    -- element collection key
    , currency_code varchar(255) NOT NULL,
    -- contents field
    , prices decimal(14,2)
);

ALTER TABLE the_other_table ADD CONSTRAINT the_other_table_pk PRIMARY KEY (
    my_key, currency_code
);
, DEFAULT_OUTPUTsql/POSTGRES/View/jp_cfg_person_nt.sql=CREATE OR REPLACE VIEW jp_cfg_person_nt AS SELECT
    -- columns of java class Person
    t0.person_key AS person_key
    , t0.name AS name
    , t0.home_street AS home_street
    , t0.home_zip_code AS home_zip_code
    , t0.home_city AS home_city
    , t0.street_work AS street_work
    , t0.zip_code_work AS zip_code_work
    , t0.city_work AS city_work
    , t0.ex_street_tra AS ex_street_tra
    , t0.ex_zip_code_tra AS ex_zip_code_tra
    , t0.ex_city_tra AS ex_city_tra
    , t0.address_lines01 AS address_lines01
    , t0.address_lines02 AS address_lines02
    , t0.address_lines03 AS address_lines03
    , t0.streetx001 AS streetx001
    , t0.zip_codex001 AS zip_codex001
    , t0.cityx001 AS cityx001
    , t0.streetx002 AS streetx002
    , t0.zip_codex002 AS zip_codex002
    , t0.cityx002 AS cityx002
    , t0.streetx003 AS streetx003
    , t0.zip_codex003 AS zip_codex003
    , t0.cityx003 AS cityx003
    , t0.my_data1 AS my_data1
    , t0.my_props01 AS my_props01
    , t0.my_props02 AS my_props02
    , t0.my_props03 AS my_props03
    , t0.my_props04 AS my_props04
FROM jp_cfg_person t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/jp_cfg_person_v.sql=CREATE OR REPLACE VIEW jp_cfg_person_v AS SELECT
    -- columns of java class Tracking
    t0.user_id AS user_id
    -- columns of java class Person
    , t0.person_key AS person_key
    , t0.name AS name
    , t0.home_street AS home_street
    , t0.home_zip_code AS home_zip_code
    , t0.home_city AS home_city
    , t0.street_work AS street_work
    , t0.zip_code_work AS zip_code_work
    , t0.city_work AS city_work
    , t0.ex_street_tra AS ex_street_tra
    , t0.ex_zip_code_tra AS ex_zip_code_tra
    , t0.ex_city_tra AS ex_city_tra
    , t0.address_lines01 AS address_lines01
    , t0.address_lines02 AS address_lines02
    , t0.address_lines03 AS address_lines03
    , t0.streetx001 AS streetx001
    , t0.zip_codex001 AS zip_codex001
    , t0.cityx001 AS cityx001
    , t0.streetx002 AS streetx002
    , t0.zip_codex002 AS zip_codex002
    , t0.cityx002 AS cityx002
    , t0.streetx003 AS streetx003
    , t0.zip_codex003 AS zip_codex003
    , t0.cityx003 AS cityx003
    , t0.my_data1 AS my_data1
    , t0.my_props01 AS my_props01
    , t0.my_props02 AS my_props02
    , t0.my_props03 AS my_props03
    , t0.my_props04 AS my_props04
FROM jp_cfg_person t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/test_boxed_types_entity_nt.sql=CREATE OR REPLACE VIEW test_boxed_types_entity_nt AS SELECT
    -- columns of java class BoxedTypes
    t0.byte1 AS byte1
    , t0.short1 AS short1
    , t0.int1 AS int1
    , t0.int2 AS int2
    , t0.long1 AS long1
    , t0.boolean1 AS boolean1
    , t0.float1 AS float1
    , t0.double1 AS double1
    , t0.char1 AS char1
    , t0.char2 AS char2
FROM test_boxed_types_entity t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/test_boxed_types_entity_v.sql=CREATE OR REPLACE VIEW test_boxed_types_entity_v AS SELECT
    -- columns of java class BoxedTypes
    t0.byte1 AS byte1
    , t0.short1 AS short1
    , t0.int1 AS int1
    , t0.int2 AS int2
    , t0.long1 AS long1
    , t0.boolean1 AS boolean1
    , t0.float1 AS float1
    , t0.double1 AS double1
    , t0.char1 AS char1
    , t0.char2 AS char2
FROM test_boxed_types_entity t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/test_missing_p_k_entity2_nt.sql=CREATE OR REPLACE VIEW test_missing_p_k_entity2_nt AS SELECT
    -- columns of java class BoxedTypes
    t0.byte1 AS byte1
    , t0.short1 AS short1
    , t0.int1 AS int1
    , t0.int2 AS int2
    , t0.long1 AS long1
    , t0.boolean1 AS boolean1
    , t0.float1 AS float1
    , t0.double1 AS double1
    , t0.char1 AS char1
    , t0.char2 AS char2
FROM test_missing_p_k_entity2 t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/test_missing_p_k_entity2_v.sql=CREATE OR REPLACE VIEW test_missing_p_k_entity2_v AS SELECT
    -- columns of java class BoxedTypes
    t0.byte1 AS byte1
    , t0.short1 AS short1
    , t0.int1 AS int1
    , t0.int2 AS int2
    , t0.long1 AS long1
    , t0.boolean1 AS boolean1
    , t0.float1 AS float1
    , t0.double1 AS double1
    , t0.char1 AS char1
    , t0.char2 AS char2
FROM test_missing_p_k_entity2 t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/test_missing_p_k_entity_nt.sql=CREATE OR REPLACE VIEW test_missing_p_k_entity_nt AS SELECT
    -- columns of java class BoxedTypes
    t0.byte1 AS byte1
    , t0.short1 AS short1
    , t0.int1 AS int1
    , t0.int2 AS int2
    , t0.long1 AS long1
    , t0.boolean1 AS boolean1
    , t0.float1 AS float1
    , t0.double1 AS double1
    , t0.char1 AS char1
    , t0.char2 AS char2
FROM test_missing_p_k_entity t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/test_missing_p_k_entity_v.sql=CREATE OR REPLACE VIEW test_missing_p_k_entity_v AS SELECT
    -- columns of java class BoxedTypes
    t0.byte1 AS byte1
    , t0.short1 AS short1
    , t0.int1 AS int1
    , t0.int2 AS int2
    , t0.long1 AS long1
    , t0.boolean1 AS boolean1
    , t0.float1 AS float1
    , t0.double1 AS double1
    , t0.char1 AS char1
    , t0.char2 AS char2
FROM test_missing_p_k_entity t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/test_other_types_entity_nt.sql=CREATE OR REPLACE VIEW test_other_types_entity_nt AS SELECT
    -- columns of java class OtherTypes
    t0.raw1 AS raw1
    , t0.binary1 AS binary1
    , t0.day1 AS day1
    , t0.timestamp1 AS timestamp1
    , t0.timestamp2 AS timestamp2
    , t0.timestamp3 AS timestamp3
    , t0.timestamp4 AS timestamp4
    , t0.ascii1 AS ascii1
    , t0.unicode1 AS unicode1
    , t0.number1 AS number1
    , t0.decimal1 AS decimal1
    , Color2s(t0.color1) AS color1
    , AlphaColor2s(t0.color2) AS color2
    , VariableLength2s(t0.var_enum1) AS var_enum1
    , VariableLengthUnicode2s(t0.var_enum2) AS var_enum2
    , t0.my_uuid AS my_uuid
    , t0.country_code AS country_code
    , t0.language_code AS language_code
    , t0.timestamp1a AS timestamp1a
    , t0.timestamp2a AS timestamp2a
    , t0.timestamp3a AS timestamp3a
    , t0.timestamp4a AS timestamp4a
FROM test_other_types_entity t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/test_other_types_entity_v.sql=CREATE OR REPLACE VIEW test_other_types_entity_v AS SELECT
    -- columns of java class OtherTypes
    t0.raw1 AS raw1
    , t0.binary1 AS binary1
    , t0.day1 AS day1
    , t0.timestamp1 AS timestamp1
    , t0.timestamp2 AS timestamp2
    , t0.timestamp3 AS timestamp3
    , t0.timestamp4 AS timestamp4
    , t0.ascii1 AS ascii1
    , t0.unicode1 AS unicode1
    , t0.number1 AS number1
    , t0.decimal1 AS decimal1
    , Color2s(t0.color1) AS color1
    , AlphaColor2s(t0.color2) AS color2
    , VariableLength2s(t0.var_enum1) AS var_enum1
    , VariableLengthUnicode2s(t0.var_enum2) AS var_enum2
    , t0.my_uuid AS my_uuid
    , t0.country_code AS country_code
    , t0.language_code AS language_code
    , t0.timestamp1a AS timestamp1a
    , t0.timestamp2a AS timestamp2a
    , t0.timestamp3a AS timestamp3a
    , t0.timestamp4a AS timestamp4a
FROM test_other_types_entity t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/tests_embedded_pk_entity_nt.sql=CREATE OR REPLACE VIEW tests_embedded_pk_entity_nt AS SELECT
    -- columns of java class EDto
    t0.key1 AS key1
    , t0.key2 AS key2
    , t0.data AS data
FROM tests_embedded_pk_entity t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/tests_embedded_pk_entity_v.sql=CREATE OR REPLACE VIEW tests_embedded_pk_entity_v AS SELECT
    -- columns of java class EDto
    t0.key1 AS key1
    , t0.key2 AS key2
    , t0.data AS data
FROM tests_embedded_pk_entity t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/tests_id_class_pk_entity_nt.sql=CREATE OR REPLACE VIEW tests_id_class_pk_entity_nt AS SELECT
    -- columns of java class EDto2
    t0.key1 AS key1
    , t0.key2 AS key2
    , t0.data AS data
FROM tests_id_class_pk_entity t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/tests_id_class_pk_entity_v.sql=CREATE OR REPLACE VIEW tests_id_class_pk_entity_v AS SELECT
    -- columns of java class EDto2
    t0.key1 AS key1
    , t0.key2 AS key2
    , t0.data AS data
FROM tests_id_class_pk_entity t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/tests_item_entity_nt.sql=CREATE OR REPLACE VIEW tests_item_entity_nt AS SELECT
    -- columns of java class Item
    t0.dummy_ref AS dummy_ref
    , t0.item_no AS item_no
    , t0.item_text AS item_text
FROM tests_item_entity t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/tests_item_entity_v.sql=CREATE OR REPLACE VIEW tests_item_entity_v AS SELECT
    -- columns of java class Item
    t0.dummy_ref AS dummy_ref
    , t0.item_no AS item_no
    , t0.item_text AS item_text
FROM tests_item_entity t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/tests_multi_field_pk_entity_nt.sql=CREATE OR REPLACE VIEW tests_multi_field_pk_entity_nt AS SELECT
    -- columns of java class EDto2
    t0.key1 AS key1
    , t0.key2 AS key2
    , t0.data AS data
FROM tests_multi_field_pk_entity t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/tests_multi_field_pk_entity_v.sql=CREATE OR REPLACE VIEW tests_multi_field_pk_entity_v AS SELECT
    -- columns of java class EDto2
    t0.key1 AS key1
    , t0.key2 AS key2
    , t0.data AS data
FROM tests_multi_field_pk_entity t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/tests_no_pk_entity_nt.sql=CREATE OR REPLACE VIEW tests_no_pk_entity_nt AS SELECT
    -- columns of java class EDto
    t0.my_composite_key AS my_composite_key
    , t0.data AS data
FROM tests_no_pk_entity t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/tests_no_pk_entity_v.sql=CREATE OR REPLACE VIEW tests_no_pk_entity_v AS SELECT
    -- columns of java class EDto
    t0.my_composite_key AS my_composite_key
    , t0.data AS data
FROM tests_no_pk_entity t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/tests_one_field_pk_entity_nt.sql=CREATE OR REPLACE VIEW tests_one_field_pk_entity_nt AS SELECT
    -- columns of java class EDto
    t0.my_composite_key AS my_composite_key
    , t0.data AS data
FROM tests_one_field_pk_entity t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/tests_one_field_pk_entity_v.sql=CREATE OR REPLACE VIEW tests_one_field_pk_entity_v AS SELECT
    -- columns of java class EDto
    t0.my_composite_key AS my_composite_key
    , t0.data AS data
FROM tests_one_field_pk_entity t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/tests_parent_entity_nt.sql=CREATE OR REPLACE VIEW tests_parent_entity_nt AS SELECT
    -- columns of java class Parent
    t0.key AS key
    , t0.text AS text
FROM tests_parent_entity t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/tests_parent_entity_v.sql=CREATE OR REPLACE VIEW tests_parent_entity_v AS SELECT
    -- columns of java class Parent
    t0.key AS key
    , t0.text AS text
FROM tests_parent_entity t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/tests_test_entity_nt.sql=CREATE OR REPLACE VIEW tests_test_entity_nt AS SELECT
    -- columns of java class TestObject
    t0.my_key AS my_key
    , t0.parent_ref AS parent_ref
    , t0.name AS name
FROM tests_test_entity t0;
, DEFAULT_OUTPUTsql/POSTGRES/View/tests_test_entity_v.sql=CREATE OR REPLACE VIEW tests_test_entity_v AS SELECT
    -- columns of java class TestObject
    t0.my_key AS my_key
    , t0.parent_ref AS parent_ref
    , t0.name AS name
FROM tests_test_entity t0;
}